[{"createdAt":"2025-07-23T05:30:44.383Z","updatedAt":"2025-07-23T05:31:30.000Z","id":"fYt7IJen0aIvYo7t","name":"Shopware to Qdrant Product Import (Enhanced)","active":false,"isArchived":false,"nodes":[{"parameters":{},"id":"f8b0c5e1-8a2d-4c3e-9f1a-2b3c4d5e6f7g","name":"Manual Trigger","type":"n8n-nodes-base.manualTrigger","typeVersion":1,"position":[240,300]},{"parameters":{"url":"https://shop.held.de/api/oauth/token","sendHeaders":true,"headerParameters":{"parameters":[{"name":"Content-Type","value":"application/json"}]},"sendBody":true,"bodyParameters":{"parameters":[{"name":"grant_type","value":"client_credentials"},{"name":"client_id","value":"SWIANEPSMGTHMLJMT1BHEFAZNW"},{"name":"client_secret","value":"UVJKRGFWZENoVW9OY1ZuUktYNkN6NFRucVNVQU1VR1B0cElhUzE"}]},"options":{"timeout":30000,"retry":{"enabled":true,"maxRetries":3,"retryInterval":1000}}},"id":"a1b2c3d4-5e6f-7g8h-9i0j-1k2l3m4n5o6p","name":"Get OAuth Token","type":"n8n-nodes-base.httpRequest","typeVersion":4.1,"position":[460,300]},{"parameters":{"jsCode":"// Validate OAuth response and initialize pagination\nconst items = $input.all();\nconst response = items[0].json;\n\n// Check if we got a valid access token\nif (!response.access_token) {\n  throw new Error('Failed to obtain access token from Shopware API');\n}\n\nconsole.log('‚úÖ Successfully obtained OAuth token');\nconsole.log(`Token type: ${response.token_type}`);\nconsole.log(`Expires in: ${response.expires_in} seconds`);\n\n// Set initial pagination parameters\nconst paginationData = {\n  page: 1,\n  limit: 50, // Shopware default limit\n  totalPages: null,\n  accessToken: response.access_token,\n  allProducts: [],\n  startTime: new Date().toISOString(),\n  errors: []\n};\n\nreturn [{\n  json: paginationData\n}];"},"id":"b2c3d4e5-6f7g-8h9i-0j1k-2l3m4n5o6p7q","name":"Validate Token & Initialize","type":"n8n-nodes-base.code","typeVersion":2,"position":[680,300]},{"parameters":{"url":"=https://shop.held.de/api/product?page={{ $json.page }}&limit={{ $json.limit }}&includes[product][]=name&includes[product][]=description&includes[product][]=metaDescription&includes[product][]=price&includes[product][]=stock&includes[product][]=active&includes[product][]=manufacturerNumber&includes[product][]=ean&includes[product][]=categories&includes[product][]=properties&includes[product][]=seoUrls&includes[product][]=createdAt&includes[product][]=updatedAt","sendHeaders":true,"headerParameters":{"parameters":[{"name":"Authorization","value":"=Bearer {{ $json.accessToken }}"},{"name":"Content-Type","value":"application/json"},{"name":"Accept","value":"application/json"},{"name":"sw-include-seo-urls","value":"true"}]},"options":{"timeout":60000,"retry":{"enabled":true,"maxRetries":3,"retryInterval":2000}}},"id":"c3d4e5f6-7g8h-9i0j-1k2l-3m4n5o6p7q8r","name":"Fetch Products Page","type":"n8n-nodes-base.httpRequest","typeVersion":4.1,"position":[900,300]},{"parameters":{"jsCode":"// Process the API response with comprehensive error handling\nconst items = $input.all();\nconst response = items[0].json;\n\n// Validate API response structure\nif (!response || typeof response !== 'object') {\n  throw new Error('Invalid API response format');\n}\n\n// Extract products and pagination info with fallbacks\nconst products = response.data || [];\nconst total = response.total || 0;\nconst currentPage = response.page || 1;\nconst limit = response.limit || 50;\nconst totalPages = Math.ceil(total / limit);\n\n// Get existing data from previous iterations\nlet allProducts = $node[\"Validate Token & Initialize\"].json.allProducts || [];\nlet errors = $node[\"Validate Token & Initialize\"].json.errors || [];\n\n// Validate products data\nif (!Array.isArray(products)) {\n  const error = `Page ${currentPage}: Products data is not an array`;\n  errors.push(error);\n  console.warn('‚ö†Ô∏è ' + error);\n} else {\n  // Add current page products to the collection\n  allProducts = allProducts.concat(products);\n  console.log(`üì¶ Fetched page ${currentPage}/${totalPages} - ${products.length} products (Total: ${allProducts.length}/${total})`);\n}\n\n// Determine if we need to fetch more pages\nconst hasMorePages = currentPage < totalPages;\n\nif (hasMorePages) {\n  // Return data for next page\n  return [{\n    json: {\n      page: currentPage + 1,\n      limit: limit,\n      totalPages: totalPages,\n      accessToken: $node[\"Validate Token & Initialize\"].json.accessToken,\n      allProducts: allProducts,\n      hasMorePages: true,\n      currentTotal: allProducts.length,\n      expectedTotal: total,\n      startTime: $node[\"Validate Token & Initialize\"].json.startTime,\n      errors: errors\n    }\n  }];\n} else {\n  // All pages fetched, return final collection\n  const endTime = new Date().toISOString();\n  const duration = new Date(endTime) - new Date($node[\"Validate Token & Initialize\"].json.startTime);\n  \n  console.log(`üéâ Pagination complete! Fetched ${allProducts.length} products in ${Math.round(duration/1000)}s`);\n  \n  if (errors.length > 0) {\n    console.warn(`‚ö†Ô∏è ${errors.length} errors encountered during fetch:`);\n    errors.forEach(error => console.warn(`  - ${error}`));\n  }\n  \n  return [{\n    json: {\n      allProducts: allProducts,\n      hasMorePages: false,\n      totalProducts: allProducts.length,\n      paginationComplete: true,\n      startTime: $node[\"Validate Token & Initialize\"].json.startTime,\n      endTime: endTime,\n      duration: Math.round(duration/1000),\n      errors: errors\n    }\n  }];\n}"},"id":"d4e5f6g7-8h9i-0j1k-2l3m-4n5o6p7q8r9s","name":"Process Page & Check Pagination","type":"n8n-nodes-base.code","typeVersion":2,"position":[1120,300]},{"parameters":{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict"},"conditions":[{"id":"c1a2b3c4-d5e6-f7g8-h9i0-j1k2l3m4n5o6","leftValue":"={{ $json.hasMorePages }}","rightValue":true,"operator":{"type":"boolean","operation":"equal"}}],"combinator":"and"},"options":{}},"id":"e5f6g7h8-9i0j-1k2l-3m4n-5o6p7q8r9s0t","name":"Has More Pages?","type":"n8n-nodes-base.if","typeVersion":2,"position":[1340,300]},{"parameters":{"jsCode":"// Transform products for vector storage with enhanced error handling\nconst items = $input.all();\nconst allProducts = items[0].json.allProducts;\nconst previousErrors = items[0].json.errors || [];\n\nif (!Array.isArray(allProducts)) {\n  throw new Error('Products data is not an array');\n}\n\nconsole.log(`üîÑ Starting transformation of ${allProducts.length} products...`);\n\nconst transformedProducts = [];\nconst transformErrors = [];\n\nallProducts.forEach((product, index) => {\n  try {\n    // Validate required fields\n    if (!product || typeof product !== 'object') {\n      transformErrors.push(`Product ${index}: Invalid product object`);\n      return;\n    }\n\n    if (!product.id) {\n      transformErrors.push(`Product ${index}: Missing product ID`);\n      return;\n    }\n\n    // Safely extract and combine text fields\n    const textParts = [];\n    \n    // Add name\n    if (product.name && typeof product.name === 'string') {\n      textParts.push(product.name.trim());\n    }\n    \n    // Add description\n    if (product.description && typeof product.description === 'string') {\n      textParts.push(product.description.trim());\n    }\n    \n    // Add meta description\n    if (product.metaDescription && typeof product.metaDescription === 'string') {\n      textParts.push(product.metaDescription.trim());\n    }\n    \n    // Add properties\n    if (Array.isArray(product.properties)) {\n      const propertyTexts = product.properties\n        .filter(prop => prop && prop.name && prop.value)\n        .map(prop => `${prop.name}: ${prop.value}`);\n      if (propertyTexts.length > 0) {\n        textParts.push(propertyTexts.join(', '));\n      }\n    }\n    \n    // Add categories\n    if (Array.isArray(product.categories)) {\n      const categoryNames = product.categories\n        .filter(cat => cat && cat.name)\n        .map(cat => cat.name);\n      if (categoryNames.length > 0) {\n        textParts.push(categoryNames.join(', '));\n      }\n    }\n    \n    // Add manufacturer number\n    if (product.manufacturerNumber && typeof product.manufacturerNumber === 'string') {\n      textParts.push(product.manufacturerNumber.trim());\n    }\n    \n    // Add EAN\n    if (product.ean && typeof product.ean === 'string') {\n      textParts.push(product.ean.trim());\n    }\n\n    // Combine all text parts\n    const textContent = textParts.filter(part => part.length > 0).join(' | ');\n    \n    // Skip products with no meaningful content\n    if (textContent.trim().length === 0) {\n      transformErrors.push(`Product ${product.id}: No meaningful text content`);\n      return;\n    }\n\n    // Safely extract price information\n    let price = 0;\n    let currency = 'EUR';\n    if (Array.isArray(product.price) && product.price.length > 0) {\n      const priceObj = product.price[0];\n      if (priceObj && typeof priceObj.gross === 'number') {\n        price = priceObj.gross;\n      }\n      if (priceObj && priceObj.currencyId) {\n        currency = priceObj.currencyId;\n      }\n    }\n\n    // Prepare metadata with safe defaults\n    const metadata = {\n      id: product.id,\n      name: product.name || '',\n      price: price,\n      currency: currency,\n      stock: typeof product.stock === 'number' ? product.stock : 0,\n      active: Boolean(product.active),\n      manufacturerNumber: product.manufacturerNumber || '',\n      ean: product.ean || '',\n      categories: Array.isArray(product.categories) \n        ? product.categories.filter(cat => cat && cat.name).map(cat => cat.name)\n        : [],\n      properties: Array.isArray(product.properties) ? product.properties : [],\n      url: (Array.isArray(product.seoUrls) && product.seoUrls.length > 0) \n        ? product.seoUrls[0].seoPathInfo || ''\n        : '',\n      createdAt: product.createdAt || null,\n      updatedAt: product.updatedAt || null\n    };\n\n    transformedProducts.push({\n      pageContent: textContent,\n      metadata: metadata\n    });\n\n  } catch (error) {\n    transformErrors.push(`Product ${product.id || index}: ${error.message}`);\n  }\n});\n\nconsole.log(`‚úÖ Transformed ${transformedProducts.length} products successfully`);\nif (transformErrors.length > 0) {\n  console.warn(`‚ö†Ô∏è ${transformErrors.length} transformation errors:`);\n  transformErrors.slice(0, 10).forEach(error => console.warn(`  - ${error}`));\n  if (transformErrors.length > 10) {\n    console.warn(`  ... and ${transformErrors.length - 10} more errors`);\n  }\n}\n\n// Return transformed products with error tracking\nconst result = transformedProducts.map(product => ({ \n  json: {\n    ...product,\n    _metadata: {\n      totalErrors: previousErrors.length + transformErrors.length,\n      transformErrors: transformErrors.length\n    }\n  }\n}));\n\nif (result.length === 0) {\n  throw new Error('No products could be transformed successfully');\n}\n\nreturn result;"},"id":"f6g7h8i9-0j1k-2l3m-4n5o-6p7q8r9s0t1u","name":"Transform Products for Vector Storage","type":"n8n-nodes-base.code","typeVersion":2,"position":[1560,420]},{"parameters":{"model":"text-embedding-3-small","options":{"batchSize":100,"stripNewLines":true,"maxRetries":3}},"id":"g7h8i9j0-1k2l-3m4n-5o6p-7q8r9s0t1u2v","name":"Generate Embeddings","type":"@n8n/n8n-nodes-langchain.embeddingsOpenAi","typeVersion":1,"position":[1780,420]},{"parameters":{"mode":"insert","qdrantCollection":{"__rl":true,"value":"shopware_products","mode":"name"},"options":{"batchSize":50}},"id":"h8i9j0k1-2l3m-4n5o-6p7q-8r9s0t1u2v3w","name":"Insert into Qdrant","type":"@n8n/n8n-nodes-langchain.vectorStoreQdrant","typeVersion":1,"position":[2000,420]},{"parameters":{"jsCode":"// Comprehensive completion logging with error summary\nconst items = $input.all();\nconst totalProcessed = items.length;\n\n// Extract error information from the first item's metadata\nconst firstItem = items[0];\nconst errorInfo = firstItem?.json?._metadata || {};\n\nconst completionTime = new Date().toISOString();\n\n// Calculate processing statistics\nconst stats = {\n  totalProductsProcessed: totalProcessed,\n  totalErrors: errorInfo.totalErrors || 0,\n  transformErrors: errorInfo.transformErrors || 0,\n  successRate: totalProcessed > 0 ? ((totalProcessed / (totalProcessed + (errorInfo.totalErrors || 0))) * 100).toFixed(2) : 0\n};\n\n// Log comprehensive completion status\nconsole.log('üéâ ===== IMPORT COMPLETED =====');\nconsole.log(`üìä Products successfully processed: ${stats.totalProductsProcessed}`);\nconsole.log(`‚ö†Ô∏è Total errors encountered: ${stats.totalErrors}`);\nconsole.log(`üìà Success rate: ${stats.successRate}%`);\nconsole.log(`‚è∞ Completion time: ${completionTime}`);\nconsole.log('================================');\n\nif (stats.totalErrors > 0) {\n  console.warn('‚ö†Ô∏è Some products could not be processed. Check the logs above for details.');\n}\n\nif (totalProcessed === 0) {\n  throw new Error('No products were successfully processed!');\n}\n\nreturn [{\n  json: {\n    status: 'completed',\n    statistics: stats,\n    message: `Successfully imported ${totalProcessed} products into Qdrant`,\n    timestamp: completionTime,\n    recommendations: stats.totalErrors > 0 \n      ? ['Review error logs', 'Consider re-running for failed products', 'Check data quality in source system']\n      : ['Import completed successfully', 'Ready for chatbot integration', 'Consider setting up monitoring']\n  }\n}];"},"id":"i9j0k1l2-3m4n-5o6p-7q8r-9s0t1u2v3w4x","name":"Log Completion & Statistics","type":"n8n-nodes-base.code","typeVersion":2,"position":[2220,420]},{"parameters":{"jsCode":"// Error handler for OAuth failures\nconst error = $input.first().error;\n\nconsole.error('‚ùå OAuth Authentication Failed!');\nconsole.error(`Error: ${error.message}`);\nconsole.error('Please check:');\nconsole.error('- Shopware API credentials are correct');\nconsole.error('- Integration has proper permissions');\nconsole.error('- Shopware instance is accessible');\n\nreturn [{\n  json: {\n    status: 'failed',\n    stage: 'authentication',\n    error: error.message,\n    timestamp: new Date().toISOString(),\n    troubleshooting: [\n      'Verify client_id and client_secret',\n      'Check Shopware integration permissions',\n      'Ensure API endpoint is accessible',\n      'Review Shopware logs for authentication errors'\n    ]\n  }\n}];"},"id":"j0k1l2m3-4n5o-6p7q-8r9s-0t1u2v3w4x5y","name":"Handle OAuth Error","type":"n8n-nodes-base.code","typeVersion":2,"position":[460,480]},{"parameters":{"jsCode":"// Error handler for API fetch failures\nconst error = $input.first().error;\nconst currentPage = $node[\"Process Page & Check Pagination\"]?.json?.page || 'unknown';\n\nconsole.error(`‚ùå API Fetch Failed on page ${currentPage}!`);\nconsole.error(`Error: ${error.message}`);\nconsole.error('This could be due to:');\nconsole.error('- Network connectivity issues');\nconsole.error('- API rate limiting');\nconsole.error('- Invalid API response format');\nconsole.error('- Server-side errors');\n\nreturn [{\n  json: {\n    status: 'failed',\n    stage: 'data_fetch',\n    page: currentPage,\n    error: error.message,\n    timestamp: new Date().toISOString(),\n    troubleshooting: [\n      'Check network connectivity',\n      'Verify API endpoint availability',\n      'Review rate limiting settings',\n      'Check Shopware server logs',\n      'Try reducing batch size'\n    ]\n  }\n}];"},"id":"k1l2m3n4-5o6p-7q8r-9s0t-1u2v3w4x5y6z","name":"Handle API Error","type":"n8n-nodes-base.code","typeVersion":2,"position":[1120,480]},{"parameters":{"jsCode":"// Error handler for vector storage failures\nconst error = $input.first().error;\n\nconsole.error('‚ùå Vector Storage Failed!');\nconsole.error(`Error: ${error.message}`);\nconsole.error('This could be due to:');\nconsole.error('- Qdrant connection issues');\nconsole.error('- Invalid collection configuration');\nconsole.error('- Embedding generation failures');\nconsole.error('- Insufficient Qdrant storage space');\n\nreturn [{\n  json: {\n    status: 'failed',\n    stage: 'vector_storage',\n    error: error.message,\n    timestamp: new Date().toISOString(),\n    troubleshooting: [\n      'Verify Qdrant connection credentials',\n      'Check collection exists and is accessible',\n      'Ensure OpenAI API key is valid',\n      'Review Qdrant cluster status',\n      'Check available storage space',\n      'Verify embedding dimensions match collection config'\n    ]\n  }\n}];"},"id":"l2m3n4o5-6p7q-8r9s-0t1u-2v3w4x5y6z7a","name":"Handle Vector Storage Error","type":"n8n-nodes-base.code","typeVersion":2,"position":[2000,580]}],"connections":{"Manual Trigger":{"main":[[{"node":"Get OAuth Token","type":"main","index":0}]]},"Get OAuth Token":{"main":[[{"node":"Validate Token & Initialize","type":"main","index":0}]],"error":[[{"node":"Handle OAuth Error","type":"main","index":0}]]},"Validate Token & Initialize":{"main":[[{"node":"Fetch Products Page","type":"main","index":0}]]},"Fetch Products Page":{"main":[[{"node":"Process Page & Check Pagination","type":"main","index":0}]],"error":[[{"node":"Handle API Error","type":"main","index":0}]]},"Process Page & Check Pagination":{"main":[[{"node":"Has More Pages?","type":"main","index":0}]]},"Has More Pages?":{"main":[[{"node":"Fetch Products Page","type":"main","index":0}],[{"node":"Transform Products for Vector Storage","type":"main","index":0}]]},"Transform Products for Vector Storage":{"main":[[{"node":"Generate Embeddings","type":"main","index":0}]]},"Generate Embeddings":{"main":[[{"node":"Insert into Qdrant","type":"main","index":0}]],"error":[[{"node":"Handle Vector Storage Error","type":"main","index":0}]]},"Insert into Qdrant":{"main":[[{"node":"Log Completion & Statistics","type":"main","index":0}]],"error":[[{"node":"Handle Vector Storage Error","type":"main","index":0}]]}},"settings":{"executionOrder":"v1","saveManualExecutions":true,"callerPolicy":"workflowsFromSameOwner","errorWorkflow":{"enabled":false}},"staticData":null,"meta":null,"pinData":{},"versionId":"2","triggerCount":1,"tags":[{"createdAt":"2024-01-01T00:00:00.000Z","updatedAt":"2024-01-01T00:00:00.000Z","id":"tag1","name":"shopware"},{"createdAt":"2024-01-01T00:00:00.000Z","updatedAt":"2024-01-01T00:00:00.000Z","id":"tag2","name":"qdrant"},{"createdAt":"2024-01-01T00:00:00.000Z","updatedAt":"2024-01-01T00:00:00.000Z","id":"tag3","name":"vector-database"},{"createdAt":"2024-01-01T00:00:00.000Z","updatedAt":"2024-01-01T00:00:00.000Z","id":"tag4","name":"enhanced"}]},{"createdAt":"2025-07-23T05:35:50.581Z","updatedAt":"2024-01-01T00:00:00.000Z","id":"I4GgzudjH6STl6q6","name":"Shopware to Qdrant Product Import (Enhanced)","active":false,"isArchived":false,"nodes":[{"parameters":{},"id":"f8b0c5e1-8a2d-4c3e-9f1a-2b3c4d5e6f7g","name":"Manual Trigger","type":"n8n-nodes-base.manualTrigger","typeVersion":1,"position":[240,300]},{"parameters":{"method":"POST","url":"https://shop.held.de/api/oauth/token","sendHeaders":true,"headerParameters":{"parameters":[{"name":"Content-Type","value":"application/json"}]},"sendBody":true,"bodyParameters":{"parameters":[{"name":"grant_type","value":"client_credentials"},{"name":"client_id","value":"SWIANEPSMGTHMLJMT1BHEFAZNW"},{"name":"client_secret","value":"UVJKRGFWZENoVW9OY1ZuUktYNkN6NFRucVNVQU1VR1B0cElhUzE"}]},"options":{"timeout":30000,"retry":{"enabled":true,"maxRetries":3,"retryInterval":1000}}},"id":"a1b2c3d4-5e6f-7g8h-9i0j-1k2l3m4n5o6p","name":"Get OAuth Token","type":"n8n-nodes-base.httpRequest","typeVersion":4.1,"position":[460,300]},{"parameters":{"jsCode":"// Validate OAuth response and initialize pagination\nconst items = $input.all();\nconst response = items[0].json;\n\n// Check if we got a valid access token\nif (!response.access_token) {\n  throw new Error('Failed to obtain access token from Shopware API');\n}\n\nconsole.log('‚úÖ Successfully obtained OAuth token');\nconsole.log(`Token type: ${response.token_type}`);\nconsole.log(`Expires in: ${response.expires_in} seconds`);\n\n// Set initial pagination parameters\nconst paginationData = {\n  page: 1,\n  limit: 50, // Shopware default limit\n  totalPages: null,\n  accessToken: response.access_token,\n  allProducts: [],\n  startTime: new Date().toISOString(),\n  errors: []\n};\n\nreturn [{\n  json: paginationData\n}];"},"id":"b2c3d4e5-6f7g-8h9i-0j1k-2l3m4n5o6p7q","name":"Validate Token & Initialize","type":"n8n-nodes-base.code","typeVersion":2,"position":[680,300]},{"parameters":{"url":"=https://shop.held.de/api/product?page={{ $json.page }}&limit={{ $json.limit }}&includes[product][]=name&includes[product][]=description&includes[product][]=metaDescription&includes[product][]=price&includes[product][]=stock&includes[product][]=active&includes[product][]=manufacturerNumber&includes[product][]=ean&includes[product][]=categories&includes[product][]=properties&includes[product][]=seoUrls&includes[product][]=createdAt&includes[product][]=updatedAt","sendHeaders":true,"headerParameters":{"parameters":[{"name":"Authorization","value":"=Bearer {{ $json.accessToken }}"},{"name":"Content-Type","value":"application/json"},{"name":"Accept","value":"application/json"},{"name":"sw-include-seo-urls","value":"true"}]},"options":{"timeout":60000,"retry":{"enabled":true,"maxRetries":3,"retryInterval":2000}}},"id":"c3d4e5f6-7g8h-9i0j-1k2l-3m4n5o6p7q8r","name":"Fetch Products Page","type":"n8n-nodes-base.httpRequest","typeVersion":4.1,"position":[900,300]},{"parameters":{"jsCode":"// Process the API response with comprehensive error handling\nconst items = $input.all();\nconst response = items[0].json;\n\n// Validate API response structure\nif (!response || typeof response !== 'object') {\n  throw new Error('Invalid API response format');\n}\n\n// Extract products and pagination info with fallbacks\nconst products = response.data || [];\nconst total = response.total || 0;\nconst currentPage = response.page || 1;\nconst limit = response.limit || 50;\nconst totalPages = Math.ceil(total / limit);\n\n// Get existing data from previous iterations\nlet allProducts = $node[\"Validate Token & Initialize\"].json.allProducts || [];\nlet errors = $node[\"Validate Token & Initialize\"].json.errors || [];\n\n// Validate products data\nif (!Array.isArray(products)) {\n  const error = `Page ${currentPage}: Products data is not an array`;\n  errors.push(error);\n  console.warn('‚ö†Ô∏è ' + error);\n} else {\n  // Add current page products to the collection\n  allProducts = allProducts.concat(products);\n  console.log(`üì¶ Fetched page ${currentPage}/${totalPages} - ${products.length} products (Total: ${allProducts.length}/${total})`);\n}\n\n// Determine if we need to fetch more pages\nconst hasMorePages = currentPage < totalPages;\n\nif (hasMorePages) {\n  // Return data for next page\n  return [{\n    json: {\n      page: currentPage + 1,\n      limit: limit,\n      totalPages: totalPages,\n      accessToken: $node[\"Validate Token & Initialize\"].json.accessToken,\n      allProducts: allProducts,\n      hasMorePages: true,\n      currentTotal: allProducts.length,\n      expectedTotal: total,\n      startTime: $node[\"Validate Token & Initialize\"].json.startTime,\n      errors: errors\n    }\n  }];\n} else {\n  // All pages fetched, return final collection\n  const endTime = new Date().toISOString();\n  const duration = new Date(endTime) - new Date($node[\"Validate Token & Initialize\"].json.startTime);\n  \n  console.log(`üéâ Pagination complete! Fetched ${allProducts.length} products in ${Math.round(duration/1000)}s`);\n  \n  if (errors.length > 0) {\n    console.warn(`‚ö†Ô∏è ${errors.length} errors encountered during fetch:`);\n    errors.forEach(error => console.warn(`  - ${error}`));\n  }\n  \n  return [{\n    json: {\n      allProducts: allProducts,\n      hasMorePages: false,\n      totalProducts: allProducts.length,\n      paginationComplete: true,\n      startTime: $node[\"Validate Token & Initialize\"].json.startTime,\n      endTime: endTime,\n      duration: Math.round(duration/1000),\n      errors: errors\n    }\n  }];\n}"},"id":"d4e5f6g7-8h9i-0j1k-2l3m-4n5o6p7q8r9s","name":"Process Page & Check Pagination","type":"n8n-nodes-base.code","typeVersion":2,"position":[1120,300]},{"parameters":{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict"},"conditions":[{"id":"c1a2b3c4-d5e6-f7g8-h9i0-j1k2l3m4n5o6","leftValue":"={{ $json.hasMorePages }}","rightValue":true,"operator":{"type":"boolean","operation":"equal"}}],"combinator":"and"},"options":{}},"id":"e5f6g7h8-9i0j-1k2l-3m4n-5o6p7q8r9s0t","name":"Has More Pages?","type":"n8n-nodes-base.if","typeVersion":2,"position":[1340,300]},{"parameters":{"jsCode":"// Transform products for vector storage with enhanced error handling\nconst items = $input.all();\nconst allProducts = items[0].json.allProducts;\nconst previousErrors = items[0].json.errors || [];\n\nif (!Array.isArray(allProducts)) {\n  throw new Error('Products data is not an array');\n}\n\nconsole.log(`üîÑ Starting transformation of ${allProducts.length} products...`);\n\nconst transformedProducts = [];\nconst transformErrors = [];\n\nallProducts.forEach((product, index) => {\n  try {\n    // Validate required fields\n    if (!product || typeof product !== 'object') {\n      transformErrors.push(`Product ${index}: Invalid product object`);\n      return;\n    }\n\n    if (!product.id) {\n      transformErrors.push(`Product ${index}: Missing product ID`);\n      return;\n    }\n\n    // Safely extract and combine text fields\n    const textParts = [];\n    \n    // Add name\n    if (product.name && typeof product.name === 'string') {\n      textParts.push(product.name.trim());\n    }\n    \n    // Add description\n    if (product.description && typeof product.description === 'string') {\n      textParts.push(product.description.trim());\n    }\n    \n    // Add meta description\n    if (product.metaDescription && typeof product.metaDescription === 'string') {\n      textParts.push(product.metaDescription.trim());\n    }\n    \n    // Add properties\n    if (Array.isArray(product.properties)) {\n      const propertyTexts = product.properties\n        .filter(prop => prop && prop.name && prop.value)\n        .map(prop => `${prop.name}: ${prop.value}`);\n      if (propertyTexts.length > 0) {\n        textParts.push(propertyTexts.join(', '));\n      }\n    }\n    \n    // Add categories\n    if (Array.isArray(product.categories)) {\n      const categoryNames = product.categories\n        .filter(cat => cat && cat.name)\n        .map(cat => cat.name);\n      if (categoryNames.length > 0) {\n        textParts.push(categoryNames.join(', '));\n      }\n    }\n    \n    // Add manufacturer number\n    if (product.manufacturerNumber && typeof product.manufacturerNumber === 'string') {\n      textParts.push(product.manufacturerNumber.trim());\n    }\n    \n    // Add EAN\n    if (product.ean && typeof product.ean === 'string') {\n      textParts.push(product.ean.trim());\n    }\n\n    // Combine all text parts\n    const textContent = textParts.filter(part => part.length > 0).join(' | ');\n    \n    // Skip products with no meaningful content\n    if (textContent.trim().length === 0) {\n      transformErrors.push(`Product ${product.id}: No meaningful text content`);\n      return;\n    }\n\n    // Safely extract price information\n    let price = 0;\n    let currency = 'EUR';\n    if (Array.isArray(product.price) && product.price.length > 0) {\n      const priceObj = product.price[0];\n      if (priceObj && typeof priceObj.gross === 'number') {\n        price = priceObj.gross;\n      }\n      if (priceObj && priceObj.currencyId) {\n        currency = priceObj.currencyId;\n      }\n    }\n\n    // Prepare metadata with safe defaults\n    const metadata = {\n      id: product.id,\n      name: product.name || '',\n      price: price,\n      currency: currency,\n      stock: typeof product.stock === 'number' ? product.stock : 0,\n      active: Boolean(product.active),\n      manufacturerNumber: product.manufacturerNumber || '',\n      ean: product.ean || '',\n      categories: Array.isArray(product.categories) \n        ? product.categories.filter(cat => cat && cat.name).map(cat => cat.name)\n        : [],\n      properties: Array.isArray(product.properties) ? product.properties : [],\n      url: (Array.isArray(product.seoUrls) && product.seoUrls.length > 0) \n        ? product.seoUrls[0].seoPathInfo || ''\n        : '',\n      createdAt: product.createdAt || null,\n      updatedAt: product.updatedAt || null\n    };\n\n    transformedProducts.push({\n      pageContent: textContent,\n      metadata: metadata\n    });\n\n  } catch (error) {\n    transformErrors.push(`Product ${product.id || index}: ${error.message}`);\n  }\n});\n\nconsole.log(`‚úÖ Transformed ${transformedProducts.length} products successfully`);\nif (transformErrors.length > 0) {\n  console.warn(`‚ö†Ô∏è ${transformErrors.length} transformation errors:`);\n  transformErrors.slice(0, 10).forEach(error => console.warn(`  - ${error}`));\n  if (transformErrors.length > 10) {\n    console.warn(`  ... and ${transformErrors.length - 10} more errors`);\n  }\n}\n\n// Return transformed products with error tracking\nconst result = transformedProducts.map(product => ({ \n  json: {\n    ...product,\n    _metadata: {\n      totalErrors: previousErrors.length + transformErrors.length,\n      transformErrors: transformErrors.length\n    }\n  }\n}));\n\nif (result.length === 0) {\n  throw new Error('No products could be transformed successfully');\n}\n\nreturn result;"},"id":"f6g7h8i9-0j1k-2l3m-4n5o-6p7q8r9s0t1u","name":"Transform Products for Vector Storage","type":"n8n-nodes-base.code","typeVersion":2,"position":[1560,420]},{"parameters":{"model":"text-embedding-3-small","options":{"batchSize":100,"stripNewLines":true,"maxRetries":3}},"id":"g7h8i9j0-1k2l-3m4n-5o6p-7q8r9s0t1u2v","name":"Generate Embeddings","type":"@n8n/n8n-nodes-langchain.embeddingsOpenAi","typeVersion":1,"position":[1780,420]},{"parameters":{"mode":"insert","qdrantCollection":{"__rl":true,"value":"shopware_products","mode":"name"},"options":{"batchSize":50}},"id":"h8i9j0k1-2l3m-4n5o-6p7q-8r9s0t1u2v3w","name":"Insert into Qdrant","type":"@n8n/n8n-nodes-langchain.vectorStoreQdrant","typeVersion":1,"position":[2000,420]},{"parameters":{"jsCode":"// Comprehensive completion logging with error summary\nconst items = $input.all();\nconst totalProcessed = items.length;\n\n// Extract error information from the first item's metadata\nconst firstItem = items[0];\nconst errorInfo = firstItem?.json?._metadata || {};\n\nconst completionTime = new Date().toISOString();\n\n// Calculate processing statistics\nconst stats = {\n  totalProductsProcessed: totalProcessed,\n  totalErrors: errorInfo.totalErrors || 0,\n  transformErrors: errorInfo.transformErrors || 0,\n  successRate: totalProcessed > 0 ? ((totalProcessed / (totalProcessed + (errorInfo.totalErrors || 0))) * 100).toFixed(2) : 0\n};\n\n// Log comprehensive completion status\nconsole.log('üéâ ===== IMPORT COMPLETED =====');\nconsole.log(`üìä Products successfully processed: ${stats.totalProductsProcessed}`);\nconsole.log(`‚ö†Ô∏è Total errors encountered: ${stats.totalErrors}`);\nconsole.log(`üìà Success rate: ${stats.successRate}%`);\nconsole.log(`‚è∞ Completion time: ${completionTime}`);\nconsole.log('================================');\n\nif (stats.totalErrors > 0) {\n  console.warn('‚ö†Ô∏è Some products could not be processed. Check the logs above for details.');\n}\n\nif (totalProcessed === 0) {\n  throw new Error('No products were successfully processed!');\n}\n\nreturn [{\n  json: {\n    status: 'completed',\n    statistics: stats,\n    message: `Successfully imported ${totalProcessed} products into Qdrant`,\n    timestamp: completionTime,\n    recommendations: stats.totalErrors > 0 \n      ? ['Review error logs', 'Consider re-running for failed products', 'Check data quality in source system']\n      : ['Import completed successfully', 'Ready for chatbot integration', 'Consider setting up monitoring']\n  }\n}];"},"id":"i9j0k1l2-3m4n-5o6p-7q8r-9s0t1u2v3w4x","name":"Log Completion & Statistics","type":"n8n-nodes-base.code","typeVersion":2,"position":[2220,420]},{"parameters":{"jsCode":"// Error handler for OAuth failures\nconst error = $input.first().error;\n\nconsole.error('‚ùå OAuth Authentication Failed!');\nconsole.error(`Error: ${error.message}`);\nconsole.error('Please check:');\nconsole.error('- Shopware API credentials are correct');\nconsole.error('- Integration has proper permissions');\nconsole.error('- Shopware instance is accessible');\n\nreturn [{\n  json: {\n    status: 'failed',\n    stage: 'authentication',\n    error: error.message,\n    timestamp: new Date().toISOString(),\n    troubleshooting: [\n      'Verify client_id and client_secret',\n      'Check Shopware integration permissions',\n      'Ensure API endpoint is accessible',\n      'Review Shopware logs for authentication errors'\n    ]\n  }\n}];"},"id":"j0k1l2m3-4n5o-6p7q-8r9s-0t1u2v3w4x5y","name":"Handle OAuth Error","type":"n8n-nodes-base.code","typeVersion":2,"position":[460,480]},{"parameters":{"jsCode":"// Error handler for API fetch failures\nconst error = $input.first().error;\nconst currentPage = $node[\"Process Page & Check Pagination\"]?.json?.page || 'unknown';\n\nconsole.error(`‚ùå API Fetch Failed on page ${currentPage}!`);\nconsole.error(`Error: ${error.message}`);\nconsole.error('This could be due to:');\nconsole.error('- Network connectivity issues');\nconsole.error('- API rate limiting');\nconsole.error('- Invalid API response format');\nconsole.error('- Server-side errors');\n\nreturn [{\n  json: {\n    status: 'failed',\n    stage: 'data_fetch',\n    page: currentPage,\n    error: error.message,\n    timestamp: new Date().toISOString(),\n    troubleshooting: [\n      'Check network connectivity',\n      'Verify API endpoint availability',\n      'Review rate limiting settings',\n      'Check Shopware server logs',\n      'Try reducing batch size'\n    ]\n  }\n}];"},"id":"k1l2m3n4-5o6p-7q8r-9s0t-1u2v3w4x5y6z","name":"Handle API Error","type":"n8n-nodes-base.code","typeVersion":2,"position":[1120,480]},{"parameters":{"jsCode":"// Error handler for vector storage failures\nconst error = $input.first().error;\n\nconsole.error('‚ùå Vector Storage Failed!');\nconsole.error(`Error: ${error.message}`);\nconsole.error('This could be due to:');\nconsole.error('- Qdrant connection issues');\nconsole.error('- Invalid collection configuration');\nconsole.error('- Embedding generation failures');\nconsole.error('- Insufficient Qdrant storage space');\n\nreturn [{\n  json: {\n    status: 'failed',\n    stage: 'vector_storage',\n    error: error.message,\n    timestamp: new Date().toISOString(),\n    troubleshooting: [\n      'Verify Qdrant connection credentials',\n      'Check collection exists and is accessible',\n      'Ensure OpenAI API key is valid',\n      'Review Qdrant cluster status',\n      'Check available storage space',\n      'Verify embedding dimensions match collection config'\n    ]\n  }\n}];"},"id":"l2m3n4o5-6p7q-8r9s-0t1u-2v3w4x5y6z7a","name":"Handle Vector Storage Error","type":"n8n-nodes-base.code","typeVersion":2,"position":[2000,580]}],"connections":{"Manual Trigger":{"main":[[{"node":"Get OAuth Token","type":"main","index":0}]]},"Get OAuth Token":{"main":[[{"node":"Validate Token & Initialize","type":"main","index":0}]],"error":[[{"node":"Handle OAuth Error","type":"main","index":0}]]},"Validate Token & Initialize":{"main":[[{"node":"Fetch Products Page","type":"main","index":0}]]},"Fetch Products Page":{"main":[[{"node":"Process Page & Check Pagination","type":"main","index":0}]],"error":[[{"node":"Handle API Error","type":"main","index":0}]]},"Process Page & Check Pagination":{"main":[[{"node":"Has More Pages?","type":"main","index":0}]]},"Has More Pages?":{"main":[[{"node":"Fetch Products Page","type":"main","index":0}],[{"node":"Transform Products for Vector Storage","type":"main","index":0}]]},"Transform Products for Vector Storage":{"main":[[{"node":"Generate Embeddings","type":"main","index":0}]]},"Generate Embeddings":{"main":[[{"node":"Insert into Qdrant","type":"main","index":0}]],"error":[[{"node":"Handle Vector Storage Error","type":"main","index":0}]]},"Insert into Qdrant":{"main":[[{"node":"Log Completion & Statistics","type":"main","index":0}]],"error":[[{"node":"Handle Vector Storage Error","type":"main","index":0}]]}},"settings":{"executionOrder":"v1","saveManualExecutions":true,"callerPolicy":"workflowsFromSameOwner","errorWorkflow":{"enabled":false}},"staticData":null,"meta":null,"pinData":{},"versionId":"2","triggerCount":1,"tags":[{"createdAt":"2024-01-01T00:00:00.000Z","updatedAt":"2024-01-01T00:00:00.000Z","id":"tag1","name":"shopware"},{"createdAt":"2024-01-01T00:00:00.000Z","updatedAt":"2024-01-01T00:00:00.000Z","id":"tag2","name":"qdrant"},{"createdAt":"2024-01-01T00:00:00.000Z","updatedAt":"2024-01-01T00:00:00.000Z","id":"tag3","name":"vector-database"},{"createdAt":"2024-01-01T00:00:00.000Z","updatedAt":"2024-01-01T00:00:00.000Z","id":"tag4","name":"enhanced"}]},{"createdAt":"2025-07-23T05:38:01.905Z","updatedAt":"2024-01-01T00:00:00.000Z","id":"i6RnhP6rCz2hpRVJ","name":"Shopware to Qdrant Product Import (Fixed)","active":false,"isArchived":false,"nodes":[{"parameters":{},"id":"f8b0c5e1-8a2d-4c3e-9f1a-2b3c4d5e6f7g","name":"Manual Trigger","type":"n8n-nodes-base.manualTrigger","typeVersion":1,"position":[240,300]},{"parameters":{"method":"POST","url":"https://shop.held.de/api/oauth/token","sendHeaders":true,"headerParameters":{"parameters":[{"name":"Content-Type","value":"application/json"}]},"sendBody":true,"bodyParameters":{"parameters":[{"name":"grant_type","value":"client_credentials"},{"name":"client_id","value":"SWIANEPSMGTHMLJMT1BHEFAZNW"},{"name":"client_secret","value":"UVJKRGFWZENoVW9OY1ZuUktYNkN6NFRucVNVQU1VR1B0cElhUzE"}]},"options":{"timeout":30000,"retry":{"enabled":true,"maxRetries":3,"retryInterval":1000}}},"id":"a1b2c3d4-5e6f-7g8h-9i0j-1k2l3m4n5o6p","name":"Get OAuth Token","type":"n8n-nodes-base.httpRequest","typeVersion":4.1,"position":[460,300]},{"parameters":{"jsCode":"// Validate OAuth response and initialize pagination\nconst items = $input.all();\nconst response = items[0].json;\n\n// Check if we got a valid access token\nif (!response.access_token) {\n  throw new Error('Failed to obtain access token from Shopware API');\n}\n\nconsole.log('‚úÖ Successfully obtained OAuth token');\nconsole.log(`Token type: ${response.token_type}`);\nconsole.log(`Expires in: ${response.expires_in} seconds`);\n\n// Set initial pagination parameters\nconst paginationData = {\n  page: 1,\n  limit: 10, // Reduced for testing\n  totalPages: null,\n  accessToken: response.access_token,\n  allProducts: [],\n  startTime: new Date().toISOString(),\n  errors: []\n};\n\nreturn [{\n  json: paginationData\n}];"},"id":"b2c3d4e5-6f7g-8h9i-0j1k-2l3m4n5o6p7q","name":"Validate Token & Initialize","type":"n8n-nodes-base.code","typeVersion":2,"position":[680,300]},{"parameters":{"url":"=https://shop.held.de/api/product?page={{ $json.page }}&limit={{ $json.limit }}","sendHeaders":true,"headerParameters":{"parameters":[{"name":"Authorization","value":"=Bearer {{ $json.accessToken }}"},{"name":"Content-Type","value":"application/json"},{"name":"Accept","value":"application/json"}]},"options":{"timeout":60000,"retry":{"enabled":true,"maxRetries":3,"retryInterval":2000}}},"id":"c3d4e5f6-7g8h-9i0j-1k2l-3m4n5o6p7q8r","name":"Fetch Products Page","type":"n8n-nodes-base.httpRequest","typeVersion":4.1,"position":[900,300]},{"parameters":{"jsCode":"// Process the API response with comprehensive error handling\nconst items = $input.all();\nconst response = items[0].json;\n\n// Validate API response structure\nif (!response || typeof response !== 'object') {\n  throw new Error('Invalid API response format');\n}\n\n// Extract products and pagination info with fallbacks\nconst products = response.data || [];\nconst total = response.total || 0;\nconst currentPage = response.page || 1;\nconst limit = response.limit || 10;\nconst totalPages = Math.ceil(total / limit);\n\n// Get existing data from previous iterations\nlet allProducts = $node[\"Validate Token & Initialize\"].json.allProducts || [];\nlet errors = $node[\"Validate Token & Initialize\"].json.errors || [];\n\n// Validate products data\nif (!Array.isArray(products)) {\n  const error = `Page ${currentPage}: Products data is not an array`;\n  errors.push(error);\n  console.warn('‚ö†Ô∏è ' + error);\n} else {\n  // Add current page products to the collection\n  allProducts = allProducts.concat(products);\n  console.log(`üì¶ Fetched page ${currentPage}/${totalPages} - ${products.length} products (Total: ${allProducts.length}/${total})`);\n}\n\n// Determine if we need to fetch more pages (limit to 2 pages for testing)\nconst hasMorePages = currentPage < Math.min(totalPages, 2);\n\nif (hasMorePages) {\n  // Return data for next page\n  return [{\n    json: {\n      page: currentPage + 1,\n      limit: limit,\n      totalPages: totalPages,\n      accessToken: $node[\"Validate Token & Initialize\"].json.accessToken,\n      allProducts: allProducts,\n      hasMorePages: true,\n      currentTotal: allProducts.length,\n      expectedTotal: total,\n      startTime: $node[\"Validate Token & Initialize\"].json.startTime,\n      errors: errors\n    }\n  }];\n} else {\n  // All pages fetched, return final collection\n  const endTime = new Date().toISOString();\n  const duration = new Date(endTime) - new Date($node[\"Validate Token & Initialize\"].json.startTime);\n  \n  console.log(`üéâ Pagination complete! Fetched ${allProducts.length} products in ${Math.round(duration/1000)}s`);\n  \n  if (errors.length > 0) {\n    console.warn(`‚ö†Ô∏è ${errors.length} errors encountered during fetch:`);\n    errors.forEach(error => console.warn(`  - ${error}`));\n  }\n  \n  return [{\n    json: {\n      allProducts: allProducts,\n      hasMorePages: false,\n      totalProducts: allProducts.length,\n      paginationComplete: true,\n      startTime: $node[\"Validate Token & Initialize\"].json.startTime,\n      endTime: endTime,\n      duration: Math.round(duration/1000),\n      errors: errors\n    }\n  }];\n}"},"id":"d4e5f6g7-8h9i-0j1k-2l3m-4n5o6p7q8r9s","name":"Process Page & Check Pagination","type":"n8n-nodes-base.code","typeVersion":2,"position":[1120,300]},{"parameters":{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict"},"conditions":[{"id":"c1a2b3c4-d5e6-f7g8-h9i0-j1k2l3m4n5o6","leftValue":"={{ $json.hasMorePages }}","rightValue":true,"operator":{"type":"boolean","operation":"equal","rightType":"boolean"}}],"combinator":"and"},"options":{}},"id":"e5f6g7h8-9i0j-1k2l-3m4n-5o6p7q8r9s0t","name":"Has More Pages?","type":"n8n-nodes-base.if","typeVersion":2,"position":[1340,300]},{"parameters":{"jsCode":"// Transform products for vector storage with enhanced error handling\nconst items = $input.all();\nconst allProducts = items[0].json.allProducts;\nconst previousErrors = items[0].json.errors || [];\n\nif (!Array.isArray(allProducts)) {\n  throw new Error('Products data is not an array');\n}\n\nconsole.log(`üîÑ Starting transformation of ${allProducts.length} products...`);\n\nconst transformedProducts = [];\nconst transformErrors = [];\n\nallProducts.forEach((product, index) => {\n  try {\n    // Validate required fields\n    if (!product || typeof product !== 'object') {\n      transformErrors.push(`Product ${index}: Invalid product object`);\n      return;\n    }\n\n    if (!product.id) {\n      transformErrors.push(`Product ${index}: Missing product ID`);\n      return;\n    }\n\n    // Safely extract and combine text fields\n    const textParts = [];\n    \n    // Extract name from translations or direct field\n    let productName = product.name;\n    if (!productName && product.translations && Array.isArray(product.translations)) {\n      const translation = product.translations.find(t => t.name);\n      productName = translation?.name;\n    }\n    if (productName && typeof productName === 'string') {\n      textParts.push(productName.trim());\n    }\n    \n    // Extract description from translations or direct field\n    let productDescription = product.description;\n    if (!productDescription && product.translations && Array.isArray(product.translations)) {\n      const translation = product.translations.find(t => t.description);\n      productDescription = translation?.description;\n    }\n    if (productDescription && typeof productDescription === 'string') {\n      // Strip HTML tags from description\n      const cleanDescription = productDescription.replace(/<[^>]*>/g, ' ').replace(/\\s+/g, ' ').trim();\n      if (cleanDescription.length > 0) {\n        textParts.push(cleanDescription);\n      }\n    }\n    \n    // Add EAN if available\n    if (product.ean && typeof product.ean === 'string') {\n      textParts.push(`EAN: ${product.ean.trim()}`);\n    }\n    \n    // Add manufacturer number if available\n    if (product.manufacturerNumber && typeof product.manufacturerNumber === 'string') {\n      textParts.push(`MFG: ${product.manufacturerNumber.trim()}`);\n    }\n\n    // Combine all text parts\n    const textContent = textParts.filter(part => part.length > 0).join(' | ');\n    \n    // For products with minimal content, create basic description\n    let finalTextContent = textContent;\n    if (finalTextContent.trim().length === 0) {\n      finalTextContent = `Product ID: ${product.id}`;\n      if (product.ean) finalTextContent += ` | EAN: ${product.ean}`;\n      if (product.active) finalTextContent += ' | Active Product';\n    }\n\n    // Safely extract price information\n    let price = 0;\n    let currency = 'EUR';\n    if (Array.isArray(product.price) && product.price.length > 0) {\n      const priceObj = product.price[0];\n      if (priceObj && typeof priceObj.gross === 'number') {\n        price = priceObj.gross;\n      }\n      if (priceObj && priceObj.currencyId) {\n        currency = priceObj.currencyId;\n      }\n    }\n\n    // Prepare metadata with safe defaults\n    const metadata = {\n      id: product.id,\n      name: productName || '',\n      price: price,\n      currency: currency,\n      stock: typeof product.stock === 'number' ? product.stock : 0,\n      active: Boolean(product.active),\n      manufacturerNumber: product.manufacturerNumber || '',\n      ean: product.ean || '',\n      createdAt: product.createdAt || null,\n      updatedAt: product.updatedAt || null\n    };\n\n    transformedProducts.push({\n      pageContent: finalTextContent,\n      metadata: metadata\n    });\n\n  } catch (error) {\n    transformErrors.push(`Product ${product.id || index}: ${error.message}`);\n  }\n});\n\nconsole.log(`‚úÖ Transformed ${transformedProducts.length} products successfully`);\nif (transformErrors.length > 0) {\n  console.warn(`‚ö†Ô∏è ${transformErrors.length} transformation errors:`);\n  transformErrors.slice(0, 5).forEach(error => console.warn(`  - ${error}`));\n}\n\n// Return transformed products with error tracking\nconst result = transformedProducts.map(product => ({ \n  json: {\n    ...product,\n    _metadata: {\n      totalErrors: previousErrors.length + transformErrors.length,\n      transformErrors: transformErrors.length\n    }\n  }\n}));\n\nif (result.length === 0) {\n  throw new Error('No products could be transformed successfully');\n}\n\nreturn result;"},"id":"f6g7h8i9-0j1k-2l3m-4n5o-6p7q8r9s0t1u","name":"Transform Products for Vector Storage","type":"n8n-nodes-base.code","typeVersion":2,"position":[1560,420]},{"parameters":{"jsCode":"// Simple completion logging\nconst items = $input.all();\nconst totalProcessed = items.length;\n\nconst completionTime = new Date().toISOString();\n\n// Log completion status\nconsole.log('üéâ ===== IMPORT COMPLETED =====');\nconsole.log(`üìä Products successfully processed: ${totalProcessed}`);\nconsole.log(`‚è∞ Completion time: ${completionTime}`);\nconsole.log('================================');\n\nreturn [{\n  json: {\n    status: 'completed',\n    totalProcessed: totalProcessed,\n    message: `Successfully processed ${totalProcessed} products`,\n    timestamp: completionTime\n  }\n}];"},"id":"i9j0k1l2-3m4n-5o6p-7q8r-9s0t1u2v3w4x","name":"Log Completion & Statistics","type":"n8n-nodes-base.code","typeVersion":2,"position":[1780,420]}],"connections":{"Manual Trigger":{"main":[[{"node":"Get OAuth Token","type":"main","index":0}]]},"Get OAuth Token":{"main":[[{"node":"Validate Token & Initialize","type":"main","index":0}]]},"Validate Token & Initialize":{"main":[[{"node":"Fetch Products Page","type":"main","index":0}]]},"Fetch Products Page":{"main":[[{"node":"Process Page & Check Pagination","type":"main","index":0}]]},"Process Page & Check Pagination":{"main":[[{"node":"Has More Pages?","type":"main","index":0}]]},"Has More Pages?":{"main":[[{"node":"Fetch Products Page","type":"main","index":0}],[{"node":"Transform Products for Vector Storage","type":"main","index":0}]]},"Transform Products for Vector Storage":{"main":[[{"node":"Log Completion & Statistics","type":"main","index":0}]]}},"settings":{"executionOrder":"v1","saveManualExecutions":true,"callerPolicy":"workflowsFromSameOwner"},"staticData":null,"meta":null,"pinData":{},"versionId":"3","triggerCount":1,"tags":[{"createdAt":"2024-01-01T00:00:00.000Z","updatedAt":"2024-01-01T00:00:00.000Z","id":"tag1","name":"shopware"},{"createdAt":"2024-01-01T00:00:00.000Z","updatedAt":"2024-01-01T00:00:00.000Z","id":"tag2","name":"qdrant"},{"createdAt":"2024-01-01T00:00:00.000Z","updatedAt":"2024-01-01T00:00:00.000Z","id":"tag3","name":"vector-database"}]},{"createdAt":"2025-07-25T05:16:34.968Z","updatedAt":"2024-01-01T00:00:00.000Z","id":"9k4mpqtnDULUlqRc","name":"Shopware to Qdrant Product Import (Fixed)","active":false,"isArchived":false,"nodes":[{"parameters":{},"id":"f8b0c5e1-8a2d-4c3e-9f1a-2b3c4d5e6f7g","name":"Manual Trigger","type":"n8n-nodes-base.manualTrigger","typeVersion":1,"position":[240,300]},{"parameters":{"method":"POST","url":"https://shop.held.de/api/oauth/token","sendHeaders":true,"headerParameters":{"parameters":[{"name":"Content-Type","value":"application/json"}]},"sendBody":true,"bodyParameters":{"parameters":[{"name":"grant_type","value":"client_credentials"},{"name":"client_id","value":"SWIANEPSMGTHMLJMT1BHEFAZNW"},{"name":"client_secret","value":"UVJKRGFWZENoVW9OY1ZuUktYNkN6NFRucVNVQU1VR1B0cElhUzE"}]},"options":{"timeout":30000,"retry":{"enabled":true,"maxRetries":3,"retryInterval":1000}}},"id":"a1b2c3d4-5e6f-7g8h-9i0j-1k2l3m4n5o6p","name":"Get OAuth Token","type":"n8n-nodes-base.httpRequest","typeVersion":4.1,"position":[460,300]},{"parameters":{"jsCode":"// Validate OAuth response and initialize pagination\nconst items = $input.all();\nconst response = items[0].json;\n\n// Check if we got a valid access token\nif (!response.access_token) {\n  throw new Error('Failed to obtain access token from Shopware API');\n}\n\nconsole.log('‚úÖ Successfully obtained OAuth token');\nconsole.log(`Token type: ${response.token_type}`);\nconsole.log(`Expires in: ${response.expires_in} seconds`);\n\n// Set initial pagination parameters\nconst paginationData = {\n  page: 1,\n  limit: 10, // Reduced for testing\n  totalPages: null,\n  accessToken: response.access_token,\n  allProducts: [],\n  startTime: new Date().toISOString(),\n  errors: []\n};\n\nreturn [{\n  json: paginationData\n}];"},"id":"b2c3d4e5-6f7g-8h9i-0j1k-2l3m4n5o6p7q","name":"Validate Token & Initialize","type":"n8n-nodes-base.code","typeVersion":2,"position":[680,300]},{"parameters":{"url":"=https://shop.held.de/api/product?page={{ $json.page }}&limit={{ $json.limit }}","sendHeaders":true,"headerParameters":{"parameters":[{"name":"Authorization","value":"=Bearer {{ $json.accessToken }}"},{"name":"Content-Type","value":"application/json"},{"name":"Accept","value":"application/json"}]},"options":{"timeout":60000,"retry":{"enabled":true,"maxRetries":3,"retryInterval":2000}}},"id":"c3d4e5f6-7g8h-9i0j-1k2l-3m4n5o6p7q8r","name":"Fetch Products Page","type":"n8n-nodes-base.httpRequest","typeVersion":4.1,"position":[900,300]},{"parameters":{"jsCode":"// Process the API response with comprehensive error handling\nconst items = $input.all();\nconst response = items[0].json;\n\n// Validate API response structure\nif (!response || typeof response !== 'object') {\n  throw new Error('Invalid API response format');\n}\n\n// Extract products and pagination info with fallbacks\nconst products = response.data || [];\nconst total = response.total || 0;\nconst currentPage = response.page || 1;\nconst limit = response.limit || 10;\nconst totalPages = Math.ceil(total / limit);\n\n// Get existing data from previous iterations\nlet allProducts = $node[\"Validate Token & Initialize\"].json.allProducts || [];\nlet errors = $node[\"Validate Token & Initialize\"].json.errors || [];\n\n// Validate products data\nif (!Array.isArray(products)) {\n  const error = `Page ${currentPage}: Products data is not an array`;\n  errors.push(error);\n  console.warn('‚ö†Ô∏è ' + error);\n} else {\n  // Add current page products to the collection\n  allProducts = allProducts.concat(products);\n  console.log(`üì¶ Fetched page ${currentPage}/${totalPages} - ${products.length} products (Total: ${allProducts.length}/${total})`);\n}\n\n// Determine if we need to fetch more pages (limit to 2 pages for testing)\nconst hasMorePages = currentPage < Math.min(totalPages, 2);\n\nif (hasMorePages) {\n  // Return data for next page\n  return [{\n    json: {\n      page: currentPage + 1,\n      limit: limit,\n      totalPages: totalPages,\n      accessToken: $node[\"Validate Token & Initialize\"].json.accessToken,\n      allProducts: allProducts,\n      hasMorePages: true,\n      currentTotal: allProducts.length,\n      expectedTotal: total,\n      startTime: $node[\"Validate Token & Initialize\"].json.startTime,\n      errors: errors\n    }\n  }];\n} else {\n  // All pages fetched, return final collection\n  const endTime = new Date().toISOString();\n  const duration = new Date(endTime) - new Date($node[\"Validate Token & Initialize\"].json.startTime);\n  \n  console.log(`üéâ Pagination complete! Fetched ${allProducts.length} products in ${Math.round(duration/1000)}s`);\n  \n  if (errors.length > 0) {\n    console.warn(`‚ö†Ô∏è ${errors.length} errors encountered during fetch:`);\n    errors.forEach(error => console.warn(`  - ${error}`));\n  }\n  \n  return [{\n    json: {\n      allProducts: allProducts,\n      hasMorePages: false,\n      totalProducts: allProducts.length,\n      paginationComplete: true,\n      startTime: $node[\"Validate Token & Initialize\"].json.startTime,\n      endTime: endTime,\n      duration: Math.round(duration/1000),\n      errors: errors\n    }\n  }];\n}"},"id":"d4e5f6g7-8h9i-0j1k-2l3m-4n5o6p7q8r9s","name":"Process Page & Check Pagination","type":"n8n-nodes-base.code","typeVersion":2,"position":[1120,300]},{"parameters":{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict"},"conditions":[{"id":"c1a2b3c4-d5e6-f7g8-h9i0-j1k2l3m4n5o6","leftValue":"={{ $json.hasMorePages }}","rightValue":true,"operator":{"type":"boolean","operation":"equal","rightType":"boolean"}}],"combinator":"and"},"options":{}},"id":"e5f6g7h8-9i0j-1k2l-3m4n-5o6p7q8r9s0t","name":"Has More Pages?","type":"n8n-nodes-base.if","typeVersion":2,"position":[1340,300]},{"parameters":{"jsCode":"// Transform products for vector storage with enhanced error handling\nconst items = $input.all();\nconst allProducts = items[0].json.allProducts;\nconst previousErrors = items[0].json.errors || [];\n\nif (!Array.isArray(allProducts)) {\n  throw new Error('Products data is not an array');\n}\n\nconsole.log(`üîÑ Starting transformation of ${allProducts.length} products...`);\n\nconst transformedProducts = [];\nconst transformErrors = [];\n\nallProducts.forEach((product, index) => {\n  try {\n    // Validate required fields\n    if (!product || typeof product !== 'object') {\n      transformErrors.push(`Product ${index}: Invalid product object`);\n      return;\n    }\n\n    if (!product.id) {\n      transformErrors.push(`Product ${index}: Missing product ID`);\n      return;\n    }\n\n    // Safely extract and combine text fields\n    const textParts = [];\n    \n    // Extract name from translations or direct field\n    let productName = product.name;\n    if (!productName && product.translations && Array.isArray(product.translations)) {\n      const translation = product.translations.find(t => t.name);\n      productName = translation?.name;\n    }\n    if (productName && typeof productName === 'string') {\n      textParts.push(productName.trim());\n    }\n    \n    // Extract description from translations or direct field\n    let productDescription = product.description;\n    if (!productDescription && product.translations && Array.isArray(product.translations)) {\n      const translation = product.translations.find(t => t.description);\n      productDescription = translation?.description;\n    }\n    if (productDescription && typeof productDescription === 'string') {\n      // Strip HTML tags from description\n      const cleanDescription = productDescription.replace(/<[^>]*>/g, ' ').replace(/\\s+/g, ' ').trim();\n      if (cleanDescription.length > 0) {\n        textParts.push(cleanDescription);\n      }\n    }\n    \n    // Add EAN if available\n    if (product.ean && typeof product.ean === 'string') {\n      textParts.push(`EAN: ${product.ean.trim()}`);\n    }\n    \n    // Add manufacturer number if available\n    if (product.manufacturerNumber && typeof product.manufacturerNumber === 'string') {\n      textParts.push(`MFG: ${product.manufacturerNumber.trim()}`);\n    }\n\n    // Combine all text parts\n    const textContent = textParts.filter(part => part.length > 0).join(' | ');\n    \n    // For products with minimal content, create basic description\n    let finalTextContent = textContent;\n    if (finalTextContent.trim().length === 0) {\n      finalTextContent = `Product ID: ${product.id}`;\n      if (product.ean) finalTextContent += ` | EAN: ${product.ean}`;\n      if (product.active) finalTextContent += ' | Active Product';\n    }\n\n    // Safely extract price information\n    let price = 0;\n    let currency = 'EUR';\n    if (Array.isArray(product.price) && product.price.length > 0) {\n      const priceObj = product.price[0];\n      if (priceObj && typeof priceObj.gross === 'number') {\n        price = priceObj.gross;\n      }\n      if (priceObj && priceObj.currencyId) {\n        currency = priceObj.currencyId;\n      }\n    }\n\n    // Prepare metadata with safe defaults\n    const metadata = {\n      id: product.id,\n      name: productName || '',\n      price: price,\n      currency: currency,\n      stock: typeof product.stock === 'number' ? product.stock : 0,\n      active: Boolean(product.active),\n      manufacturerNumber: product.manufacturerNumber || '',\n      ean: product.ean || '',\n      createdAt: product.createdAt || null,\n      updatedAt: product.updatedAt || null\n    };\n\n    transformedProducts.push({\n      pageContent: finalTextContent,\n      metadata: metadata\n    });\n\n  } catch (error) {\n    transformErrors.push(`Product ${product.id || index}: ${error.message}`);\n  }\n});\n\nconsole.log(`‚úÖ Transformed ${transformedProducts.length} products successfully`);\nif (transformErrors.length > 0) {\n  console.warn(`‚ö†Ô∏è ${transformErrors.length} transformation errors:`);\n  transformErrors.slice(0, 5).forEach(error => console.warn(`  - ${error}`));\n}\n\n// Return transformed products with error tracking\nconst result = transformedProducts.map(product => ({ \n  json: {\n    ...product,\n    _metadata: {\n      totalErrors: previousErrors.length + transformErrors.length,\n      transformErrors: transformErrors.length\n    }\n  }\n}));\n\nif (result.length === 0) {\n  throw new Error('No products could be transformed successfully');\n}\n\nreturn result;"},"id":"f6g7h8i9-0j1k-2l3m-4n5o-6p7q8r9s0t1u","name":"Transform Products for Vector Storage","type":"n8n-nodes-base.code","typeVersion":2,"position":[1560,420]},{"parameters":{"operation":"insert","collection":"shopware_products","options":{"batchSize":100}},"id":"g7h8i9j0-1k2l-3m4n-5o6p-7q8r9s0t1u2v","name":"Store in Qdrant Vector DB","type":"n8n-nodes-base.qdrant","typeVersion":1,"position":[1780,420],"credentials":{"qdrantApi":{"id":"qdrant-shopware-creds","name":"Qdrant Shopware Integration"}}},{"parameters":{"jsCode":"// Enhanced completion logging with Qdrant storage results\nconst items = $input.all();\nconst totalProcessed = items.length;\nconst successfulInserts = items.filter(item => item.json && item.json.status === 'ok').length;\nconst failedInserts = totalProcessed - successfulInserts;\n\nconst completionTime = new Date().toISOString();\n\n// Log completion status\nconsole.log('üéâ ===== IMPORT COMPLETED =====');\nconsole.log(`üìä Products processed: ${totalProcessed}`);\nconsole.log(`‚úÖ Successfully stored in Qdrant: ${successfulInserts}`);\nif (failedInserts > 0) {\n  console.log(`‚ùå Failed to store: ${failedInserts}`);\n}\nconsole.log(`‚è∞ Completion time: ${completionTime}`);\nconsole.log('================================');\n\n// Check for any errors in the Qdrant responses\nconst errors = [];\nitems.forEach((item, index) => {\n  if (item.json && item.json.status !== 'ok') {\n    errors.push(`Item ${index}: ${item.json.message || 'Unknown error'}`);\n  }\n});\n\nif (errors.length > 0) {\n  console.warn('‚ö†Ô∏è Qdrant storage errors:');\n  errors.slice(0, 5).forEach(error => console.warn(`  - ${error}`));\n}\n\nreturn [{\n  json: {\n    status: 'completed',\n    totalProcessed: totalProcessed,\n    successfulInserts: successfulInserts,\n    failedInserts: failedInserts,\n    errorRate: totalProcessed > 0 ? (failedInserts / totalProcessed * 100).toFixed(2) + '%' : '0%',\n    message: `Successfully processed ${totalProcessed} products, ${successfulInserts} stored in Qdrant`,\n    timestamp: completionTime,\n    errors: errors.slice(0, 10) // Keep first 10 errors for debugging\n  }\n}];"},"id":"i9j0k1l2-3m4n-5o6p-7q8r-9s0t1u2v3w4x","name":"Log Completion & Statistics","type":"n8n-nodes-base.code","typeVersion":2,"position":[2000,420]}],"connections":{"Manual Trigger":{"main":[[{"node":"Get OAuth Token","type":"main","index":0}]]},"Get OAuth Token":{"main":[[{"node":"Validate Token & Initialize","type":"main","index":0}]]},"Validate Token & Initialize":{"main":[[{"node":"Fetch Products Page","type":"main","index":0}]]},"Fetch Products Page":{"main":[[{"node":"Process Page & Check Pagination","type":"main","index":0}]]},"Process Page & Check Pagination":{"main":[[{"node":"Has More Pages?","type":"main","index":0}]]},"Has More Pages?":{"main":[[{"node":"Fetch Products Page","type":"main","index":0}],[{"node":"Transform Products for Vector Storage","type":"main","index":0}]]},"Transform Products for Vector Storage":{"main":[[{"node":"Store in Qdrant Vector DB","type":"main","index":0}]]},"Store in Qdrant Vector DB":{"main":[[{"node":"Log Completion & Statistics","type":"main","index":0}]]}},"settings":{"executionOrder":"v1","saveManualExecutions":true,"callerPolicy":"workflowsFromSameOwner"},"staticData":null,"meta":null,"pinData":{},"versionId":"3","triggerCount":1,"tags":[{"createdAt":"2024-01-01T00:00:00.000Z","updatedAt":"2024-01-01T00:00:00.000Z","id":"tag1","name":"shopware"},{"createdAt":"2024-01-01T00:00:00.000Z","updatedAt":"2024-01-01T00:00:00.000Z","id":"tag2","name":"qdrant"},{"createdAt":"2024-01-01T00:00:00.000Z","updatedAt":"2024-01-01T00:00:00.000Z","id":"tag3","name":"vector-database"}]},{"createdAt":"2025-07-25T05:18:57.819Z","updatedAt":"2024-01-01T00:00:00.000Z","id":"7TWUffAdGfJzIkRk","name":"Shopware to Qdrant Product Import (Complete)","active":false,"isArchived":false,"nodes":[{"parameters":{},"id":"f8b0c5e1-8a2d-4c3e-9f1a-2b3c4d5e6f7g","name":"Manual Trigger","type":"n8n-nodes-base.manualTrigger","typeVersion":1,"position":[240,300]},{"parameters":{"method":"POST","url":"https://shop.held.de/api/oauth/token","sendHeaders":true,"headerParameters":{"parameters":[{"name":"Content-Type","value":"application/json"}]},"sendBody":true,"bodyParameters":{"parameters":[{"name":"grant_type","value":"client_credentials"},{"name":"client_id","value":"SWIANEPSMGTHMLJMT1BHEFAZNW"},{"name":"client_secret","value":"UVJKRGFWZENoVW9OY1ZuUktYNkN6NFRucVNVQU1VR1B0cElhUzE"}]},"options":{"timeout":30000,"retry":{"enabled":true,"maxRetries":3,"retryInterval":1000}}},"id":"a1b2c3d4-5e6f-7g8h-9i0j-1k2l3m4n5o6p","name":"Get OAuth Token","type":"n8n-nodes-base.httpRequest","typeVersion":4.1,"position":[460,300]},{"parameters":{"jsCode":"// Validate OAuth response and initialize pagination\nconst items = $input.all();\nconst response = items[0].json;\n\n// Check if we got a valid access token\nif (!response.access_token) {\n  throw new Error('Failed to obtain access token from Shopware API');\n}\n\nconsole.log('‚úÖ Successfully obtained OAuth token');\nconsole.log(`Token type: ${response.token_type}`);\nconsole.log(`Expires in: ${response.expires_in} seconds`);\n\n// Set initial pagination parameters\nconst paginationData = {\n  page: 1,\n  limit: 10, // Reduced for testing\n  totalPages: null,\n  accessToken: response.access_token,\n  allProducts: [],\n  startTime: new Date().toISOString(),\n  errors: []\n};\n\nreturn [{\n  json: paginationData\n}];"},"id":"b2c3d4e5-6f7g-8h9i-0j1k-2l3m4n5o6p7q","name":"Validate Token & Initialize","type":"n8n-nodes-base.code","typeVersion":2,"position":[680,300]},{"parameters":{"url":"=https://shop.held.de/api/product?page={{ $json.page }}&limit={{ $json.limit }}","sendHeaders":true,"headerParameters":{"parameters":[{"name":"Authorization","value":"=Bearer {{ $json.accessToken }}"},{"name":"Content-Type","value":"application/json"},{"name":"Accept","value":"application/json"}]},"options":{"timeout":60000,"retry":{"enabled":true,"maxRetries":3,"retryInterval":2000}}},"id":"c3d4e5f6-7g8h-9i0j-1k2l-3m4n5o6p7q8r","name":"Fetch Products Page","type":"n8n-nodes-base.httpRequest","typeVersion":4.1,"position":[900,300]},{"parameters":{"jsCode":"// Process the API response with comprehensive error handling\nconst items = $input.all();\nconst response = items[0].json;\n\n// Validate API response structure\nif (!response || typeof response !== 'object') {\n  throw new Error('Invalid API response format');\n}\n\n// Extract products and pagination info with fallbacks\nconst products = response.data || [];\nconst total = response.total || 0;\nconst currentPage = response.page || 1;\nconst limit = response.limit || 10;\nconst totalPages = Math.ceil(total / limit);\n\n// Get existing data from previous iterations\nlet allProducts = $node[\"Validate Token & Initialize\"].json.allProducts || [];\nlet errors = $node[\"Validate Token & Initialize\"].json.errors || [];\n\n// Validate products data\nif (!Array.isArray(products)) {\n  const error = `Page ${currentPage}: Products data is not an array`;\n  errors.push(error);\n  console.warn('‚ö†Ô∏è ' + error);\n} else {\n  // Add current page products to the collection\n  allProducts = allProducts.concat(products);\n  console.log(`üì¶ Fetched page ${currentPage}/${totalPages} - ${products.length} products (Total: ${allProducts.length}/${total})`);\n}\n\n// Determine if we need to fetch more pages (limit to 2 pages for testing)\nconst hasMorePages = currentPage < Math.min(totalPages, 2);\n\nif (hasMorePages) {\n  // Return data for next page\n  return [{\n    json: {\n      page: currentPage + 1,\n      limit: limit,\n      totalPages: totalPages,\n      accessToken: $node[\"Validate Token & Initialize\"].json.accessToken,\n      allProducts: allProducts,\n      hasMorePages: true,\n      currentTotal: allProducts.length,\n      expectedTotal: total,\n      startTime: $node[\"Validate Token & Initialize\"].json.startTime,\n      errors: errors\n    }\n  }];\n} else {\n  // All pages fetched, return final collection\n  const endTime = new Date().toISOString();\n  const duration = new Date(endTime) - new Date($node[\"Validate Token & Initialize\"].json.startTime);\n  \n  console.log(`üéâ Pagination complete! Fetched ${allProducts.length} products in ${Math.round(duration/1000)}s`);\n  \n  if (errors.length > 0) {\n    console.warn(`‚ö†Ô∏è ${errors.length} errors encountered during fetch:`);\n    errors.forEach(error => console.warn(`  - ${error}`));\n  }\n  \n  return [{\n    json: {\n      allProducts: allProducts,\n      hasMorePages: false,\n      totalProducts: allProducts.length,\n      paginationComplete: true,\n      startTime: $node[\"Validate Token & Initialize\"].json.startTime,\n      endTime: endTime,\n      duration: Math.round(duration/1000),\n      errors: errors\n    }\n  }];\n}"},"id":"d4e5f6g7-8h9i-0j1k-2l3m-4n5o6p7q8r9s","name":"Process Page & Check Pagination","type":"n8n-nodes-base.code","typeVersion":2,"position":[1120,300]},{"parameters":{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict"},"conditions":[{"id":"c1a2b3c4-d5e6-f7g8-h9i0-j1k2l3m4n5o6","leftValue":"={{ $json.hasMorePages }}","rightValue":true,"operator":{"type":"boolean","operation":"equal","rightType":"boolean"}}],"combinator":"and"},"options":{}},"id":"e5f6g7h8-9i0j-1k2l-3m4n-5o6p7q8r9s0t","name":"Has More Pages?","type":"n8n-nodes-base.if","typeVersion":2,"position":[1340,300]},{"parameters":{"jsCode":"// Transform products for vector storage with enhanced error handling\nconst items = $input.all();\nconst allProducts = items[0].json.allProducts;\nconst previousErrors = items[0].json.errors || [];\n\nif (!Array.isArray(allProducts)) {\n  throw new Error('Products data is not an array');\n}\n\nconsole.log(`üîÑ Starting transformation of ${allProducts.length} products...`);\n\nconst transformedProducts = [];\nconst transformErrors = [];\n\nallProducts.forEach((product, index) => {\n  try {\n    // Validate required fields\n    if (!product || typeof product !== 'object') {\n      transformErrors.push(`Product ${index}: Invalid product object`);\n      return;\n    }\n\n    if (!product.id) {\n      transformErrors.push(`Product ${index}: Missing product ID`);\n      return;\n    }\n\n    // Safely extract and combine text fields\n    const textParts = [];\n    \n    // Extract name from translations or direct field\n    let productName = product.name;\n    if (!productName && product.translations && Array.isArray(product.translations)) {\n      const translation = product.translations.find(t => t.name);\n      productName = translation?.name;\n    }\n    if (productName && typeof productName === 'string') {\n      textParts.push(productName.trim());\n    }\n    \n    // Extract description from translations or direct field\n    let productDescription = product.description;\n    if (!productDescription && product.translations && Array.isArray(product.translations)) {\n      const translation = product.translations.find(t => t.description);\n      productDescription = translation?.description;\n    }\n    if (productDescription && typeof productDescription === 'string') {\n      // Strip HTML tags from description\n      const cleanDescription = productDescription.replace(/<[^>]*>/g, ' ').replace(/\\s+/g, ' ').trim();\n      if (cleanDescription.length > 0) {\n        textParts.push(cleanDescription);\n      }\n    }\n    \n    // Add EAN if available\n    if (product.ean && typeof product.ean === 'string') {\n      textParts.push(`EAN: ${product.ean.trim()}`);\n    }\n    \n    // Add manufacturer number if available\n    if (product.manufacturerNumber && typeof product.manufacturerNumber === 'string') {\n      textParts.push(`MFG: ${product.manufacturerNumber.trim()}`);\n    }\n\n    // Combine all text parts\n    const textContent = textParts.filter(part => part.length > 0).join(' | ');\n    \n    // For products with minimal content, create basic description\n    let finalTextContent = textContent;\n    if (finalTextContent.trim().length === 0) {\n      finalTextContent = `Product ID: ${product.id}`;\n      if (product.ean) finalTextContent += ` | EAN: ${product.ean}`;\n      if (product.active) finalTextContent += ' | Active Product';\n    }\n\n    // Safely extract price information\n    let price = 0;\n    let currency = 'EUR';\n    if (Array.isArray(product.price) && product.price.length > 0) {\n      const priceObj = product.price[0];\n      if (priceObj && typeof priceObj.gross === 'number') {\n        price = priceObj.gross;\n      }\n      if (priceObj && priceObj.currencyId) {\n        currency = priceObj.currencyId;\n      }\n    }\n\n    // Prepare metadata with safe defaults\n    const metadata = {\n      id: product.id,\n      name: productName || '',\n      price: price,\n      currency: currency,\n      stock: typeof product.stock === 'number' ? product.stock : 0,\n      active: Boolean(product.active),\n      manufacturerNumber: product.manufacturerNumber || '',\n      ean: product.ean || '',\n      createdAt: product.createdAt || null,\n      updatedAt: product.updatedAt || null\n    };\n\n    transformedProducts.push({\n      pageContent: finalTextContent,\n      metadata: metadata\n    });\n\n  } catch (error) {\n    transformErrors.push(`Product ${product.id || index}: ${error.message}`);\n  }\n});\n\nconsole.log(`‚úÖ Transformed ${transformedProducts.length} products successfully`);\nif (transformErrors.length > 0) {\n  console.warn(`‚ö†Ô∏è ${transformErrors.length} transformation errors:`);\n  transformErrors.slice(0, 5).forEach(error => console.warn(`  - ${error}`));\n}\n\n// Return transformed products with error tracking\nconst result = transformedProducts.map(product => ({ \n  json: {\n    ...product,\n    _metadata: {\n      totalErrors: previousErrors.length + transformErrors.length,\n      transformErrors: transformErrors.length\n    }\n  }\n}));\n\nif (result.length === 0) {\n  throw new Error('No products could be transformed successfully');\n}\n\nreturn result;"},"id":"f6g7h8i9-0j1k-2l3m-4n5o-6p7q8r9s0t1u","name":"Transform Products for Vector Storage","type":"n8n-nodes-base.code","typeVersion":2,"position":[1560,420]},{"parameters":{"jsCode":"// Store products in Qdrant using HTTP API\nconst items = $input.all();\n\nif (!Array.isArray(items) || items.length === 0) {\n  throw new Error('No products to store in Qdrant');\n}\n\nconsole.log(`üîÑ Preparing to store ${items.length} products in Qdrant...`);\n\n// Prepare points for Qdrant\nconst points = [];\nconst errors = [];\n\nitems.forEach((item, index) => {\n  try {\n    const product = item.json;\n    \n    if (!product || !product.pageContent || !product.metadata || !product.metadata.id) {\n      errors.push(`Item ${index}: Missing required fields`);\n      return;\n    }\n\n    // Create a simple vector (placeholder since we don't have embeddings yet)\n    // In a real implementation, you'd generate embeddings from pageContent\n    const vector = new Array(1536).fill(0).map(() => Math.random() * 0.1);\n    \n    const point = {\n      id: product.metadata.id,\n      vector: vector,\n      payload: {\n        content: product.pageContent,\n        name: product.metadata.name,\n        price: product.metadata.price,\n        currency: product.metadata.currency,\n        stock: product.metadata.stock,\n        active: product.metadata.active,\n        ean: product.metadata.ean,\n        manufacturerNumber: product.metadata.manufacturerNumber,\n        createdAt: product.metadata.createdAt,\n        updatedAt: product.metadata.updatedAt\n      }\n    };\n    \n    points.push(point);\n    \n  } catch (error) {\n    errors.push(`Item ${index}: ${error.message}`);\n  }\n});\n\nif (points.length === 0) {\n  throw new Error('No valid points could be prepared for Qdrant storage');\n}\n\nconsole.log(`‚úÖ Prepared ${points.length} points for Qdrant storage`);\nif (errors.length > 0) {\n  console.warn(`‚ö†Ô∏è ${errors.length} preparation errors:`);\n  errors.slice(0, 3).forEach(error => console.warn(`  - ${error}`));\n}\n\n// Return the points data for the HTTP request\nreturn [{\n  json: {\n    points: points,\n    totalPoints: points.length,\n    errors: errors\n  }\n}];"},"id":"g7h8i9j0-1k2l-3m4n-5o6p-7q8r9s0t1u2v","name":"Prepare Qdrant Points","type":"n8n-nodes-base.code","typeVersion":2,"position":[1780,420]},{"parameters":{"method":"PUT","url":"https://8ec957ec-27b4-4041-9714-f8dde751b007.europe-west3-0.gcp.cloud.qdrant.io:6333/collections/shopware_products/points","sendHeaders":true,"headerParameters":{"parameters":[{"name":"api-key","value":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhY2Nlc3MiOiJtIn0.50x-a9c0zTX_dzWnKjq-xM7rJ0ym6_yZ-D_eN_Idft4"},{"name":"Content-Type","value":"application/json"}]},"sendBody":true,"bodyParameters":{"parameters":[{"name":"points","value":"={{ $json.points }}"}]},"options":{"timeout":60000,"retry":{"enabled":true,"maxRetries":2,"retryInterval":3000}}},"id":"h8i9j0k1-2l3m-4n5o-6p7q-8r9s0t1u2v3w","name":"Store in Qdrant Vector DB","type":"n8n-nodes-base.httpRequest","typeVersion":4.1,"position":[2000,420]},{"parameters":{"jsCode":"// Enhanced completion logging with Qdrant storage results\nconst items = $input.all();\nconst qdrantResponse = items[0].json;\n\n// Parse Qdrant response\nlet successfulInserts = 0;\nlet failedInserts = 0;\nlet totalProcessed = 0;\n\nif (qdrantResponse && qdrantResponse.status === 'ok') {\n  successfulInserts = qdrantResponse.result?.operation_id ? 1 : 0;\n  totalProcessed = 1;\n} else {\n  failedInserts = 1;\n  totalProcessed = 1;\n}\n\nconst completionTime = new Date().toISOString();\n\n// Log completion status\nconsole.log('üéâ ===== IMPORT COMPLETED =====');\nconsole.log(`üìä Batch operations processed: ${totalProcessed}`);\nconsole.log(`‚úÖ Successfully stored in Qdrant: ${successfulInserts}`);\nif (failedInserts > 0) {\n  console.log(`‚ùå Failed to store: ${failedInserts}`);\n  console.log(`Response: ${JSON.stringify(qdrantResponse, null, 2)}`);\n}\nconsole.log(`‚è∞ Completion time: ${completionTime}`);\nconsole.log('================================');\n\nreturn [{\n  json: {\n    status: 'completed',\n    totalProcessed: totalProcessed,\n    successfulInserts: successfulInserts,\n    failedInserts: failedInserts,\n    errorRate: totalProcessed > 0 ? (failedInserts / totalProcessed * 100).toFixed(2) + '%' : '0%',\n    message: `Successfully processed batch operation, ${successfulInserts} operations completed`,\n    timestamp: completionTime,\n    qdrantResponse: qdrantResponse\n  }\n}];"},"id":"i9j0k1l2-3m4n-5o6p-7q8r-9s0t1u2v3w4x","name":"Log Completion & Statistics","type":"n8n-nodes-base.code","typeVersion":2,"position":[2220,420]}],"connections":{"Manual Trigger":{"main":[[{"node":"Get OAuth Token","type":"main","index":0}]]},"Get OAuth Token":{"main":[[{"node":"Validate Token & Initialize","type":"main","index":0}]]},"Validate Token & Initialize":{"main":[[{"node":"Fetch Products Page","type":"main","index":0}]]},"Fetch Products Page":{"main":[[{"node":"Process Page & Check Pagination","type":"main","index":0}]]},"Process Page & Check Pagination":{"main":[[{"node":"Has More Pages?","type":"main","index":0}]]},"Has More Pages?":{"main":[[{"node":"Fetch Products Page","type":"main","index":0}],[{"node":"Transform Products for Vector Storage","type":"main","index":0}]]},"Transform Products for Vector Storage":{"main":[[{"node":"Prepare Qdrant Points","type":"main","index":0}]]},"Prepare Qdrant Points":{"main":[[{"node":"Store in Qdrant Vector DB","type":"main","index":0}]]},"Store in Qdrant Vector DB":{"main":[[{"node":"Log Completion & Statistics","type":"main","index":0}]]}},"settings":{"executionOrder":"v1","saveManualExecutions":true,"callerPolicy":"workflowsFromSameOwner"},"staticData":null,"meta":null,"pinData":{},"versionId":"4","triggerCount":1,"tags":[{"createdAt":"2024-01-01T00:00:00.000Z","updatedAt":"2024-01-01T00:00:00.000Z","id":"tag1","name":"shopware"},{"createdAt":"2024-01-01T00:00:00.000Z","updatedAt":"2024-01-01T00:00:00.000Z","id":"tag2","name":"qdrant"},{"createdAt":"2024-01-01T00:00:00.000Z","updatedAt":"2024-01-01T00:00:00.000Z","id":"tag3","name":"vector-database"}]},{"createdAt":"2025-07-25T05:20:44.935Z","updatedAt":"2024-01-01T00:00:00.000Z","id":"V48C8mTC05ywXBcr","name":"Shopware to Qdrant Product Import (Complete)","active":false,"isArchived":false,"nodes":[{"parameters":{},"id":"f8b0c5e1-8a2d-4c3e-9f1a-2b3c4d5e6f7g","name":"Manual Trigger","type":"n8n-nodes-base.manualTrigger","typeVersion":1,"position":[240,300]},{"parameters":{"method":"POST","url":"https://shop.held.de/api/oauth/token","sendHeaders":true,"headerParameters":{"parameters":[{"name":"Content-Type","value":"application/json"}]},"sendBody":true,"bodyParameters":{"parameters":[{"name":"grant_type","value":"client_credentials"},{"name":"client_id","value":"SWIANEPSMGTHMLJMT1BHEFAZNW"},{"name":"client_secret","value":"UVJKRGFWZENoVW9OY1ZuUktYNkN6NFRucVNVQU1VR1B0cElhUzE"}]},"options":{"timeout":30000,"retry":{"enabled":true,"maxRetries":3,"retryInterval":1000}}},"id":"a1b2c3d4-5e6f-7g8h-9i0j-1k2l3m4n5o6p","name":"Get OAuth Token","type":"n8n-nodes-base.httpRequest","typeVersion":4.1,"position":[460,300]},{"parameters":{"jsCode":"// Validate OAuth response and initialize pagination\nconst items = $input.all();\nconst response = items[0].json;\n\n// Check if we got a valid access token\nif (!response.access_token) {\n  throw new Error('Failed to obtain access token from Shopware API');\n}\n\nconsole.log('‚úÖ Successfully obtained OAuth token');\nconsole.log(`Token type: ${response.token_type}`);\nconsole.log(`Expires in: ${response.expires_in} seconds`);\n\n// Set initial pagination parameters\nconst paginationData = {\n  page: 1,\n  limit: 10, // Reduced for testing\n  totalPages: null,\n  accessToken: response.access_token,\n  allProducts: [],\n  startTime: new Date().toISOString(),\n  errors: []\n};\n\nreturn [{\n  json: paginationData\n}];"},"id":"b2c3d4e5-6f7g-8h9i-0j1k-2l3m4n5o6p7q","name":"Validate Token & Initialize","type":"n8n-nodes-base.code","typeVersion":2,"position":[680,300]},{"parameters":{"url":"=https://shop.held.de/api/product?page={{ $json.page }}&limit={{ $json.limit }}","sendHeaders":true,"headerParameters":{"parameters":[{"name":"Authorization","value":"=Bearer {{ $json.accessToken }}"},{"name":"Content-Type","value":"application/json"},{"name":"Accept","value":"application/json"}]},"options":{"timeout":60000,"retry":{"enabled":true,"maxRetries":3,"retryInterval":2000}}},"id":"c3d4e5f6-7g8h-9i0j-1k2l-3m4n5o6p7q8r","name":"Fetch Products Page","type":"n8n-nodes-base.httpRequest","typeVersion":4.1,"position":[900,300]},{"parameters":{"jsCode":"// Process the API response with comprehensive error handling\nconst items = $input.all();\nconst response = items[0].json;\n\n// Validate API response structure\nif (!response || typeof response !== 'object') {\n  throw new Error('Invalid API response format');\n}\n\n// Extract products and pagination info with fallbacks\nconst products = response.data || [];\nconst total = response.total || 0;\nconst currentPage = response.page || 1;\nconst limit = response.limit || 10;\nconst totalPages = Math.ceil(total / limit);\n\n// Get existing data from previous iterations\nlet allProducts = $node[\"Validate Token & Initialize\"].json.allProducts || [];\nlet errors = $node[\"Validate Token & Initialize\"].json.errors || [];\n\n// Validate products data\nif (!Array.isArray(products)) {\n  const error = `Page ${currentPage}: Products data is not an array`;\n  errors.push(error);\n  console.warn('‚ö†Ô∏è ' + error);\n} else {\n  // Add current page products to the collection\n  allProducts = allProducts.concat(products);\n  console.log(`üì¶ Fetched page ${currentPage}/${totalPages} - ${products.length} products (Total: ${allProducts.length}/${total})`);\n}\n\n// Determine if we need to fetch more pages (limit to 2 pages for testing)\nconst hasMorePages = currentPage < Math.min(totalPages, 2);\n\nif (hasMorePages) {\n  // Return data for next page\n  return [{\n    json: {\n      page: currentPage + 1,\n      limit: limit,\n      totalPages: totalPages,\n      accessToken: $node[\"Validate Token & Initialize\"].json.accessToken,\n      allProducts: allProducts,\n      hasMorePages: true,\n      currentTotal: allProducts.length,\n      expectedTotal: total,\n      startTime: $node[\"Validate Token & Initialize\"].json.startTime,\n      errors: errors\n    }\n  }];\n} else {\n  // All pages fetched, return final collection\n  const endTime = new Date().toISOString();\n  const duration = new Date(endTime) - new Date($node[\"Validate Token & Initialize\"].json.startTime);\n  \n  console.log(`üéâ Pagination complete! Fetched ${allProducts.length} products in ${Math.round(duration/1000)}s`);\n  \n  if (errors.length > 0) {\n    console.warn(`‚ö†Ô∏è ${errors.length} errors encountered during fetch:`);\n    errors.forEach(error => console.warn(`  - ${error}`));\n  }\n  \n  return [{\n    json: {\n      allProducts: allProducts,\n      hasMorePages: false,\n      totalProducts: allProducts.length,\n      paginationComplete: true,\n      startTime: $node[\"Validate Token & Initialize\"].json.startTime,\n      endTime: endTime,\n      duration: Math.round(duration/1000),\n      errors: errors\n    }\n  }];\n}"},"id":"d4e5f6g7-8h9i-0j1k-2l3m-4n5o6p7q8r9s","name":"Process Page & Check Pagination","type":"n8n-nodes-base.code","typeVersion":2,"position":[1120,300]},{"parameters":{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict"},"conditions":[{"id":"c1a2b3c4-d5e6-f7g8-h9i0-j1k2l3m4n5o6","leftValue":"={{ $json.hasMorePages }}","rightValue":true,"operator":{"type":"boolean","operation":"equal","rightType":"boolean"}}],"combinator":"and"},"options":{}},"id":"e5f6g7h8-9i0j-1k2l-3m4n-5o6p7q8r9s0t","name":"Has More Pages?","type":"n8n-nodes-base.if","typeVersion":2,"position":[1340,300]},{"parameters":{"jsCode":"// Transform products for vector storage with enhanced error handling\nconst items = $input.all();\nconst allProducts = items[0].json.allProducts;\nconst previousErrors = items[0].json.errors || [];\n\nif (!Array.isArray(allProducts)) {\n  throw new Error('Products data is not an array');\n}\n\nconsole.log(`üîÑ Starting transformation of ${allProducts.length} products...`);\n\nconst transformedProducts = [];\nconst transformErrors = [];\n\nallProducts.forEach((product, index) => {\n  try {\n    // Validate required fields\n    if (!product || typeof product !== 'object') {\n      transformErrors.push(`Product ${index}: Invalid product object`);\n      return;\n    }\n\n    if (!product.id) {\n      transformErrors.push(`Product ${index}: Missing product ID`);\n      return;\n    }\n\n    // Safely extract and combine text fields\n    const textParts = [];\n    \n    // Extract name from translations or direct field\n    let productName = product.name;\n    if (!productName && product.translations && Array.isArray(product.translations)) {\n      const translation = product.translations.find(t => t.name);\n      productName = translation?.name;\n    }\n    if (productName && typeof productName === 'string') {\n      textParts.push(productName.trim());\n    }\n    \n    // Extract description from translations or direct field\n    let productDescription = product.description;\n    if (!productDescription && product.translations && Array.isArray(product.translations)) {\n      const translation = product.translations.find(t => t.description);\n      productDescription = translation?.description;\n    }\n    if (productDescription && typeof productDescription === 'string') {\n      // Strip HTML tags from description\n      const cleanDescription = productDescription.replace(/<[^>]*>/g, ' ').replace(/\\s+/g, ' ').trim();\n      if (cleanDescription.length > 0) {\n        textParts.push(cleanDescription);\n      }\n    }\n    \n    // Add EAN if available\n    if (product.ean && typeof product.ean === 'string') {\n      textParts.push(`EAN: ${product.ean.trim()}`);\n    }\n    \n    // Add manufacturer number if available\n    if (product.manufacturerNumber && typeof product.manufacturerNumber === 'string') {\n      textParts.push(`MFG: ${product.manufacturerNumber.trim()}`);\n    }\n\n    // Combine all text parts\n    const textContent = textParts.filter(part => part.length > 0).join(' | ');\n    \n    // For products with minimal content, create basic description\n    let finalTextContent = textContent;\n    if (finalTextContent.trim().length === 0) {\n      finalTextContent = `Product ID: ${product.id}`;\n      if (product.ean) finalTextContent += ` | EAN: ${product.ean}`;\n      if (product.active) finalTextContent += ' | Active Product';\n    }\n\n    // Safely extract price information\n    let price = 0;\n    let currency = 'EUR';\n    if (Array.isArray(product.price) && product.price.length > 0) {\n      const priceObj = product.price[0];\n      if (priceObj && typeof priceObj.gross === 'number') {\n        price = priceObj.gross;\n      }\n      if (priceObj && priceObj.currencyId) {\n        currency = priceObj.currencyId;\n      }\n    }\n\n    // Prepare metadata with safe defaults\n    const metadata = {\n      id: product.id,\n      name: productName || '',\n      price: price,\n      currency: currency,\n      stock: typeof product.stock === 'number' ? product.stock : 0,\n      active: Boolean(product.active),\n      manufacturerNumber: product.manufacturerNumber || '',\n      ean: product.ean || '',\n      createdAt: product.createdAt || null,\n      updatedAt: product.updatedAt || null\n    };\n\n    transformedProducts.push({\n      pageContent: finalTextContent,\n      metadata: metadata\n    });\n\n  } catch (error) {\n    transformErrors.push(`Product ${product.id || index}: ${error.message}`);\n  }\n});\n\nconsole.log(`‚úÖ Transformed ${transformedProducts.length} products successfully`);\nif (transformErrors.length > 0) {\n  console.warn(`‚ö†Ô∏è ${transformErrors.length} transformation errors:`);\n  transformErrors.slice(0, 5).forEach(error => console.warn(`  - ${error}`));\n}\n\n// Return transformed products with error tracking\nconst result = transformedProducts.map(product => ({ \n  json: {\n    ...product,\n    _metadata: {\n      totalErrors: previousErrors.length + transformErrors.length,\n      transformErrors: transformErrors.length\n    }\n  }\n}));\n\nif (result.length === 0) {\n  throw new Error('No products could be transformed successfully');\n}\n\nreturn result;"},"id":"f6g7h8i9-0j1k-2l3m-4n5o-6p7q8r9s0t1u","name":"Transform Products for Vector Storage","type":"n8n-nodes-base.code","typeVersion":2,"position":[1560,420]},{"parameters":{"jsCode":"// Store products in Qdrant using HTTP API\nconst items = $input.all();\n\nif (!Array.isArray(items) || items.length === 0) {\n  throw new Error('No products to store in Qdrant');\n}\n\nconsole.log(`üîÑ Preparing to store ${items.length} products in Qdrant...`);\n\n// Prepare points for Qdrant\nconst points = [];\nconst errors = [];\n\nitems.forEach((item, index) => {\n  try {\n    const product = item.json;\n    \n    if (!product || !product.pageContent || !product.metadata || !product.metadata.id) {\n      errors.push(`Item ${index}: Missing required fields`);\n      return;\n    }\n\n    // Create a simple vector (placeholder since we don't have embeddings yet)\n    // In a real implementation, you'd generate embeddings from pageContent\n    const vector = new Array(1536).fill(0).map(() => Math.random() * 0.1);\n    \n    const point = {\n      id: product.metadata.id,\n      vector: vector,\n      payload: {\n        content: product.pageContent,\n        name: product.metadata.name,\n        price: product.metadata.price,\n        currency: product.metadata.currency,\n        stock: product.metadata.stock,\n        active: product.metadata.active,\n        ean: product.metadata.ean,\n        manufacturerNumber: product.metadata.manufacturerNumber,\n        createdAt: product.metadata.createdAt,\n        updatedAt: product.metadata.updatedAt\n      }\n    };\n    \n    points.push(point);\n    \n  } catch (error) {\n    errors.push(`Item ${index}: ${error.message}`);\n  }\n});\n\nif (points.length === 0) {\n  throw new Error('No valid points could be prepared for Qdrant storage');\n}\n\nconsole.log(`‚úÖ Prepared ${points.length} points for Qdrant storage`);\nif (errors.length > 0) {\n  console.warn(`‚ö†Ô∏è ${errors.length} preparation errors:`);\n  errors.slice(0, 3).forEach(error => console.warn(`  - ${error}`));\n}\n\n// Return the points data for the HTTP request\nreturn [{\n  json: {\n    points: points,\n    totalPoints: points.length,\n    errors: errors\n  }\n}];"},"id":"g7h8i9j0-1k2l-3m4n-5o6p-7q8r9s0t1u2v","name":"Prepare Qdrant Points","type":"n8n-nodes-base.code","typeVersion":2,"position":[1780,420]},{"parameters":{"method":"PUT","url":"https://8ec957ec-27b4-4041-9714-f8dde751b007.europe-west3-0.gcp.cloud.qdrant.io:6333/collections/shopware_products/points","sendHeaders":true,"headerParameters":{"parameters":[{"name":"api-key","value":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhY2Nlc3MiOiJtIn0.50x-a9c0zTX_dzWnKjq-xM7rJ0ym6_yZ-D_eN_Idft4"},{"name":"Content-Type","value":"application/json"}]},"sendBody":true,"bodyParameters":{"parameters":[{"name":"points","value":"={{ $json.points }}"}]},"options":{"timeout":60000,"retry":{"enabled":true,"maxRetries":2,"retryInterval":3000}}},"id":"h8i9j0k1-2l3m-4n5o-6p7q-8r9s0t1u2v3w","name":"Store in Qdrant Vector DB","type":"n8n-nodes-base.httpRequest","typeVersion":4.1,"position":[2000,420]},{"parameters":{"jsCode":"// Enhanced completion logging with Qdrant storage results\nconst items = $input.all();\nconst qdrantResponse = items[0].json;\n\n// Parse Qdrant response\nlet successfulInserts = 0;\nlet failedInserts = 0;\nlet totalProcessed = 0;\n\nif (qdrantResponse && qdrantResponse.status === 'ok') {\n  successfulInserts = qdrantResponse.result?.operation_id ? 1 : 0;\n  totalProcessed = 1;\n} else {\n  failedInserts = 1;\n  totalProcessed = 1;\n}\n\nconst completionTime = new Date().toISOString();\n\n// Log completion status\nconsole.log('üéâ ===== IMPORT COMPLETED =====');\nconsole.log(`üìä Batch operations processed: ${totalProcessed}`);\nconsole.log(`‚úÖ Successfully stored in Qdrant: ${successfulInserts}`);\nif (failedInserts > 0) {\n  console.log(`‚ùå Failed to store: ${failedInserts}`);\n  console.log(`Response: ${JSON.stringify(qdrantResponse, null, 2)}`);\n}\nconsole.log(`‚è∞ Completion time: ${completionTime}`);\nconsole.log('================================');\n\nreturn [{\n  json: {\n    status: 'completed',\n    totalProcessed: totalProcessed,\n    successfulInserts: successfulInserts,\n    failedInserts: failedInserts,\n    errorRate: totalProcessed > 0 ? (failedInserts / totalProcessed * 100).toFixed(2) + '%' : '0%',\n    message: `Successfully processed batch operation, ${successfulInserts} operations completed`,\n    timestamp: completionTime,\n    qdrantResponse: qdrantResponse\n  }\n}];"},"id":"i9j0k1l2-3m4n-5o6p-7q8r-9s0t1u2v3w4x","name":"Log Completion & Statistics","type":"n8n-nodes-base.code","typeVersion":2,"position":[2220,420]}],"connections":{"Manual Trigger":{"main":[[{"node":"Get OAuth Token","type":"main","index":0}]]},"Get OAuth Token":{"main":[[{"node":"Validate Token & Initialize","type":"main","index":0}]]},"Validate Token & Initialize":{"main":[[{"node":"Fetch Products Page","type":"main","index":0}]]},"Fetch Products Page":{"main":[[{"node":"Process Page & Check Pagination","type":"main","index":0}]]},"Process Page & Check Pagination":{"main":[[{"node":"Has More Pages?","type":"main","index":0}]]},"Has More Pages?":{"main":[[{"node":"Fetch Products Page","type":"main","index":0}],[{"node":"Transform Products for Vector Storage","type":"main","index":0}]]},"Transform Products for Vector Storage":{"main":[[{"node":"Prepare Qdrant Points","type":"main","index":0}]]},"Prepare Qdrant Points":{"main":[[{"node":"Store in Qdrant Vector DB","type":"main","index":0}]]},"Store in Qdrant Vector DB":{"main":[[{"node":"Log Completion & Statistics","type":"main","index":0}]]}},"settings":{"executionOrder":"v1","saveManualExecutions":true,"callerPolicy":"workflowsFromSameOwner"},"staticData":null,"meta":null,"pinData":{},"versionId":"4","triggerCount":1,"tags":[{"createdAt":"2024-01-01T00:00:00.000Z","updatedAt":"2024-01-01T00:00:00.000Z","id":"tag1","name":"shopware"},{"createdAt":"2024-01-01T00:00:00.000Z","updatedAt":"2024-01-01T00:00:00.000Z","id":"tag2","name":"qdrant"},{"createdAt":"2024-01-01T00:00:00.000Z","updatedAt":"2024-01-01T00:00:00.000Z","id":"tag3","name":"vector-database"}]},{"createdAt":"2025-07-26T06:36:50.298Z","updatedAt":"2024-01-01T00:00:00.000Z","id":"N9Zh12IDPG3cI7cM","name":"Shopware to Qdrant Product Import (Complete)","active":false,"isArchived":false,"nodes":[{"parameters":{},"id":"f8b0c5e1-8a2d-4c3e-9f1a-2b3c4d5e6f7g","name":"Manual Trigger","type":"n8n-nodes-base.manualTrigger","typeVersion":1,"position":[240,300]},{"parameters":{"method":"POST","url":"https://shop.held.de/api/oauth/token","sendHeaders":true,"headerParameters":{"parameters":[{"name":"Content-Type","value":"application/json"}]},"sendBody":true,"bodyParameters":{"parameters":[{"name":"grant_type","value":"client_credentials"},{"name":"client_id","value":"SWIANEPSMGTHMLJMT1BHEFAZNW"},{"name":"client_secret","value":"UVJKRGFWZENoVW9OY1ZuUktYNkN6NFRucVNVQU1VR1B0cElhUzE"}]},"options":{"timeout":30000,"retry":{"enabled":true,"maxRetries":3,"retryInterval":1000}}},"id":"a1b2c3d4-5e6f-7g8h-9i0j-1k2l3m4n5o6p","name":"Get OAuth Token","type":"n8n-nodes-base.httpRequest","typeVersion":4.1,"position":[460,300]},{"parameters":{"jsCode":"// Validate OAuth response and initialize pagination\nconst items = $input.all();\nconst response = items[0].json;\n\n// Check if we got a valid access token\nif (!response.access_token) {\n  throw new Error('Failed to obtain access token from Shopware API');\n}\n\nconsole.log('‚úÖ Successfully obtained OAuth token');\nconsole.log(`Token type: ${response.token_type}`);\nconsole.log(`Expires in: ${response.expires_in} seconds`);\n\n// Set initial pagination parameters\nconst paginationData = {\n  page: 1,\n  limit: 10, // Reduced for testing\n  totalPages: null,\n  accessToken: response.access_token,\n  allProducts: [],\n  startTime: new Date().toISOString(),\n  errors: []\n};\n\nreturn [{\n  json: paginationData\n}];"},"id":"b2c3d4e5-6f7g-8h9i-0j1k-2l3m4n5o6p7q","name":"Validate Token & Initialize","type":"n8n-nodes-base.code","typeVersion":2,"position":[680,300]},{"parameters":{"url":"=https://shop.held.de/api/product?page={{ $json.page }}&limit={{ $json.limit }}","sendHeaders":true,"headerParameters":{"parameters":[{"name":"Authorization","value":"=Bearer {{ $json.accessToken }}"},{"name":"Content-Type","value":"application/json"},{"name":"Accept","value":"application/json"}]},"options":{"timeout":60000,"retry":{"enabled":true,"maxRetries":3,"retryInterval":2000}}},"id":"c3d4e5f6-7g8h-9i0j-1k2l-3m4n5o6p7q8r","name":"Fetch Products Page","type":"n8n-nodes-base.httpRequest","typeVersion":4.1,"position":[900,300]},{"parameters":{"jsCode":"// Process the API response with comprehensive error handling\nconst items = $input.all();\nconst response = items[0].json;\n\n// Validate API response structure\nif (!response || typeof response !== 'object') {\n  throw new Error('Invalid API response format');\n}\n\n// Extract products and pagination info with fallbacks\nconst products = response.data || [];\nconst total = response.total || 0;\nconst currentPage = response.page || 1;\nconst limit = response.limit || 10;\nconst totalPages = Math.ceil(total / limit);\n\n// Get existing data from previous iterations\nlet allProducts = $node[\"Validate Token & Initialize\"].json.allProducts || [];\nlet errors = $node[\"Validate Token & Initialize\"].json.errors || [];\n\n// Validate products data\nif (!Array.isArray(products)) {\n  const error = `Page ${currentPage}: Products data is not an array`;\n  errors.push(error);\n  console.warn('‚ö†Ô∏è ' + error);\n} else {\n  // Add current page products to the collection\n  allProducts = allProducts.concat(products);\n  console.log(`üì¶ Fetched page ${currentPage}/${totalPages} - ${products.length} products (Total: ${allProducts.length}/${total})`);\n}\n\n// Determine if we need to fetch more pages (limit to 2 pages for testing)\nconst hasMorePages = currentPage < Math.min(totalPages, 2);\n\nif (hasMorePages) {\n  // Return data for next page\n  return [{\n    json: {\n      page: currentPage + 1,\n      limit: limit,\n      totalPages: totalPages,\n      accessToken: $node[\"Validate Token & Initialize\"].json.accessToken,\n      allProducts: allProducts,\n      hasMorePages: true,\n      currentTotal: allProducts.length,\n      expectedTotal: total,\n      startTime: $node[\"Validate Token & Initialize\"].json.startTime,\n      errors: errors\n    }\n  }];\n} else {\n  // All pages fetched, return final collection\n  const endTime = new Date().toISOString();\n  const duration = new Date(endTime) - new Date($node[\"Validate Token & Initialize\"].json.startTime);\n  \n  console.log(`üéâ Pagination complete! Fetched ${allProducts.length} products in ${Math.round(duration/1000)}s`);\n  \n  if (errors.length > 0) {\n    console.warn(`‚ö†Ô∏è ${errors.length} errors encountered during fetch:`);\n    errors.forEach(error => console.warn(`  - ${error}`));\n  }\n  \n  return [{\n    json: {\n      allProducts: allProducts,\n      hasMorePages: false,\n      totalProducts: allProducts.length,\n      paginationComplete: true,\n      startTime: $node[\"Validate Token & Initialize\"].json.startTime,\n      endTime: endTime,\n      duration: Math.round(duration/1000),\n      errors: errors\n    }\n  }];\n}"},"id":"d4e5f6g7-8h9i-0j1k-2l3m-4n5o6p7q8r9s","name":"Process Page & Check Pagination","type":"n8n-nodes-base.code","typeVersion":2,"position":[1120,300]},{"parameters":{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict"},"conditions":[{"id":"c1a2b3c4-d5e6-f7g8-h9i0-j1k2l3m4n5o6","leftValue":"={{ $json.hasMorePages }}","rightValue":true,"operator":{"type":"boolean","operation":"equal","rightType":"boolean"}}],"combinator":"and"},"options":{}},"id":"e5f6g7h8-9i0j-1k2l-3m4n-5o6p7q8r9s0t","name":"Has More Pages?","type":"n8n-nodes-base.if","typeVersion":2,"position":[1340,300]},{"parameters":{"jsCode":"// Transform products for vector storage with enhanced error handling\nconst items = $input.all();\nconst allProducts = items[0].json.allProducts;\nconst previousErrors = items[0].json.errors || [];\n\nif (!Array.isArray(allProducts)) {\n  throw new Error('Products data is not an array');\n}\n\nconsole.log(`üîÑ Starting transformation of ${allProducts.length} products...`);\n\nconst transformedProducts = [];\nconst transformErrors = [];\n\nallProducts.forEach((product, index) => {\n  try {\n    // Validate required fields\n    if (!product || typeof product !== 'object') {\n      transformErrors.push(`Product ${index}: Invalid product object`);\n      return;\n    }\n\n    if (!product.id) {\n      transformErrors.push(`Product ${index}: Missing product ID`);\n      return;\n    }\n\n    // Safely extract and combine text fields\n    const textParts = [];\n    \n    // Extract name from translations or direct field\n    let productName = product.name;\n    if (!productName && product.translations && Array.isArray(product.translations)) {\n      const translation = product.translations.find(t => t.name);\n      productName = translation?.name;\n    }\n    if (productName && typeof productName === 'string') {\n      textParts.push(productName.trim());\n    }\n    \n    // Extract description from translations or direct field\n    let productDescription = product.description;\n    if (!productDescription && product.translations && Array.isArray(product.translations)) {\n      const translation = product.translations.find(t => t.description);\n      productDescription = translation?.description;\n    }\n    if (productDescription && typeof productDescription === 'string') {\n      // Strip HTML tags from description\n      const cleanDescription = productDescription.replace(/<[^>]*>/g, ' ').replace(/\\s+/g, ' ').trim();\n      if (cleanDescription.length > 0) {\n        textParts.push(cleanDescription);\n      }\n    }\n    \n    // Add EAN if available\n    if (product.ean && typeof product.ean === 'string') {\n      textParts.push(`EAN: ${product.ean.trim()}`);\n    }\n    \n    // Add manufacturer number if available\n    if (product.manufacturerNumber && typeof product.manufacturerNumber === 'string') {\n      textParts.push(`MFG: ${product.manufacturerNumber.trim()}`);\n    }\n\n    // Combine all text parts\n    const textContent = textParts.filter(part => part.length > 0).join(' | ');\n    \n    // For products with minimal content, create basic description\n    let finalTextContent = textContent;\n    if (finalTextContent.trim().length === 0) {\n      finalTextContent = `Product ID: ${product.id}`;\n      if (product.ean) finalTextContent += ` | EAN: ${product.ean}`;\n      if (product.active) finalTextContent += ' | Active Product';\n    }\n\n    // Safely extract price information\n    let price = 0;\n    let currency = 'EUR';\n    if (Array.isArray(product.price) && product.price.length > 0) {\n      const priceObj = product.price[0];\n      if (priceObj && typeof priceObj.gross === 'number') {\n        price = priceObj.gross;\n      }\n      if (priceObj && priceObj.currencyId) {\n        currency = priceObj.currencyId;\n      }\n    }\n\n    // Prepare metadata with safe defaults\n    const metadata = {\n      id: product.id,\n      name: productName || '',\n      price: price,\n      currency: currency,\n      stock: typeof product.stock === 'number' ? product.stock : 0,\n      active: Boolean(product.active),\n      manufacturerNumber: product.manufacturerNumber || '',\n      ean: product.ean || '',\n      createdAt: product.createdAt || null,\n      updatedAt: product.updatedAt || null\n    };\n\n    transformedProducts.push({\n      pageContent: finalTextContent,\n      metadata: metadata\n    });\n\n  } catch (error) {\n    transformErrors.push(`Product ${product.id || index}: ${error.message}`);\n  }\n});\n\nconsole.log(`‚úÖ Transformed ${transformedProducts.length} products successfully`);\nif (transformErrors.length > 0) {\n  console.warn(`‚ö†Ô∏è ${transformErrors.length} transformation errors:`);\n  transformErrors.slice(0, 5).forEach(error => console.warn(`  - ${error}`));\n}\n\n// Return transformed products with error tracking\nconst result = transformedProducts.map(product => ({ \n  json: {\n    ...product,\n    _metadata: {\n      totalErrors: previousErrors.length + transformErrors.length,\n      transformErrors: transformErrors.length\n    }\n  }\n}));\n\nif (result.length === 0) {\n  throw new Error('No products could be transformed successfully');\n}\n\nreturn result;"},"id":"f6g7h8i9-0j1k-2l3m-4n5o-6p7q8r9s0t1u","name":"Transform Products for Vector Storage","type":"n8n-nodes-base.code","typeVersion":2,"position":[1560,420]},{"parameters":{"jsCode":"// Store products in Qdrant using HTTP API\nconst items = $input.all();\n\nif (!Array.isArray(items) || items.length === 0) {\n  throw new Error('No products to store in Qdrant');\n}\n\nconsole.log(`üîÑ Preparing to store ${items.length} products in Qdrant...`);\n\n// Prepare points for Qdrant\nconst points = [];\nconst errors = [];\n\nitems.forEach((item, index) => {\n  try {\n    const product = item.json;\n    \n    if (!product || !product.pageContent || !product.metadata || !product.metadata.id) {\n      errors.push(`Item ${index}: Missing required fields`);\n      return;\n    }\n\n    // Create a simple vector (placeholder since we don't have embeddings yet)\n    // In a real implementation, you'd generate embeddings from pageContent\n    const vector = new Array(1536).fill(0).map(() => Math.random() * 0.1);\n    \n    const point = {\n      id: product.metadata.id,\n      vector: vector,\n      payload: {\n        content: product.pageContent,\n        name: product.metadata.name,\n        price: product.metadata.price,\n        currency: product.metadata.currency,\n        stock: product.metadata.stock,\n        active: product.metadata.active,\n        ean: product.metadata.ean,\n        manufacturerNumber: product.metadata.manufacturerNumber,\n        createdAt: product.metadata.createdAt,\n        updatedAt: product.metadata.updatedAt\n      }\n    };\n    \n    points.push(point);\n    \n  } catch (error) {\n    errors.push(`Item ${index}: ${error.message}`);\n  }\n});\n\nif (points.length === 0) {\n  throw new Error('No valid points could be prepared for Qdrant storage');\n}\n\nconsole.log(`‚úÖ Prepared ${points.length} points for Qdrant storage`);\nif (errors.length > 0) {\n  console.warn(`‚ö†Ô∏è ${errors.length} preparation errors:`);\n  errors.slice(0, 3).forEach(error => console.warn(`  - ${error}`));\n}\n\n// Return the points data for the HTTP request\nreturn [{\n  json: {\n    points: points,\n    totalPoints: points.length,\n    errors: errors\n  }\n}];"},"id":"g7h8i9j0-1k2l-3m4n-5o6p-7q8r9s0t1u2v","name":"Prepare Qdrant Points","type":"n8n-nodes-base.code","typeVersion":2,"position":[1780,420]},{"parameters":{"method":"PUT","url":"https://8ec957ec-27b4-4041-9714-f8dde751b007.europe-west3-0.gcp.cloud.qdrant.io:6333/collections/shopware_products/points","sendHeaders":true,"headerParameters":{"parameters":[{"name":"api-key","value":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhY2Nlc3MiOiJtIn0.50x-a9c0zTX_dzWnKjq-xM7rJ0ym6_yZ-D_eN_Idft4"},{"name":"Content-Type","value":"application/json"}]},"sendBody":true,"bodyParameters":{"parameters":[{"name":"points","value":"={{ $json.points }}"}]},"options":{"timeout":60000,"retry":{"enabled":true,"maxRetries":2,"retryInterval":3000}}},"id":"h8i9j0k1-2l3m-4n5o-6p7q-8r9s0t1u2v3w","name":"Store in Qdrant Vector DB","type":"n8n-nodes-base.httpRequest","typeVersion":4.1,"position":[2000,420]},{"parameters":{"jsCode":"// Enhanced completion logging with Qdrant storage results\nconst items = $input.all();\nconst qdrantResponse = items[0].json;\n\n// Parse Qdrant response\nlet successfulInserts = 0;\nlet failedInserts = 0;\nlet totalProcessed = 0;\n\nif (qdrantResponse && qdrantResponse.status === 'ok') {\n  successfulInserts = qdrantResponse.result?.operation_id ? 1 : 0;\n  totalProcessed = 1;\n} else {\n  failedInserts = 1;\n  totalProcessed = 1;\n}\n\nconst completionTime = new Date().toISOString();\n\n// Log completion status\nconsole.log('üéâ ===== IMPORT COMPLETED =====');\nconsole.log(`üìä Batch operations processed: ${totalProcessed}`);\nconsole.log(`‚úÖ Successfully stored in Qdrant: ${successfulInserts}`);\nif (failedInserts > 0) {\n  console.log(`‚ùå Failed to store: ${failedInserts}`);\n  console.log(`Response: ${JSON.stringify(qdrantResponse, null, 2)}`);\n}\nconsole.log(`‚è∞ Completion time: ${completionTime}`);\nconsole.log('================================');\n\nreturn [{\n  json: {\n    status: 'completed',\n    totalProcessed: totalProcessed,\n    successfulInserts: successfulInserts,\n    failedInserts: failedInserts,\n    errorRate: totalProcessed > 0 ? (failedInserts / totalProcessed * 100).toFixed(2) + '%' : '0%',\n    message: `Successfully processed batch operation, ${successfulInserts} operations completed`,\n    timestamp: completionTime,\n    qdrantResponse: qdrantResponse\n  }\n}];"},"id":"i9j0k1l2-3m4n-5o6p-7q8r-9s0t1u2v3w4x","name":"Log Completion & Statistics","type":"n8n-nodes-base.code","typeVersion":2,"position":[2220,420]}],"connections":{"Manual Trigger":{"main":[[{"node":"Get OAuth Token","type":"main","index":0}]]},"Get OAuth Token":{"main":[[{"node":"Validate Token & Initialize","type":"main","index":0}]]},"Validate Token & Initialize":{"main":[[{"node":"Fetch Products Page","type":"main","index":0}]]},"Fetch Products Page":{"main":[[{"node":"Process Page & Check Pagination","type":"main","index":0}]]},"Process Page & Check Pagination":{"main":[[{"node":"Has More Pages?","type":"main","index":0}]]},"Has More Pages?":{"main":[[{"node":"Fetch Products Page","type":"main","index":0}],[{"node":"Transform Products for Vector Storage","type":"main","index":0}]]},"Transform Products for Vector Storage":{"main":[[{"node":"Prepare Qdrant Points","type":"main","index":0}]]},"Prepare Qdrant Points":{"main":[[{"node":"Store in Qdrant Vector DB","type":"main","index":0}]]},"Store in Qdrant Vector DB":{"main":[[{"node":"Log Completion & Statistics","type":"main","index":0}]]}},"settings":{"executionOrder":"v1","saveManualExecutions":true,"callerPolicy":"workflowsFromSameOwner"},"staticData":null,"meta":null,"pinData":{},"versionId":"4","triggerCount":1,"tags":[{"createdAt":"2024-01-01T00:00:00.000Z","updatedAt":"2024-01-01T00:00:00.000Z","id":"tag1","name":"shopware"},{"createdAt":"2024-01-01T00:00:00.000Z","updatedAt":"2024-01-01T00:00:00.000Z","id":"tag2","name":"qdrant"},{"createdAt":"2024-01-01T00:00:00.000Z","updatedAt":"2024-01-01T00:00:00.000Z","id":"tag3","name":"vector-database"}]},{"createdAt":"2025-07-26T06:36:51.097Z","updatedAt":"2024-01-01T00:00:00.000Z","id":"BNuYvwRcNEutDIUa","name":"Shopware to Qdrant Product Import (Enhanced)","active":false,"isArchived":false,"nodes":[{"parameters":{},"id":"f8b0c5e1-8a2d-4c3e-9f1a-2b3c4d5e6f7g","name":"Manual Trigger","type":"n8n-nodes-base.manualTrigger","typeVersion":1,"position":[240,300]},{"parameters":{"method":"POST","url":"https://shop.held.de/api/oauth/token","sendHeaders":true,"headerParameters":{"parameters":[{"name":"Content-Type","value":"application/json"}]},"sendBody":true,"bodyParameters":{"parameters":[{"name":"grant_type","value":"client_credentials"},{"name":"client_id","value":"SWIANEPSMGTHMLJMT1BHEFAZNW"},{"name":"client_secret","value":"UVJKRGFWZENoVW9OY1ZuUktYNkN6NFRucVNVQU1VR1B0cElhUzE"}]},"options":{"timeout":30000,"retry":{"enabled":true,"maxRetries":3,"retryInterval":1000}}},"id":"a1b2c3d4-5e6f-7g8h-9i0j-1k2l3m4n5o6p","name":"Get OAuth Token","type":"n8n-nodes-base.httpRequest","typeVersion":4.1,"position":[460,300]},{"parameters":{"jsCode":"// Validate OAuth response and initialize pagination\nconst items = $input.all();\nconst response = items[0].json;\n\n// Check if we got a valid access token\nif (!response.access_token) {\n  throw new Error('Failed to obtain access token from Shopware API');\n}\n\nconsole.log('‚úÖ Successfully obtained OAuth token');\nconsole.log(`Token type: ${response.token_type}`);\nconsole.log(`Expires in: ${response.expires_in} seconds`);\n\n// Set initial pagination parameters\nconst paginationData = {\n  page: 1,\n  limit: 50, // Shopware default limit\n  totalPages: null,\n  accessToken: response.access_token,\n  allProducts: [],\n  startTime: new Date().toISOString(),\n  errors: []\n};\n\nreturn [{\n  json: paginationData\n}];"},"id":"b2c3d4e5-6f7g-8h9i-0j1k-2l3m4n5o6p7q","name":"Validate Token & Initialize","type":"n8n-nodes-base.code","typeVersion":2,"position":[680,300]},{"parameters":{"url":"=https://shop.held.de/api/product?page={{ $json.page }}&limit={{ $json.limit }}&associations[translations][]=name&associations[translations][]=description&associations[translations][]=metaDescription&includes[product][]=price&includes[product][]=stock&includes[product][]=active&includes[product][]=manufacturerNumber&includes[product][]=ean&includes[product][]=categories&includes[product][]=properties&includes[product][]=seoUrls&includes[product][]=createdAt&includes[product][]=updatedAt","sendHeaders":true,"headerParameters":{"parameters":[{"name":"Authorization","value":"=Bearer {{ $json.accessToken }}"},{"name":"Content-Type","value":"application/json"},{"name":"Accept","value":"application/json"},{"name":"sw-include-seo-urls","value":"true"}]},"options":{"timeout":60000,"retry":{"enabled":true,"maxRetries":3,"retryInterval":2000}}},"id":"c3d4e5f6-7g8h-9i0j-1k2l-3m4n5o6p7q8r","name":"Fetch Products Page","type":"n8n-nodes-base.httpRequest","typeVersion":4.1,"position":[900,300]},{"parameters":{"jsCode":"// Process the API response with comprehensive error handling\nconst items = $input.all();\nconst response = items[0].json;\n\n// Validate API response structure\nif (!response || typeof response !== 'object') {\n  throw new Error('Invalid API response format');\n}\n\n// Extract products and pagination info with fallbacks\nconst products = response.data || [];\nconst total = response.total || 0;\nconst currentPage = response.page || 1;\nconst limit = response.limit || 50;\nconst totalPages = Math.ceil(total / limit);\n\n// Get existing data from previous iterations\nlet allProducts = $node[\"Validate Token & Initialize\"].json.allProducts || [];\nlet errors = $node[\"Validate Token & Initialize\"].json.errors || [];\n\n// Validate products data\nif (!Array.isArray(products)) {\n  const error = `Page ${currentPage}: Products data is not an array`;\n  errors.push(error);\n  console.warn('‚ö†Ô∏è ' + error);\n} else {\n  // Add current page products to the collection\n  allProducts = allProducts.concat(products);\n  console.log(`üì¶ Fetched page ${currentPage}/${totalPages} - ${products.length} products (Total: ${allProducts.length}/${total})`);\n}\n\n// Determine if we need to fetch more pages\nconst hasMorePages = currentPage < totalPages;\n\nif (hasMorePages) {\n  // Return data for next page\n  return [{\n    json: {\n      page: currentPage + 1,\n      limit: limit,\n      totalPages: totalPages,\n      accessToken: $node[\"Validate Token & Initialize\"].json.accessToken,\n      allProducts: allProducts,\n      hasMorePages: true,\n      currentTotal: allProducts.length,\n      expectedTotal: total,\n      startTime: $node[\"Validate Token & Initialize\"].json.startTime,\n      errors: errors\n    }\n  }];\n} else {\n  // All pages fetched, return final collection\n  const endTime = new Date().toISOString();\n  const duration = new Date(endTime) - new Date($node[\"Validate Token & Initialize\"].json.startTime);\n  \n  console.log(`üéâ Pagination complete! Fetched ${allProducts.length} products in ${Math.round(duration/1000)}s`);\n  \n  if (errors.length > 0) {\n    console.warn(`‚ö†Ô∏è ${errors.length} errors encountered during fetch:`);\n    errors.forEach(error => console.warn(`  - ${error}`));\n  }\n  \n  return [{\n    json: {\n      allProducts: allProducts,\n      hasMorePages: false,\n      totalProducts: allProducts.length,\n      paginationComplete: true,\n      startTime: $node[\"Validate Token & Initialize\"].json.startTime,\n      endTime: endTime,\n      duration: Math.round(duration/1000),\n      errors: errors\n    }\n  }];\n}"},"id":"d4e5f6g7-8h9i-0j1k-2l3m-4n5o6p7q8r9s","name":"Process Page & Check Pagination","type":"n8n-nodes-base.code","typeVersion":2,"position":[1120,300]},{"parameters":{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict"},"conditions":[{"id":"c1a2b3c4-d5e6-f7g8-h9i0-j1k2l3m4n5o6","leftValue":"={{ $json.hasMorePages }}","rightValue":true,"operator":{"type":"boolean","operation":"true"}}],"combinator":"and"},"options":{}},"id":"e5f6g7h8-9i0j-1k2l-3m4n-5o6p7q8r9s0t","name":"Has More Pages?","type":"n8n-nodes-base.if","typeVersion":2,"position":[1340,300]},{"parameters":{"jsCode":"// Transform products for vector storage with enhanced error handling\nconst items = $input.all();\nconst allProducts = items[0].json.allProducts;\nconst previousErrors = items[0].json.errors || [];\n\nif (!Array.isArray(allProducts)) {\n  throw new Error('Products data is not an array');\n}\n\nconsole.log(`üîÑ Starting transformation of ${allProducts.length} products...`);\n\nconst transformedProducts = [];\nconst transformErrors = [];\n\nallProducts.forEach((product, index) => {\n  try {\n    // Validate required fields\n    if (!product || typeof product !== 'object') {\n      transformErrors.push(`Product ${index}: Invalid product object`);\n      return;\n    }\n\n    if (!product.id) {\n      transformErrors.push(`Product ${index}: Missing product ID`);\n      return;\n    }\n\n    // Safely extract and combine text fields\n    const textParts = [];\n    \n    // Add name\n    if (product.name && typeof product.name === 'string') {\n      textParts.push(product.name.trim());\n    }\n    \n    // Add description\n    if (product.description && typeof product.description === 'string') {\n      textParts.push(product.description.trim());\n    }\n    \n    // Add meta description\n    if (product.metaDescription && typeof product.metaDescription === 'string') {\n      textParts.push(product.metaDescription.trim());\n    }\n    \n    // Add properties\n    if (Array.isArray(product.properties)) {\n      const propertyTexts = product.properties\n        .filter(prop => prop && prop.name && prop.value)\n        .map(prop => `${prop.name}: ${prop.value}`);\n      if (propertyTexts.length > 0) {\n        textParts.push(propertyTexts.join(', '));\n      }\n    }\n    \n    // Add categories\n    if (Array.isArray(product.categories)) {\n      const categoryNames = product.categories\n        .filter(cat => cat && cat.name)\n        .map(cat => cat.name);\n      if (categoryNames.length > 0) {\n        textParts.push(categoryNames.join(', '));\n      }\n    }\n    \n    // Add manufacturer number\n    if (product.manufacturerNumber && typeof product.manufacturerNumber === 'string') {\n      textParts.push(product.manufacturerNumber.trim());\n    }\n    \n    // Add EAN\n    if (product.ean && typeof product.ean === 'string') {\n      textParts.push(product.ean.trim());\n    }\n\n    // Combine all text parts\n    const textContent = textParts.filter(part => part.length > 0).join(' | ');\n    \n    // Skip products with no meaningful content\n    if (textContent.trim().length === 0) {\n      transformErrors.push(`Product ${product.id}: No meaningful text content`);\n      return;\n    }\n\n    // Safely extract price information\n    let price = 0;\n    let currency = 'EUR';\n    if (Array.isArray(product.price) && product.price.length > 0) {\n      const priceObj = product.price[0];\n      if (priceObj && typeof priceObj.gross === 'number') {\n        price = priceObj.gross;\n      }\n      if (priceObj && priceObj.currencyId) {\n        currency = priceObj.currencyId;\n      }\n    }\n\n    // Prepare metadata with safe defaults\n    const metadata = {\n      id: product.id,\n      name: product.name || '',\n      price: price,\n      currency: currency,\n      stock: typeof product.stock === 'number' ? product.stock : 0,\n      active: Boolean(product.active),\n      manufacturerNumber: product.manufacturerNumber || '',\n      ean: product.ean || '',\n      categories: Array.isArray(product.categories) \n        ? product.categories.filter(cat => cat && cat.name).map(cat => cat.name)\n        : [],\n      properties: Array.isArray(product.properties) ? product.properties : [],\n      url: (Array.isArray(product.seoUrls) && product.seoUrls.length > 0) \n        ? product.seoUrls[0].seoPathInfo || ''\n        : '',\n      createdAt: product.createdAt || null,\n      updatedAt: product.updatedAt || null\n    };\n\n    transformedProducts.push({\n      pageContent: textContent,\n      metadata: metadata\n    });\n\n  } catch (error) {\n    transformErrors.push(`Product ${product.id || index}: ${error.message}`);\n  }\n});\n\nconsole.log(`‚úÖ Transformed ${transformedProducts.length} products successfully`);\nif (transformErrors.length > 0) {\n  console.warn(`‚ö†Ô∏è ${transformErrors.length} transformation errors:`);\n  transformErrors.slice(0, 10).forEach(error => console.warn(`  - ${error}`));\n  if (transformErrors.length > 10) {\n    console.warn(`  ... and ${transformErrors.length - 10} more errors`);\n  }\n}\n\n// Return transformed products with error tracking\nconst result = transformedProducts.map(product => ({ \n  json: {\n    ...product,\n    _metadata: {\n      totalErrors: previousErrors.length + transformErrors.length,\n      transformErrors: transformErrors.length\n    }\n  }\n}));\n\nif (result.length === 0) {\n  throw new Error('No products could be transformed successfully');\n}\n\nreturn result;"},"id":"f6g7h8i9-0j1k-2l3m-4n5o-6p7q8r9s0t1u","name":"Transform Products for Vector Storage","type":"n8n-nodes-base.code","typeVersion":2,"position":[1560,420]},{"parameters":{"model":"text-embedding-3-small","options":{"batchSize":100,"stripNewLines":true,"maxRetries":3}},"id":"g7h8i9j0-1k2l-3m4n-5o6p-7q8r9s0t1u2v","name":"Generate Embeddings","type":"@n8n/n8n-nodes-langchain.embeddingsOpenAi","typeVersion":1,"position":[1780,420]},{"parameters":{"mode":"insert","qdrantCollection":{"__rl":true,"value":"shopware_products","mode":"name"},"options":{"batchSize":50}},"id":"h8i9j0k1-2l3m-4n5o-6p7q-8r9s0t1u2v3w","name":"Insert into Qdrant","type":"@n8n/n8n-nodes-langchain.vectorStoreQdrant","typeVersion":1,"position":[2000,420]},{"parameters":{"jsCode":"// Comprehensive completion logging with error summary\nconst items = $input.all();\nconst totalProcessed = items.length;\n\n// Extract error information from the first item's metadata\nconst firstItem = items[0];\nconst errorInfo = firstItem?.json?._metadata || {};\n\nconst completionTime = new Date().toISOString();\n\n// Calculate processing statistics\nconst stats = {\n  totalProductsProcessed: totalProcessed,\n  totalErrors: errorInfo.totalErrors || 0,\n  transformErrors: errorInfo.transformErrors || 0,\n  successRate: totalProcessed > 0 ? ((totalProcessed / (totalProcessed + (errorInfo.totalErrors || 0))) * 100).toFixed(2) : 0\n};\n\n// Log comprehensive completion status\nconsole.log('üéâ ===== IMPORT COMPLETED =====');\nconsole.log(`üìä Products successfully processed: ${stats.totalProductsProcessed}`);\nconsole.log(`‚ö†Ô∏è Total errors encountered: ${stats.totalErrors}`);\nconsole.log(`üìà Success rate: ${stats.successRate}%`);\nconsole.log(`‚è∞ Completion time: ${completionTime}`);\nconsole.log('================================');\n\nif (stats.totalErrors > 0) {\n  console.warn('‚ö†Ô∏è Some products could not be processed. Check the logs above for details.');\n}\n\nif (totalProcessed === 0) {\n  throw new Error('No products were successfully processed!');\n}\n\nreturn [{\n  json: {\n    status: 'completed',\n    statistics: stats,\n    message: `Successfully imported ${totalProcessed} products into Qdrant`,\n    timestamp: completionTime,\n    recommendations: stats.totalErrors > 0 \n      ? ['Review error logs', 'Consider re-running for failed products', 'Check data quality in source system']\n      : ['Import completed successfully', 'Ready for chatbot integration', 'Consider setting up monitoring']\n  }\n}];"},"id":"i9j0k1l2-3m4n-5o6p-7q8r-9s0t1u2v3w4x","name":"Log Completion & Statistics","type":"n8n-nodes-base.code","typeVersion":2,"position":[2220,420]},{"parameters":{"jsCode":"// Error handler for OAuth failures\nconst error = $input.first().error;\n\nconsole.error('‚ùå OAuth Authentication Failed!');\nconsole.error(`Error: ${error.message}`);\nconsole.error('Please check:');\nconsole.error('- Shopware API credentials are correct');\nconsole.error('- Integration has proper permissions');\nconsole.error('- Shopware instance is accessible');\n\nreturn [{\n  json: {\n    status: 'failed',\n    stage: 'authentication',\n    error: error.message,\n    timestamp: new Date().toISOString(),\n    troubleshooting: [\n      'Verify client_id and client_secret',\n      'Check Shopware integration permissions',\n      'Ensure API endpoint is accessible',\n      'Review Shopware logs for authentication errors'\n    ]\n  }\n}];"},"id":"j0k1l2m3-4n5o-6p7q-8r9s-0t1u2v3w4x5y","name":"Handle OAuth Error","type":"n8n-nodes-base.code","typeVersion":2,"position":[460,480]},{"parameters":{"jsCode":"// Error handler for API fetch failures\nconst error = $input.first().error;\nconst currentPage = $node[\"Process Page & Check Pagination\"]?.json?.page || 'unknown';\n\nconsole.error(`‚ùå API Fetch Failed on page ${currentPage}!`);\nconsole.error(`Error: ${error.message}`);\nconsole.error('This could be due to:');\nconsole.error('- Network connectivity issues');\nconsole.error('- API rate limiting');\nconsole.error('- Invalid API response format');\nconsole.error('- Server-side errors');\n\nreturn [{\n  json: {\n    status: 'failed',\n    stage: 'data_fetch',\n    page: currentPage,\n    error: error.message,\n    timestamp: new Date().toISOString(),\n    troubleshooting: [\n      'Check network connectivity',\n      'Verify API endpoint availability',\n      'Review rate limiting settings',\n      'Check Shopware server logs',\n      'Try reducing batch size'\n    ]\n  }\n}];"},"id":"k1l2m3n4-5o6p-7q8r-9s0t-1u2v3w4x5y6z","name":"Handle API Error","type":"n8n-nodes-base.code","typeVersion":2,"position":[1120,480]},{"parameters":{"jsCode":"// Error handler for vector storage failures\nconst error = $input.first().error;\n\nconsole.error('‚ùå Vector Storage Failed!');\nconsole.error(`Error: ${error.message}`);\nconsole.error('This could be due to:');\nconsole.error('- Qdrant connection issues');\nconsole.error('- Invalid collection configuration');\nconsole.error('- Embedding generation failures');\nconsole.error('- Insufficient Qdrant storage space');\n\nreturn [{\n  json: {\n    status: 'failed',\n    stage: 'vector_storage',\n    error: error.message,\n    timestamp: new Date().toISOString(),\n    troubleshooting: [\n      'Verify Qdrant connection credentials',\n      'Check collection exists and is accessible',\n      'Ensure OpenAI API key is valid',\n      'Review Qdrant cluster status',\n      'Check available storage space',\n      'Verify embedding dimensions match collection config'\n    ]\n  }\n}];"},"id":"l2m3n4o5-6p7q-8r9s-0t1u-2v3w4x5y6z7a","name":"Handle Vector Storage Error","type":"n8n-nodes-base.code","typeVersion":2,"position":[2000,580]}],"connections":{"Manual Trigger":{"main":[[{"node":"Get OAuth Token","type":"main","index":0}]]},"Get OAuth Token":{"main":[[{"node":"Validate Token & Initialize","type":"main","index":0}]],"error":[[{"node":"Handle OAuth Error","type":"main","index":0}]]},"Validate Token & Initialize":{"main":[[{"node":"Fetch Products Page","type":"main","index":0}]]},"Fetch Products Page":{"main":[[{"node":"Process Page & Check Pagination","type":"main","index":0}]],"error":[[{"node":"Handle API Error","type":"main","index":0}]]},"Process Page & Check Pagination":{"main":[[{"node":"Has More Pages?","type":"main","index":0}]]},"Has More Pages?":{"main":[[{"node":"Fetch Products Page","type":"main","index":0}],[{"node":"Transform Products for Vector Storage","type":"main","index":0}]]},"Transform Products for Vector Storage":{"main":[[{"node":"Generate Embeddings","type":"main","index":0}]]},"Generate Embeddings":{"main":[[{"node":"Insert into Qdrant","type":"main","index":0}]],"error":[[{"node":"Handle Vector Storage Error","type":"main","index":0}]]},"Insert into Qdrant":{"main":[[{"node":"Log Completion & Statistics","type":"main","index":0}]],"error":[[{"node":"Handle Vector Storage Error","type":"main","index":0}]]}},"settings":{"executionOrder":"v1","saveManualExecutions":true,"callerPolicy":"workflowsFromSameOwner","errorWorkflow":{"enabled":false}},"staticData":null,"meta":null,"pinData":{},"versionId":"2","triggerCount":1,"tags":[{"createdAt":"2024-01-01T00:00:00.000Z","updatedAt":"2024-01-01T00:00:00.000Z","id":"tag1","name":"shopware"},{"createdAt":"2024-01-01T00:00:00.000Z","updatedAt":"2024-01-01T00:00:00.000Z","id":"tag2","name":"qdrant"},{"createdAt":"2024-01-01T00:00:00.000Z","updatedAt":"2024-01-01T00:00:00.000Z","id":"tag3","name":"vector-database"},{"createdAt":"2024-01-01T00:00:00.000Z","updatedAt":"2024-01-01T00:00:00.000Z","id":"tag4","name":"enhanced"}]},{"createdAt":"2025-07-26T06:36:54.358Z","updatedAt":"2024-01-01T00:00:00.000Z","id":"j09Ej9fvEf6NCyr3","name":"Shopware to Qdrant Product Import (Fixed)","active":false,"isArchived":false,"nodes":[{"parameters":{},"id":"f8b0c5e1-8a2d-4c3e-9f1a-2b3c4d5e6f7g","name":"Manual Trigger","type":"n8n-nodes-base.manualTrigger","typeVersion":1,"position":[240,300]},{"parameters":{"method":"POST","url":"https://shop.held.de/api/oauth/token","sendHeaders":true,"headerParameters":{"parameters":[{"name":"Content-Type","value":"application/json"}]},"sendBody":true,"bodyParameters":{"parameters":[{"name":"grant_type","value":"client_credentials"},{"name":"client_id","value":"SWIANEPSMGTHMLJMT1BHEFAZNW"},{"name":"client_secret","value":"UVJKRGFWZENoVW9OY1ZuUktYNkN6NFRucVNVQU1VR1B0cElhUzE"}]},"options":{"timeout":30000,"retry":{"enabled":true,"maxRetries":3,"retryInterval":1000}}},"id":"a1b2c3d4-5e6f-7g8h-9i0j-1k2l3m4n5o6p","name":"Get OAuth Token","type":"n8n-nodes-base.httpRequest","typeVersion":4.1,"position":[460,300]},{"parameters":{"jsCode":"// Validate OAuth response and initialize pagination\nconst items = $input.all();\nconst response = items[0].json;\n\n// Check if we got a valid access token\nif (!response.access_token) {\n  throw new Error('Failed to obtain access token from Shopware API');\n}\n\nconsole.log('‚úÖ Successfully obtained OAuth token');\nconsole.log(`Token type: ${response.token_type}`);\nconsole.log(`Expires in: ${response.expires_in} seconds`);\n\n// Set initial pagination parameters\nconst paginationData = {\n  page: 1,\n  limit: 10, // Reduced for testing\n  totalPages: null,\n  accessToken: response.access_token,\n  allProducts: [],\n  startTime: new Date().toISOString(),\n  errors: []\n};\n\nreturn [{\n  json: paginationData\n}];"},"id":"b2c3d4e5-6f7g-8h9i-0j1k-2l3m4n5o6p7q","name":"Validate Token & Initialize","type":"n8n-nodes-base.code","typeVersion":2,"position":[680,300]},{"parameters":{"url":"=https://shop.held.de/api/product?page={{ $json.page }}&limit={{ $json.limit }}","sendHeaders":true,"headerParameters":{"parameters":[{"name":"Authorization","value":"=Bearer {{ $json.accessToken }}"},{"name":"Content-Type","value":"application/json"},{"name":"Accept","value":"application/json"}]},"options":{"timeout":60000,"retry":{"enabled":true,"maxRetries":3,"retryInterval":2000}}},"id":"c3d4e5f6-7g8h-9i0j-1k2l-3m4n5o6p7q8r","name":"Fetch Products Page","type":"n8n-nodes-base.httpRequest","typeVersion":4.1,"position":[900,300]},{"parameters":{"jsCode":"// Process the API response with comprehensive error handling\nconst items = $input.all();\nconst response = items[0].json;\n\n// Validate API response structure\nif (!response || typeof response !== 'object') {\n  throw new Error('Invalid API response format');\n}\n\n// Extract products and pagination info with fallbacks\nconst products = response.data || [];\nconst total = response.total || 0;\nconst currentPage = response.page || 1;\nconst limit = response.limit || 10;\nconst totalPages = Math.ceil(total / limit);\n\n// Get existing data from previous iterations\nlet allProducts = $node[\"Validate Token & Initialize\"].json.allProducts || [];\nlet errors = $node[\"Validate Token & Initialize\"].json.errors || [];\n\n// Validate products data\nif (!Array.isArray(products)) {\n  const error = `Page ${currentPage}: Products data is not an array`;\n  errors.push(error);\n  console.warn('‚ö†Ô∏è ' + error);\n} else {\n  // Add current page products to the collection\n  allProducts = allProducts.concat(products);\n  console.log(`üì¶ Fetched page ${currentPage}/${totalPages} - ${products.length} products (Total: ${allProducts.length}/${total})`);\n}\n\n// Determine if we need to fetch more pages (limit to 2 pages for testing)\nconst hasMorePages = currentPage < Math.min(totalPages, 2);\n\nif (hasMorePages) {\n  // Return data for next page\n  return [{\n    json: {\n      page: currentPage + 1,\n      limit: limit,\n      totalPages: totalPages,\n      accessToken: $node[\"Validate Token & Initialize\"].json.accessToken,\n      allProducts: allProducts,\n      hasMorePages: true,\n      currentTotal: allProducts.length,\n      expectedTotal: total,\n      startTime: $node[\"Validate Token & Initialize\"].json.startTime,\n      errors: errors\n    }\n  }];\n} else {\n  // All pages fetched, return final collection\n  const endTime = new Date().toISOString();\n  const duration = new Date(endTime) - new Date($node[\"Validate Token & Initialize\"].json.startTime);\n  \n  console.log(`üéâ Pagination complete! Fetched ${allProducts.length} products in ${Math.round(duration/1000)}s`);\n  \n  if (errors.length > 0) {\n    console.warn(`‚ö†Ô∏è ${errors.length} errors encountered during fetch:`);\n    errors.forEach(error => console.warn(`  - ${error}`));\n  }\n  \n  return [{\n    json: {\n      allProducts: allProducts,\n      hasMorePages: false,\n      totalProducts: allProducts.length,\n      paginationComplete: true,\n      startTime: $node[\"Validate Token & Initialize\"].json.startTime,\n      endTime: endTime,\n      duration: Math.round(duration/1000),\n      errors: errors\n    }\n  }];\n}"},"id":"d4e5f6g7-8h9i-0j1k-2l3m-4n5o6p7q8r9s","name":"Process Page & Check Pagination","type":"n8n-nodes-base.code","typeVersion":2,"position":[1120,300]},{"parameters":{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict"},"conditions":[{"id":"c1a2b3c4-d5e6-f7g8-h9i0-j1k2l3m4n5o6","leftValue":"={{ $json.hasMorePages }}","rightValue":true,"operator":{"type":"boolean","operation":"equal","rightType":"boolean"}}],"combinator":"and"},"options":{}},"id":"e5f6g7h8-9i0j-1k2l-3m4n-5o6p7q8r9s0t","name":"Has More Pages?","type":"n8n-nodes-base.if","typeVersion":2,"position":[1340,300]},{"parameters":{"jsCode":"// Transform products for vector storage with enhanced error handling\nconst items = $input.all();\nconst allProducts = items[0].json.allProducts;\nconst previousErrors = items[0].json.errors || [];\n\nif (!Array.isArray(allProducts)) {\n  throw new Error('Products data is not an array');\n}\n\nconsole.log(`üîÑ Starting transformation of ${allProducts.length} products...`);\n\nconst transformedProducts = [];\nconst transformErrors = [];\n\nallProducts.forEach((product, index) => {\n  try {\n    // Validate required fields\n    if (!product || typeof product !== 'object') {\n      transformErrors.push(`Product ${index}: Invalid product object`);\n      return;\n    }\n\n    if (!product.id) {\n      transformErrors.push(`Product ${index}: Missing product ID`);\n      return;\n    }\n\n    // Safely extract and combine text fields\n    const textParts = [];\n    \n    // Extract name from translations or direct field\n    let productName = product.name;\n    if (!productName && product.translations && Array.isArray(product.translations)) {\n      const translation = product.translations.find(t => t.name);\n      productName = translation?.name;\n    }\n    if (productName && typeof productName === 'string') {\n      textParts.push(productName.trim());\n    }\n    \n    // Extract description from translations or direct field\n    let productDescription = product.description;\n    if (!productDescription && product.translations && Array.isArray(product.translations)) {\n      const translation = product.translations.find(t => t.description);\n      productDescription = translation?.description;\n    }\n    if (productDescription && typeof productDescription === 'string') {\n      // Strip HTML tags from description\n      const cleanDescription = productDescription.replace(/<[^>]*>/g, ' ').replace(/\\s+/g, ' ').trim();\n      if (cleanDescription.length > 0) {\n        textParts.push(cleanDescription);\n      }\n    }\n    \n    // Add EAN if available\n    if (product.ean && typeof product.ean === 'string') {\n      textParts.push(`EAN: ${product.ean.trim()}`);\n    }\n    \n    // Add manufacturer number if available\n    if (product.manufacturerNumber && typeof product.manufacturerNumber === 'string') {\n      textParts.push(`MFG: ${product.manufacturerNumber.trim()}`);\n    }\n\n    // Combine all text parts\n    const textContent = textParts.filter(part => part.length > 0).join(' | ');\n    \n    // For products with minimal content, create basic description\n    let finalTextContent = textContent;\n    if (finalTextContent.trim().length === 0) {\n      finalTextContent = `Product ID: ${product.id}`;\n      if (product.ean) finalTextContent += ` | EAN: ${product.ean}`;\n      if (product.active) finalTextContent += ' | Active Product';\n    }\n\n    // Safely extract price information\n    let price = 0;\n    let currency = 'EUR';\n    if (Array.isArray(product.price) && product.price.length > 0) {\n      const priceObj = product.price[0];\n      if (priceObj && typeof priceObj.gross === 'number') {\n        price = priceObj.gross;\n      }\n      if (priceObj && priceObj.currencyId) {\n        currency = priceObj.currencyId;\n      }\n    }\n\n    // Prepare metadata with safe defaults\n    const metadata = {\n      id: product.id,\n      name: productName || '',\n      price: price,\n      currency: currency,\n      stock: typeof product.stock === 'number' ? product.stock : 0,\n      active: Boolean(product.active),\n      manufacturerNumber: product.manufacturerNumber || '',\n      ean: product.ean || '',\n      createdAt: product.createdAt || null,\n      updatedAt: product.updatedAt || null\n    };\n\n    transformedProducts.push({\n      pageContent: finalTextContent,\n      metadata: metadata\n    });\n\n  } catch (error) {\n    transformErrors.push(`Product ${product.id || index}: ${error.message}`);\n  }\n});\n\nconsole.log(`‚úÖ Transformed ${transformedProducts.length} products successfully`);\nif (transformErrors.length > 0) {\n  console.warn(`‚ö†Ô∏è ${transformErrors.length} transformation errors:`);\n  transformErrors.slice(0, 5).forEach(error => console.warn(`  - ${error}`));\n}\n\n// Return transformed products with error tracking\nconst result = transformedProducts.map(product => ({ \n  json: {\n    ...product,\n    _metadata: {\n      totalErrors: previousErrors.length + transformErrors.length,\n      transformErrors: transformErrors.length\n    }\n  }\n}));\n\nif (result.length === 0) {\n  throw new Error('No products could be transformed successfully');\n}\n\nreturn result;"},"id":"f6g7h8i9-0j1k-2l3m-4n5o-6p7q8r9s0t1u","name":"Transform Products for Vector Storage","type":"n8n-nodes-base.code","typeVersion":2,"position":[1560,420]},{"parameters":{"operation":"insert","collection":"shopware_products","options":{"batchSize":100}},"id":"g7h8i9j0-1k2l-3m4n-5o6p-7q8r9s0t1u2v","name":"Store in Qdrant Vector DB","type":"n8n-nodes-base.qdrant","typeVersion":1,"position":[1780,420],"credentials":{"qdrantApi":{"id":"qdrant-shopware-creds","name":"Qdrant Shopware Integration"}}},{"parameters":{"jsCode":"// Enhanced completion logging with Qdrant storage results\nconst items = $input.all();\nconst totalProcessed = items.length;\nconst successfulInserts = items.filter(item => item.json && item.json.status === 'ok').length;\nconst failedInserts = totalProcessed - successfulInserts;\n\nconst completionTime = new Date().toISOString();\n\n// Log completion status\nconsole.log('üéâ ===== IMPORT COMPLETED =====');\nconsole.log(`üìä Products processed: ${totalProcessed}`);\nconsole.log(`‚úÖ Successfully stored in Qdrant: ${successfulInserts}`);\nif (failedInserts > 0) {\n  console.log(`‚ùå Failed to store: ${failedInserts}`);\n}\nconsole.log(`‚è∞ Completion time: ${completionTime}`);\nconsole.log('================================');\n\n// Check for any errors in the Qdrant responses\nconst errors = [];\nitems.forEach((item, index) => {\n  if (item.json && item.json.status !== 'ok') {\n    errors.push(`Item ${index}: ${item.json.message || 'Unknown error'}`);\n  }\n});\n\nif (errors.length > 0) {\n  console.warn('‚ö†Ô∏è Qdrant storage errors:');\n  errors.slice(0, 5).forEach(error => console.warn(`  - ${error}`));\n}\n\nreturn [{\n  json: {\n    status: 'completed',\n    totalProcessed: totalProcessed,\n    successfulInserts: successfulInserts,\n    failedInserts: failedInserts,\n    errorRate: totalProcessed > 0 ? (failedInserts / totalProcessed * 100).toFixed(2) + '%' : '0%',\n    message: `Successfully processed ${totalProcessed} products, ${successfulInserts} stored in Qdrant`,\n    timestamp: completionTime,\n    errors: errors.slice(0, 10) // Keep first 10 errors for debugging\n  }\n}];"},"id":"i9j0k1l2-3m4n-5o6p-7q8r-9s0t1u2v3w4x","name":"Log Completion & Statistics","type":"n8n-nodes-base.code","typeVersion":2,"position":[2000,420]}],"connections":{"Manual Trigger":{"main":[[{"node":"Get OAuth Token","type":"main","index":0}]]},"Get OAuth Token":{"main":[[{"node":"Validate Token & Initialize","type":"main","index":0}]]},"Validate Token & Initialize":{"main":[[{"node":"Fetch Products Page","type":"main","index":0}]]},"Fetch Products Page":{"main":[[{"node":"Process Page & Check Pagination","type":"main","index":0}]]},"Process Page & Check Pagination":{"main":[[{"node":"Has More Pages?","type":"main","index":0}]]},"Has More Pages?":{"main":[[{"node":"Fetch Products Page","type":"main","index":0}],[{"node":"Transform Products for Vector Storage","type":"main","index":0}]]},"Transform Products for Vector Storage":{"main":[[{"node":"Store in Qdrant Vector DB","type":"main","index":0}]]},"Store in Qdrant Vector DB":{"main":[[{"node":"Log Completion & Statistics","type":"main","index":0}]]}},"settings":{"executionOrder":"v1","saveManualExecutions":true,"callerPolicy":"workflowsFromSameOwner"},"staticData":null,"meta":null,"pinData":{},"versionId":"3","triggerCount":1,"tags":[{"createdAt":"2024-01-01T00:00:00.000Z","updatedAt":"2024-01-01T00:00:00.000Z","id":"tag1","name":"shopware"},{"createdAt":"2024-01-01T00:00:00.000Z","updatedAt":"2024-01-01T00:00:00.000Z","id":"tag2","name":"qdrant"},{"createdAt":"2024-01-01T00:00:00.000Z","updatedAt":"2024-01-01T00:00:00.000Z","id":"tag3","name":"vector-database"}]},{"createdAt":"2025-07-26T06:38:34.107Z","updatedAt":"2024-01-01T00:00:00.000Z","id":"R46okgPqTKUuvjuY","name":"Shopware to Qdrant Product Import (Enhanced)","active":false,"isArchived":false,"nodes":[{"parameters":{},"id":"f8b0c5e1-8a2d-4c3e-9f1a-2b3c4d5e6f7g","name":"Manual Trigger","type":"n8n-nodes-base.manualTrigger","typeVersion":1,"position":[240,300]},{"parameters":{"method":"POST","url":"https://shop.held.de/api/oauth/token","sendHeaders":true,"headerParameters":{"parameters":[{"name":"Content-Type","value":"application/json"}]},"sendBody":true,"bodyParameters":{"parameters":[{"name":"grant_type","value":"client_credentials"},{"name":"client_id","value":"SWIANEPSMGTHMLJMT1BHEFAZNW"},{"name":"client_secret","value":"UVJKRGFWZENoVW9OY1ZuUktYNkN6NFRucVNVQU1VR1B0cElhUzE"}]},"options":{"timeout":30000,"retry":{"enabled":true,"maxRetries":3,"retryInterval":1000}}},"id":"a1b2c3d4-5e6f-7g8h-9i0j-1k2l3m4n5o6p","name":"Get OAuth Token","type":"n8n-nodes-base.httpRequest","typeVersion":4.1,"position":[460,300]},{"parameters":{"jsCode":"// Validate OAuth response and initialize pagination\nconst items = $input.all();\nconst response = items[0].json;\n\n// Check if we got a valid access token\nif (!response.access_token) {\n  throw new Error('Failed to obtain access token from Shopware API');\n}\n\nconsole.log('‚úÖ Successfully obtained OAuth token');\nconsole.log(`Token type: ${response.token_type}`);\nconsole.log(`Expires in: ${response.expires_in} seconds`);\n\n// Set initial pagination parameters\nconst paginationData = {\n  page: 1,\n  limit: 50, // Shopware default limit\n  totalPages: null,\n  accessToken: response.access_token,\n  allProducts: [],\n  startTime: new Date().toISOString(),\n  errors: []\n};\n\nreturn [{\n  json: paginationData\n}];"},"id":"b2c3d4e5-6f7g-8h9i-0j1k-2l3m4n5o6p7q","name":"Validate Token & Initialize","type":"n8n-nodes-base.code","typeVersion":2,"position":[680,300]},{"parameters":{"url":"=https://shop.held.de/api/product?page={{ $json.page }}&limit={{ $json.limit }}&associations[translations][]=name&associations[translations][]=description&associations[translations][]=metaDescription&includes[product][]=price&includes[product][]=stock&includes[product][]=active&includes[product][]=manufacturerNumber&includes[product][]=ean&includes[product][]=categories&includes[product][]=properties&includes[product][]=seoUrls&includes[product][]=createdAt&includes[product][]=updatedAt","sendHeaders":true,"headerParameters":{"parameters":[{"name":"Authorization","value":"=Bearer {{ $json.accessToken }}"},{"name":"Content-Type","value":"application/json"},{"name":"Accept","value":"application/json"},{"name":"sw-include-seo-urls","value":"true"}]},"options":{"timeout":60000,"retry":{"enabled":true,"maxRetries":3,"retryInterval":2000}}},"id":"c3d4e5f6-7g8h-9i0j-1k2l-3m4n5o6p7q8r","name":"Fetch Products Page","type":"n8n-nodes-base.httpRequest","typeVersion":4.1,"position":[900,300]},{"parameters":{"jsCode":"// Process the API response with comprehensive error handling\nconst items = $input.all();\nconst response = items[0].json;\n\n// Validate API response structure\nif (!response || typeof response !== 'object') {\n  throw new Error('Invalid API response format');\n}\n\n// Extract products and pagination info with fallbacks\nconst products = response.data || [];\nconst total = response.total || 0;\nconst currentPage = response.page || 1;\nconst limit = response.limit || 50;\nconst totalPages = Math.ceil(total / limit);\n\n// Get existing data from previous iterations\nlet allProducts = $node[\"Validate Token & Initialize\"].json.allProducts || [];\nlet errors = $node[\"Validate Token & Initialize\"].json.errors || [];\n\n// Validate products data\nif (!Array.isArray(products)) {\n  const error = `Page ${currentPage}: Products data is not an array`;\n  errors.push(error);\n  console.warn('‚ö†Ô∏è ' + error);\n} else {\n  // Add current page products to the collection\n  allProducts = allProducts.concat(products);\n  console.log(`üì¶ Fetched page ${currentPage}/${totalPages} - ${products.length} products (Total: ${allProducts.length}/${total})`);\n}\n\n// Determine if we need to fetch more pages\nconst hasMorePages = currentPage < totalPages;\n\nif (hasMorePages) {\n  // Return data for next page\n  return [{\n    json: {\n      page: currentPage + 1,\n      limit: limit,\n      totalPages: totalPages,\n      accessToken: $node[\"Validate Token & Initialize\"].json.accessToken,\n      allProducts: allProducts,\n      hasMorePages: true,\n      currentTotal: allProducts.length,\n      expectedTotal: total,\n      startTime: $node[\"Validate Token & Initialize\"].json.startTime,\n      errors: errors\n    }\n  }];\n} else {\n  // All pages fetched, return final collection\n  const endTime = new Date().toISOString();\n  const duration = new Date(endTime) - new Date($node[\"Validate Token & Initialize\"].json.startTime);\n  \n  console.log(`üéâ Pagination complete! Fetched ${allProducts.length} products in ${Math.round(duration/1000)}s`);\n  \n  if (errors.length > 0) {\n    console.warn(`‚ö†Ô∏è ${errors.length} errors encountered during fetch:`);\n    errors.forEach(error => console.warn(`  - ${error}`));\n  }\n  \n  return [{\n    json: {\n      allProducts: allProducts,\n      hasMorePages: false,\n      totalProducts: allProducts.length,\n      paginationComplete: true,\n      startTime: $node[\"Validate Token & Initialize\"].json.startTime,\n      endTime: endTime,\n      duration: Math.round(duration/1000),\n      errors: errors\n    }\n  }];\n}"},"id":"d4e5f6g7-8h9i-0j1k-2l3m-4n5o6p7q8r9s","name":"Process Page & Check Pagination","type":"n8n-nodes-base.code","typeVersion":2,"position":[1120,300]},{"parameters":{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict"},"conditions":[{"id":"c1a2b3c4-d5e6-f7g8-h9i0-j1k2l3m4n5o6","leftValue":"={{ $json.hasMorePages }}","rightValue":true,"operator":{"type":"boolean","operation":"true"}}],"combinator":"and"},"options":{}},"id":"e5f6g7h8-9i0j-1k2l-3m4n-5o6p7q8r9s0t","name":"Has More Pages?","type":"n8n-nodes-base.if","typeVersion":2,"position":[1340,300]},{"parameters":{"jsCode":"// Transform products for vector storage with enhanced error handling\nconst items = $input.all();\nconst allProducts = items[0].json.allProducts;\nconst previousErrors = items[0].json.errors || [];\n\nif (!Array.isArray(allProducts)) {\n  throw new Error('Products data is not an array');\n}\n\nconsole.log(`üîÑ Starting transformation of ${allProducts.length} products...`);\n\nconst transformedProducts = [];\nconst transformErrors = [];\n\nallProducts.forEach((product, index) => {\n  try {\n    // Validate required fields\n    if (!product || typeof product !== 'object') {\n      transformErrors.push(`Product ${index}: Invalid product object`);\n      return;\n    }\n\n    if (!product.id) {\n      transformErrors.push(`Product ${index}: Missing product ID`);\n      return;\n    }\n\n    // Safely extract and combine text fields\n    const textParts = [];\n    \n    // Add name\n    if (product.name && typeof product.name === 'string') {\n      textParts.push(product.name.trim());\n    }\n    \n    // Add description\n    if (product.description && typeof product.description === 'string') {\n      textParts.push(product.description.trim());\n    }\n    \n    // Add meta description\n    if (product.metaDescription && typeof product.metaDescription === 'string') {\n      textParts.push(product.metaDescription.trim());\n    }\n    \n    // Add properties\n    if (Array.isArray(product.properties)) {\n      const propertyTexts = product.properties\n        .filter(prop => prop && prop.name && prop.value)\n        .map(prop => `${prop.name}: ${prop.value}`);\n      if (propertyTexts.length > 0) {\n        textParts.push(propertyTexts.join(', '));\n      }\n    }\n    \n    // Add categories\n    if (Array.isArray(product.categories)) {\n      const categoryNames = product.categories\n        .filter(cat => cat && cat.name)\n        .map(cat => cat.name);\n      if (categoryNames.length > 0) {\n        textParts.push(categoryNames.join(', '));\n      }\n    }\n    \n    // Add manufacturer number\n    if (product.manufacturerNumber && typeof product.manufacturerNumber === 'string') {\n      textParts.push(product.manufacturerNumber.trim());\n    }\n    \n    // Add EAN\n    if (product.ean && typeof product.ean === 'string') {\n      textParts.push(product.ean.trim());\n    }\n\n    // Combine all text parts\n    const textContent = textParts.filter(part => part.length > 0).join(' | ');\n    \n    // Skip products with no meaningful content\n    if (textContent.trim().length === 0) {\n      transformErrors.push(`Product ${product.id}: No meaningful text content`);\n      return;\n    }\n\n    // Safely extract price information\n    let price = 0;\n    let currency = 'EUR';\n    if (Array.isArray(product.price) && product.price.length > 0) {\n      const priceObj = product.price[0];\n      if (priceObj && typeof priceObj.gross === 'number') {\n        price = priceObj.gross;\n      }\n      if (priceObj && priceObj.currencyId) {\n        currency = priceObj.currencyId;\n      }\n    }\n\n    // Prepare metadata with safe defaults\n    const metadata = {\n      id: product.id,\n      name: product.name || '',\n      price: price,\n      currency: currency,\n      stock: typeof product.stock === 'number' ? product.stock : 0,\n      active: Boolean(product.active),\n      manufacturerNumber: product.manufacturerNumber || '',\n      ean: product.ean || '',\n      categories: Array.isArray(product.categories) \n        ? product.categories.filter(cat => cat && cat.name).map(cat => cat.name)\n        : [],\n      properties: Array.isArray(product.properties) ? product.properties : [],\n      url: (Array.isArray(product.seoUrls) && product.seoUrls.length > 0) \n        ? product.seoUrls[0].seoPathInfo || ''\n        : '',\n      createdAt: product.createdAt || null,\n      updatedAt: product.updatedAt || null\n    };\n\n    transformedProducts.push({\n      pageContent: textContent,\n      metadata: metadata\n    });\n\n  } catch (error) {\n    transformErrors.push(`Product ${product.id || index}: ${error.message}`);\n  }\n});\n\nconsole.log(`‚úÖ Transformed ${transformedProducts.length} products successfully`);\nif (transformErrors.length > 0) {\n  console.warn(`‚ö†Ô∏è ${transformErrors.length} transformation errors:`);\n  transformErrors.slice(0, 10).forEach(error => console.warn(`  - ${error}`));\n  if (transformErrors.length > 10) {\n    console.warn(`  ... and ${transformErrors.length - 10} more errors`);\n  }\n}\n\n// Return transformed products with error tracking\nconst result = transformedProducts.map(product => ({ \n  json: {\n    ...product,\n    _metadata: {\n      totalErrors: previousErrors.length + transformErrors.length,\n      transformErrors: transformErrors.length\n    }\n  }\n}));\n\nif (result.length === 0) {\n  throw new Error('No products could be transformed successfully');\n}\n\nreturn result;"},"id":"f6g7h8i9-0j1k-2l3m-4n5o-6p7q8r9s0t1u","name":"Transform Products for Vector Storage","type":"n8n-nodes-base.code","typeVersion":2,"position":[1560,420]},{"parameters":{"model":"text-embedding-3-small","options":{"batchSize":100,"stripNewLines":true,"maxRetries":3}},"id":"g7h8i9j0-1k2l-3m4n-5o6p-7q8r9s0t1u2v","name":"Generate Embeddings","type":"@n8n/n8n-nodes-langchain.embeddingsOpenAi","typeVersion":1,"position":[1780,420]},{"parameters":{"mode":"insert","qdrantCollection":{"__rl":true,"value":"shopware_products","mode":"name"},"options":{"batchSize":50}},"id":"h8i9j0k1-2l3m-4n5o-6p7q-8r9s0t1u2v3w","name":"Insert into Qdrant","type":"@n8n/n8n-nodes-langchain.vectorStoreQdrant","typeVersion":1,"position":[2000,420]},{"parameters":{"jsCode":"// Comprehensive completion logging with error summary\nconst items = $input.all();\nconst totalProcessed = items.length;\n\n// Extract error information from the first item's metadata\nconst firstItem = items[0];\nconst errorInfo = firstItem?.json?._metadata || {};\n\nconst completionTime = new Date().toISOString();\n\n// Calculate processing statistics\nconst stats = {\n  totalProductsProcessed: totalProcessed,\n  totalErrors: errorInfo.totalErrors || 0,\n  transformErrors: errorInfo.transformErrors || 0,\n  successRate: totalProcessed > 0 ? ((totalProcessed / (totalProcessed + (errorInfo.totalErrors || 0))) * 100).toFixed(2) : 0\n};\n\n// Log comprehensive completion status\nconsole.log('üéâ ===== IMPORT COMPLETED =====');\nconsole.log(`üìä Products successfully processed: ${stats.totalProductsProcessed}`);\nconsole.log(`‚ö†Ô∏è Total errors encountered: ${stats.totalErrors}`);\nconsole.log(`üìà Success rate: ${stats.successRate}%`);\nconsole.log(`‚è∞ Completion time: ${completionTime}`);\nconsole.log('================================');\n\nif (stats.totalErrors > 0) {\n  console.warn('‚ö†Ô∏è Some products could not be processed. Check the logs above for details.');\n}\n\nif (totalProcessed === 0) {\n  throw new Error('No products were successfully processed!');\n}\n\nreturn [{\n  json: {\n    status: 'completed',\n    statistics: stats,\n    message: `Successfully imported ${totalProcessed} products into Qdrant`,\n    timestamp: completionTime,\n    recommendations: stats.totalErrors > 0 \n      ? ['Review error logs', 'Consider re-running for failed products', 'Check data quality in source system']\n      : ['Import completed successfully', 'Ready for chatbot integration', 'Consider setting up monitoring']\n  }\n}];"},"id":"i9j0k1l2-3m4n-5o6p-7q8r-9s0t1u2v3w4x","name":"Log Completion & Statistics","type":"n8n-nodes-base.code","typeVersion":2,"position":[2220,420]},{"parameters":{"jsCode":"// Error handler for OAuth failures\nconst error = $input.first().error;\n\nconsole.error('‚ùå OAuth Authentication Failed!');\nconsole.error(`Error: ${error.message}`);\nconsole.error('Please check:');\nconsole.error('- Shopware API credentials are correct');\nconsole.error('- Integration has proper permissions');\nconsole.error('- Shopware instance is accessible');\n\nreturn [{\n  json: {\n    status: 'failed',\n    stage: 'authentication',\n    error: error.message,\n    timestamp: new Date().toISOString(),\n    troubleshooting: [\n      'Verify client_id and client_secret',\n      'Check Shopware integration permissions',\n      'Ensure API endpoint is accessible',\n      'Review Shopware logs for authentication errors'\n    ]\n  }\n}];"},"id":"j0k1l2m3-4n5o-6p7q-8r9s-0t1u2v3w4x5y","name":"Handle OAuth Error","type":"n8n-nodes-base.code","typeVersion":2,"position":[460,480]},{"parameters":{"jsCode":"// Error handler for API fetch failures\nconst error = $input.first().error;\nconst currentPage = $node[\"Process Page & Check Pagination\"]?.json?.page || 'unknown';\n\nconsole.error(`‚ùå API Fetch Failed on page ${currentPage}!`);\nconsole.error(`Error: ${error.message}`);\nconsole.error('This could be due to:');\nconsole.error('- Network connectivity issues');\nconsole.error('- API rate limiting');\nconsole.error('- Invalid API response format');\nconsole.error('- Server-side errors');\n\nreturn [{\n  json: {\n    status: 'failed',\n    stage: 'data_fetch',\n    page: currentPage,\n    error: error.message,\n    timestamp: new Date().toISOString(),\n    troubleshooting: [\n      'Check network connectivity',\n      'Verify API endpoint availability',\n      'Review rate limiting settings',\n      'Check Shopware server logs',\n      'Try reducing batch size'\n    ]\n  }\n}];"},"id":"k1l2m3n4-5o6p-7q8r-9s0t-1u2v3w4x5y6z","name":"Handle API Error","type":"n8n-nodes-base.code","typeVersion":2,"position":[1120,480]},{"parameters":{"jsCode":"// Error handler for vector storage failures\nconst error = $input.first().error;\n\nconsole.error('‚ùå Vector Storage Failed!');\nconsole.error(`Error: ${error.message}`);\nconsole.error('This could be due to:');\nconsole.error('- Qdrant connection issues');\nconsole.error('- Invalid collection configuration');\nconsole.error('- Embedding generation failures');\nconsole.error('- Insufficient Qdrant storage space');\n\nreturn [{\n  json: {\n    status: 'failed',\n    stage: 'vector_storage',\n    error: error.message,\n    timestamp: new Date().toISOString(),\n    troubleshooting: [\n      'Verify Qdrant connection credentials',\n      'Check collection exists and is accessible',\n      'Ensure OpenAI API key is valid',\n      'Review Qdrant cluster status',\n      'Check available storage space',\n      'Verify embedding dimensions match collection config'\n    ]\n  }\n}];"},"id":"l2m3n4o5-6p7q-8r9s-0t1u-2v3w4x5y6z7a","name":"Handle Vector Storage Error","type":"n8n-nodes-base.code","typeVersion":2,"position":[2000,580]}],"connections":{"Manual Trigger":{"main":[[{"node":"Get OAuth Token","type":"main","index":0}]]},"Get OAuth Token":{"main":[[{"node":"Validate Token & Initialize","type":"main","index":0}]],"error":[[{"node":"Handle OAuth Error","type":"main","index":0}]]},"Validate Token & Initialize":{"main":[[{"node":"Fetch Products Page","type":"main","index":0}]]},"Fetch Products Page":{"main":[[{"node":"Process Page & Check Pagination","type":"main","index":0}]],"error":[[{"node":"Handle API Error","type":"main","index":0}]]},"Process Page & Check Pagination":{"main":[[{"node":"Has More Pages?","type":"main","index":0}]]},"Has More Pages?":{"main":[[{"node":"Fetch Products Page","type":"main","index":0}],[{"node":"Transform Products for Vector Storage","type":"main","index":0}]]},"Transform Products for Vector Storage":{"main":[[{"node":"Generate Embeddings","type":"main","index":0}]]},"Generate Embeddings":{"main":[[{"node":"Insert into Qdrant","type":"main","index":0}]],"error":[[{"node":"Handle Vector Storage Error","type":"main","index":0}]]},"Insert into Qdrant":{"main":[[{"node":"Log Completion & Statistics","type":"main","index":0}]],"error":[[{"node":"Handle Vector Storage Error","type":"main","index":0}]]}},"settings":{"executionOrder":"v1","saveManualExecutions":true,"callerPolicy":"workflowsFromSameOwner","errorWorkflow":{"enabled":false}},"staticData":null,"meta":null,"pinData":{},"versionId":"2","triggerCount":1,"tags":[{"createdAt":"2024-01-01T00:00:00.000Z","updatedAt":"2024-01-01T00:00:00.000Z","id":"tag1","name":"shopware"},{"createdAt":"2024-01-01T00:00:00.000Z","updatedAt":"2024-01-01T00:00:00.000Z","id":"tag2","name":"qdrant"},{"createdAt":"2024-01-01T00:00:00.000Z","updatedAt":"2024-01-01T00:00:00.000Z","id":"tag3","name":"vector-database"},{"createdAt":"2024-01-01T00:00:00.000Z","updatedAt":"2024-01-01T00:00:00.000Z","id":"tag4","name":"enhanced"}]},{"createdAt":"2025-07-26T06:38:39.409Z","updatedAt":"2024-01-01T00:00:00.000Z","id":"WfrjB80qiV7HKM8s","name":"Shopware to Qdrant Product Import (Complete)","active":false,"isArchived":false,"nodes":[{"parameters":{},"id":"f8b0c5e1-8a2d-4c3e-9f1a-2b3c4d5e6f7g","name":"Manual Trigger","type":"n8n-nodes-base.manualTrigger","typeVersion":1,"position":[240,300]},{"parameters":{"method":"POST","url":"https://shop.held.de/api/oauth/token","sendHeaders":true,"headerParameters":{"parameters":[{"name":"Content-Type","value":"application/json"}]},"sendBody":true,"bodyParameters":{"parameters":[{"name":"grant_type","value":"client_credentials"},{"name":"client_id","value":"SWIANEPSMGTHMLJMT1BHEFAZNW"},{"name":"client_secret","value":"UVJKRGFWZENoVW9OY1ZuUktYNkN6NFRucVNVQU1VR1B0cElhUzE"}]},"options":{"timeout":30000,"retry":{"enabled":true,"maxRetries":3,"retryInterval":1000}}},"id":"a1b2c3d4-5e6f-7g8h-9i0j-1k2l3m4n5o6p","name":"Get OAuth Token","type":"n8n-nodes-base.httpRequest","typeVersion":4.1,"position":[460,300]},{"parameters":{"jsCode":"// Validate OAuth response and initialize pagination\nconst items = $input.all();\nconst response = items[0].json;\n\n// Check if we got a valid access token\nif (!response.access_token) {\n  throw new Error('Failed to obtain access token from Shopware API');\n}\n\nconsole.log('‚úÖ Successfully obtained OAuth token');\nconsole.log(`Token type: ${response.token_type}`);\nconsole.log(`Expires in: ${response.expires_in} seconds`);\n\n// Set initial pagination parameters\nconst paginationData = {\n  page: 1,\n  limit: 10, // Reduced for testing\n  totalPages: null,\n  accessToken: response.access_token,\n  allProducts: [],\n  startTime: new Date().toISOString(),\n  errors: []\n};\n\nreturn [{\n  json: paginationData\n}];"},"id":"b2c3d4e5-6f7g-8h9i-0j1k-2l3m4n5o6p7q","name":"Validate Token & Initialize","type":"n8n-nodes-base.code","typeVersion":2,"position":[680,300]},{"parameters":{"url":"=https://shop.held.de/api/product?page={{ $json.page }}&limit={{ $json.limit }}","sendHeaders":true,"headerParameters":{"parameters":[{"name":"Authorization","value":"=Bearer {{ $json.accessToken }}"},{"name":"Content-Type","value":"application/json"},{"name":"Accept","value":"application/json"}]},"options":{"timeout":60000,"retry":{"enabled":true,"maxRetries":3,"retryInterval":2000}}},"id":"c3d4e5f6-7g8h-9i0j-1k2l-3m4n5o6p7q8r","name":"Fetch Products Page","type":"n8n-nodes-base.httpRequest","typeVersion":4.1,"position":[900,300]},{"parameters":{"jsCode":"// Process the API response with comprehensive error handling\nconst items = $input.all();\nconst response = items[0].json;\n\n// Validate API response structure\nif (!response || typeof response !== 'object') {\n  throw new Error('Invalid API response format');\n}\n\n// Extract products and pagination info with fallbacks\nconst products = response.data || [];\nconst total = response.total || 0;\nconst currentPage = response.page || 1;\nconst limit = response.limit || 10;\nconst totalPages = Math.ceil(total / limit);\n\n// Get existing data from previous iterations\nlet allProducts = $node[\"Validate Token & Initialize\"].json.allProducts || [];\nlet errors = $node[\"Validate Token & Initialize\"].json.errors || [];\n\n// Validate products data\nif (!Array.isArray(products)) {\n  const error = `Page ${currentPage}: Products data is not an array`;\n  errors.push(error);\n  console.warn('‚ö†Ô∏è ' + error);\n} else {\n  // Add current page products to the collection\n  allProducts = allProducts.concat(products);\n  console.log(`üì¶ Fetched page ${currentPage}/${totalPages} - ${products.length} products (Total: ${allProducts.length}/${total})`);\n}\n\n// Determine if we need to fetch more pages (limit to 2 pages for testing)\nconst hasMorePages = currentPage < Math.min(totalPages, 2);\n\nif (hasMorePages) {\n  // Return data for next page\n  return [{\n    json: {\n      page: currentPage + 1,\n      limit: limit,\n      totalPages: totalPages,\n      accessToken: $node[\"Validate Token & Initialize\"].json.accessToken,\n      allProducts: allProducts,\n      hasMorePages: true,\n      currentTotal: allProducts.length,\n      expectedTotal: total,\n      startTime: $node[\"Validate Token & Initialize\"].json.startTime,\n      errors: errors\n    }\n  }];\n} else {\n  // All pages fetched, return final collection\n  const endTime = new Date().toISOString();\n  const duration = new Date(endTime) - new Date($node[\"Validate Token & Initialize\"].json.startTime);\n  \n  console.log(`üéâ Pagination complete! Fetched ${allProducts.length} products in ${Math.round(duration/1000)}s`);\n  \n  if (errors.length > 0) {\n    console.warn(`‚ö†Ô∏è ${errors.length} errors encountered during fetch:`);\n    errors.forEach(error => console.warn(`  - ${error}`));\n  }\n  \n  return [{\n    json: {\n      allProducts: allProducts,\n      hasMorePages: false,\n      totalProducts: allProducts.length,\n      paginationComplete: true,\n      startTime: $node[\"Validate Token & Initialize\"].json.startTime,\n      endTime: endTime,\n      duration: Math.round(duration/1000),\n      errors: errors\n    }\n  }];\n}"},"id":"d4e5f6g7-8h9i-0j1k-2l3m-4n5o6p7q8r9s","name":"Process Page & Check Pagination","type":"n8n-nodes-base.code","typeVersion":2,"position":[1120,300]},{"parameters":{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict"},"conditions":[{"id":"c1a2b3c4-d5e6-f7g8-h9i0-j1k2l3m4n5o6","leftValue":"={{ $json.hasMorePages }}","rightValue":true,"operator":{"type":"boolean","operation":"equal","rightType":"boolean"}}],"combinator":"and"},"options":{}},"id":"e5f6g7h8-9i0j-1k2l-3m4n-5o6p7q8r9s0t","name":"Has More Pages?","type":"n8n-nodes-base.if","typeVersion":2,"position":[1340,300]},{"parameters":{"jsCode":"// Transform products for vector storage with enhanced error handling\nconst items = $input.all();\nconst allProducts = items[0].json.allProducts;\nconst previousErrors = items[0].json.errors || [];\n\nif (!Array.isArray(allProducts)) {\n  throw new Error('Products data is not an array');\n}\n\nconsole.log(`üîÑ Starting transformation of ${allProducts.length} products...`);\n\nconst transformedProducts = [];\nconst transformErrors = [];\n\nallProducts.forEach((product, index) => {\n  try {\n    // Validate required fields\n    if (!product || typeof product !== 'object') {\n      transformErrors.push(`Product ${index}: Invalid product object`);\n      return;\n    }\n\n    if (!product.id) {\n      transformErrors.push(`Product ${index}: Missing product ID`);\n      return;\n    }\n\n    // Safely extract and combine text fields\n    const textParts = [];\n    \n    // Extract name from translations or direct field\n    let productName = product.name;\n    if (!productName && product.translations && Array.isArray(product.translations)) {\n      const translation = product.translations.find(t => t.name);\n      productName = translation?.name;\n    }\n    if (productName && typeof productName === 'string') {\n      textParts.push(productName.trim());\n    }\n    \n    // Extract description from translations or direct field\n    let productDescription = product.description;\n    if (!productDescription && product.translations && Array.isArray(product.translations)) {\n      const translation = product.translations.find(t => t.description);\n      productDescription = translation?.description;\n    }\n    if (productDescription && typeof productDescription === 'string') {\n      // Strip HTML tags from description\n      const cleanDescription = productDescription.replace(/<[^>]*>/g, ' ').replace(/\\s+/g, ' ').trim();\n      if (cleanDescription.length > 0) {\n        textParts.push(cleanDescription);\n      }\n    }\n    \n    // Add EAN if available\n    if (product.ean && typeof product.ean === 'string') {\n      textParts.push(`EAN: ${product.ean.trim()}`);\n    }\n    \n    // Add manufacturer number if available\n    if (product.manufacturerNumber && typeof product.manufacturerNumber === 'string') {\n      textParts.push(`MFG: ${product.manufacturerNumber.trim()}`);\n    }\n\n    // Combine all text parts\n    const textContent = textParts.filter(part => part.length > 0).join(' | ');\n    \n    // For products with minimal content, create basic description\n    let finalTextContent = textContent;\n    if (finalTextContent.trim().length === 0) {\n      finalTextContent = `Product ID: ${product.id}`;\n      if (product.ean) finalTextContent += ` | EAN: ${product.ean}`;\n      if (product.active) finalTextContent += ' | Active Product';\n    }\n\n    // Safely extract price information\n    let price = 0;\n    let currency = 'EUR';\n    if (Array.isArray(product.price) && product.price.length > 0) {\n      const priceObj = product.price[0];\n      if (priceObj && typeof priceObj.gross === 'number') {\n        price = priceObj.gross;\n      }\n      if (priceObj && priceObj.currencyId) {\n        currency = priceObj.currencyId;\n      }\n    }\n\n    // Prepare metadata with safe defaults\n    const metadata = {\n      id: product.id,\n      name: productName || '',\n      price: price,\n      currency: currency,\n      stock: typeof product.stock === 'number' ? product.stock : 0,\n      active: Boolean(product.active),\n      manufacturerNumber: product.manufacturerNumber || '',\n      ean: product.ean || '',\n      createdAt: product.createdAt || null,\n      updatedAt: product.updatedAt || null\n    };\n\n    transformedProducts.push({\n      pageContent: finalTextContent,\n      metadata: metadata\n    });\n\n  } catch (error) {\n    transformErrors.push(`Product ${product.id || index}: ${error.message}`);\n  }\n});\n\nconsole.log(`‚úÖ Transformed ${transformedProducts.length} products successfully`);\nif (transformErrors.length > 0) {\n  console.warn(`‚ö†Ô∏è ${transformErrors.length} transformation errors:`);\n  transformErrors.slice(0, 5).forEach(error => console.warn(`  - ${error}`));\n}\n\n// Return transformed products with error tracking\nconst result = transformedProducts.map(product => ({ \n  json: {\n    ...product,\n    _metadata: {\n      totalErrors: previousErrors.length + transformErrors.length,\n      transformErrors: transformErrors.length\n    }\n  }\n}));\n\nif (result.length === 0) {\n  throw new Error('No products could be transformed successfully');\n}\n\nreturn result;"},"id":"f6g7h8i9-0j1k-2l3m-4n5o-6p7q8r9s0t1u","name":"Transform Products for Vector Storage","type":"n8n-nodes-base.code","typeVersion":2,"position":[1560,420]},{"parameters":{"jsCode":"// Store products in Qdrant using HTTP API\nconst items = $input.all();\n\nif (!Array.isArray(items) || items.length === 0) {\n  throw new Error('No products to store in Qdrant');\n}\n\nconsole.log(`üîÑ Preparing to store ${items.length} products in Qdrant...`);\n\n// Prepare points for Qdrant\nconst points = [];\nconst errors = [];\n\nitems.forEach((item, index) => {\n  try {\n    const product = item.json;\n    \n    if (!product || !product.pageContent || !product.metadata || !product.metadata.id) {\n      errors.push(`Item ${index}: Missing required fields`);\n      return;\n    }\n\n    // Create a simple vector (placeholder since we don't have embeddings yet)\n    // In a real implementation, you'd generate embeddings from pageContent\n    const vector = new Array(1536).fill(0).map(() => Math.random() * 0.1);\n    \n    const point = {\n      id: product.metadata.id,\n      vector: vector,\n      payload: {\n        content: product.pageContent,\n        name: product.metadata.name,\n        price: product.metadata.price,\n        currency: product.metadata.currency,\n        stock: product.metadata.stock,\n        active: product.metadata.active,\n        ean: product.metadata.ean,\n        manufacturerNumber: product.metadata.manufacturerNumber,\n        createdAt: product.metadata.createdAt,\n        updatedAt: product.metadata.updatedAt\n      }\n    };\n    \n    points.push(point);\n    \n  } catch (error) {\n    errors.push(`Item ${index}: ${error.message}`);\n  }\n});\n\nif (points.length === 0) {\n  throw new Error('No valid points could be prepared for Qdrant storage');\n}\n\nconsole.log(`‚úÖ Prepared ${points.length} points for Qdrant storage`);\nif (errors.length > 0) {\n  console.warn(`‚ö†Ô∏è ${errors.length} preparation errors:`);\n  errors.slice(0, 3).forEach(error => console.warn(`  - ${error}`));\n}\n\n// Return the points data for the HTTP request\nreturn [{\n  json: {\n    points: points,\n    totalPoints: points.length,\n    errors: errors\n  }\n}];"},"id":"g7h8i9j0-1k2l-3m4n-5o6p-7q8r9s0t1u2v","name":"Prepare Qdrant Points","type":"n8n-nodes-base.code","typeVersion":2,"position":[1780,420]},{"parameters":{"method":"PUT","url":"https://8ec957ec-27b4-4041-9714-f8dde751b007.europe-west3-0.gcp.cloud.qdrant.io:6333/collections/shopware_products/points","sendHeaders":true,"headerParameters":{"parameters":[{"name":"api-key","value":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhY2Nlc3MiOiJtIn0.50x-a9c0zTX_dzWnKjq-xM7rJ0ym6_yZ-D_eN_Idft4"},{"name":"Content-Type","value":"application/json"}]},"sendBody":true,"bodyParameters":{"parameters":[{"name":"points","value":"={{ $json.points }}"}]},"options":{"timeout":60000,"retry":{"enabled":true,"maxRetries":2,"retryInterval":3000}}},"id":"h8i9j0k1-2l3m-4n5o-6p7q-8r9s0t1u2v3w","name":"Store in Qdrant Vector DB","type":"n8n-nodes-base.httpRequest","typeVersion":4.1,"position":[2000,420]},{"parameters":{"jsCode":"// Enhanced completion logging with Qdrant storage results\nconst items = $input.all();\nconst qdrantResponse = items[0].json;\n\n// Parse Qdrant response\nlet successfulInserts = 0;\nlet failedInserts = 0;\nlet totalProcessed = 0;\n\nif (qdrantResponse && qdrantResponse.status === 'ok') {\n  successfulInserts = qdrantResponse.result?.operation_id ? 1 : 0;\n  totalProcessed = 1;\n} else {\n  failedInserts = 1;\n  totalProcessed = 1;\n}\n\nconst completionTime = new Date().toISOString();\n\n// Log completion status\nconsole.log('üéâ ===== IMPORT COMPLETED =====');\nconsole.log(`üìä Batch operations processed: ${totalProcessed}`);\nconsole.log(`‚úÖ Successfully stored in Qdrant: ${successfulInserts}`);\nif (failedInserts > 0) {\n  console.log(`‚ùå Failed to store: ${failedInserts}`);\n  console.log(`Response: ${JSON.stringify(qdrantResponse, null, 2)}`);\n}\nconsole.log(`‚è∞ Completion time: ${completionTime}`);\nconsole.log('================================');\n\nreturn [{\n  json: {\n    status: 'completed',\n    totalProcessed: totalProcessed,\n    successfulInserts: successfulInserts,\n    failedInserts: failedInserts,\n    errorRate: totalProcessed > 0 ? (failedInserts / totalProcessed * 100).toFixed(2) + '%' : '0%',\n    message: `Successfully processed batch operation, ${successfulInserts} operations completed`,\n    timestamp: completionTime,\n    qdrantResponse: qdrantResponse\n  }\n}];"},"id":"i9j0k1l2-3m4n-5o6p-7q8r-9s0t1u2v3w4x","name":"Log Completion & Statistics","type":"n8n-nodes-base.code","typeVersion":2,"position":[2220,420]}],"connections":{"Manual Trigger":{"main":[[{"node":"Get OAuth Token","type":"main","index":0}]]},"Get OAuth Token":{"main":[[{"node":"Validate Token & Initialize","type":"main","index":0}]]},"Validate Token & Initialize":{"main":[[{"node":"Fetch Products Page","type":"main","index":0}]]},"Fetch Products Page":{"main":[[{"node":"Process Page & Check Pagination","type":"main","index":0}]]},"Process Page & Check Pagination":{"main":[[{"node":"Has More Pages?","type":"main","index":0}]]},"Has More Pages?":{"main":[[{"node":"Fetch Products Page","type":"main","index":0}],[{"node":"Transform Products for Vector Storage","type":"main","index":0}]]},"Transform Products for Vector Storage":{"main":[[{"node":"Prepare Qdrant Points","type":"main","index":0}]]},"Prepare Qdrant Points":{"main":[[{"node":"Store in Qdrant Vector DB","type":"main","index":0}]]},"Store in Qdrant Vector DB":{"main":[[{"node":"Log Completion & Statistics","type":"main","index":0}]]}},"settings":{"executionOrder":"v1","saveManualExecutions":true,"callerPolicy":"workflowsFromSameOwner"},"staticData":null,"meta":null,"pinData":{},"versionId":"4","triggerCount":1,"tags":[{"createdAt":"2024-01-01T00:00:00.000Z","updatedAt":"2024-01-01T00:00:00.000Z","id":"tag1","name":"shopware"},{"createdAt":"2024-01-01T00:00:00.000Z","updatedAt":"2024-01-01T00:00:00.000Z","id":"tag2","name":"qdrant"},{"createdAt":"2024-01-01T00:00:00.000Z","updatedAt":"2024-01-01T00:00:00.000Z","id":"tag3","name":"vector-database"}]},{"createdAt":"2025-07-26T06:39:10.490Z","updatedAt":"2024-01-01T00:00:00.000Z","id":"hLM81zgV6c6rsa3D","name":"Shopware to Qdrant Product Import (Complete)","active":false,"isArchived":false,"nodes":[{"parameters":{},"id":"f8b0c5e1-8a2d-4c3e-9f1a-2b3c4d5e6f7g","name":"Manual Trigger","type":"n8n-nodes-base.manualTrigger","typeVersion":1,"position":[240,300]},{"parameters":{"method":"POST","url":"https://shop.held.de/api/oauth/token","sendHeaders":true,"headerParameters":{"parameters":[{"name":"Content-Type","value":"application/json"}]},"sendBody":true,"bodyParameters":{"parameters":[{"name":"grant_type","value":"client_credentials"},{"name":"client_id","value":"SWIANEPSMGTHMLJMT1BHEFAZNW"},{"name":"client_secret","value":"UVJKRGFWZENoVW9OY1ZuUktYNkN6NFRucVNVQU1VR1B0cElhUzE"}]},"options":{"timeout":30000,"retry":{"enabled":true,"maxRetries":3,"retryInterval":1000}}},"id":"a1b2c3d4-5e6f-7g8h-9i0j-1k2l3m4n5o6p","name":"Get OAuth Token","type":"n8n-nodes-base.httpRequest","typeVersion":4.1,"position":[460,300]},{"parameters":{"jsCode":"// Validate OAuth response and initialize pagination\nconst items = $input.all();\nconst response = items[0].json;\n\n// Check if we got a valid access token\nif (!response.access_token) {\n  throw new Error('Failed to obtain access token from Shopware API');\n}\n\nconsole.log('‚úÖ Successfully obtained OAuth token');\nconsole.log(`Token type: ${response.token_type}`);\nconsole.log(`Expires in: ${response.expires_in} seconds`);\n\n// Set initial pagination parameters\nconst paginationData = {\n  page: 1,\n  limit: 10, // Reduced for testing\n  totalPages: null,\n  accessToken: response.access_token,\n  allProducts: [],\n  startTime: new Date().toISOString(),\n  errors: []\n};\n\nreturn [{\n  json: paginationData\n}];"},"id":"b2c3d4e5-6f7g-8h9i-0j1k-2l3m4n5o6p7q","name":"Validate Token & Initialize","type":"n8n-nodes-base.code","typeVersion":2,"position":[680,300]},{"parameters":{"url":"=https://shop.held.de/api/product?page={{ $json.page }}&limit={{ $json.limit }}","sendHeaders":true,"headerParameters":{"parameters":[{"name":"Authorization","value":"=Bearer {{ $json.accessToken }}"},{"name":"Content-Type","value":"application/json"},{"name":"Accept","value":"application/json"}]},"options":{"timeout":60000,"retry":{"enabled":true,"maxRetries":3,"retryInterval":2000}}},"id":"c3d4e5f6-7g8h-9i0j-1k2l-3m4n5o6p7q8r","name":"Fetch Products Page","type":"n8n-nodes-base.httpRequest","typeVersion":4.1,"position":[900,300]},{"parameters":{"jsCode":"// Process the API response with comprehensive error handling\nconst items = $input.all();\nconst response = items[0].json;\n\n// Validate API response structure\nif (!response || typeof response !== 'object') {\n  throw new Error('Invalid API response format');\n}\n\n// Extract products and pagination info with fallbacks\nconst products = response.data || [];\nconst total = response.total || 0;\nconst currentPage = response.page || 1;\nconst limit = response.limit || 10;\nconst totalPages = Math.ceil(total / limit);\n\n// Get existing data from previous iterations\nlet allProducts = $node[\"Validate Token & Initialize\"].json.allProducts || [];\nlet errors = $node[\"Validate Token & Initialize\"].json.errors || [];\n\n// Validate products data\nif (!Array.isArray(products)) {\n  const error = `Page ${currentPage}: Products data is not an array`;\n  errors.push(error);\n  console.warn('‚ö†Ô∏è ' + error);\n} else {\n  // Add current page products to the collection\n  allProducts = allProducts.concat(products);\n  console.log(`üì¶ Fetched page ${currentPage}/${totalPages} - ${products.length} products (Total: ${allProducts.length}/${total})`);\n}\n\n// Determine if we need to fetch more pages (limit to 2 pages for testing)\nconst hasMorePages = currentPage < Math.min(totalPages, 2);\n\nif (hasMorePages) {\n  // Return data for next page\n  return [{\n    json: {\n      page: currentPage + 1,\n      limit: limit,\n      totalPages: totalPages,\n      accessToken: $node[\"Validate Token & Initialize\"].json.accessToken,\n      allProducts: allProducts,\n      hasMorePages: true,\n      currentTotal: allProducts.length,\n      expectedTotal: total,\n      startTime: $node[\"Validate Token & Initialize\"].json.startTime,\n      errors: errors\n    }\n  }];\n} else {\n  // All pages fetched, return final collection\n  const endTime = new Date().toISOString();\n  const duration = new Date(endTime) - new Date($node[\"Validate Token & Initialize\"].json.startTime);\n  \n  console.log(`üéâ Pagination complete! Fetched ${allProducts.length} products in ${Math.round(duration/1000)}s`);\n  \n  if (errors.length > 0) {\n    console.warn(`‚ö†Ô∏è ${errors.length} errors encountered during fetch:`);\n    errors.forEach(error => console.warn(`  - ${error}`));\n  }\n  \n  return [{\n    json: {\n      allProducts: allProducts,\n      hasMorePages: false,\n      totalProducts: allProducts.length,\n      paginationComplete: true,\n      startTime: $node[\"Validate Token & Initialize\"].json.startTime,\n      endTime: endTime,\n      duration: Math.round(duration/1000),\n      errors: errors\n    }\n  }];\n}"},"id":"d4e5f6g7-8h9i-0j1k-2l3m-4n5o6p7q8r9s","name":"Process Page & Check Pagination","type":"n8n-nodes-base.code","typeVersion":2,"position":[1120,300]},{"parameters":{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict"},"conditions":[{"id":"c1a2b3c4-d5e6-f7g8-h9i0-j1k2l3m4n5o6","leftValue":"={{ $json.hasMorePages }}","rightValue":true,"operator":{"type":"boolean","operation":"equal","rightType":"boolean"}}],"combinator":"and"},"options":{}},"id":"e5f6g7h8-9i0j-1k2l-3m4n-5o6p7q8r9s0t","name":"Has More Pages?","type":"n8n-nodes-base.if","typeVersion":2,"position":[1340,300]},{"parameters":{"jsCode":"// Transform products for vector storage with enhanced error handling\nconst items = $input.all();\nconst allProducts = items[0].json.allProducts;\nconst previousErrors = items[0].json.errors || [];\n\nif (!Array.isArray(allProducts)) {\n  throw new Error('Products data is not an array');\n}\n\nconsole.log(`üîÑ Starting transformation of ${allProducts.length} products...`);\n\nconst transformedProducts = [];\nconst transformErrors = [];\n\nallProducts.forEach((product, index) => {\n  try {\n    // Validate required fields\n    if (!product || typeof product !== 'object') {\n      transformErrors.push(`Product ${index}: Invalid product object`);\n      return;\n    }\n\n    if (!product.id) {\n      transformErrors.push(`Product ${index}: Missing product ID`);\n      return;\n    }\n\n    // Safely extract and combine text fields\n    const textParts = [];\n    \n    // Extract name from translations or direct field\n    let productName = product.name;\n    if (!productName && product.translations && Array.isArray(product.translations)) {\n      const translation = product.translations.find(t => t.name);\n      productName = translation?.name;\n    }\n    if (productName && typeof productName === 'string') {\n      textParts.push(productName.trim());\n    }\n    \n    // Extract description from translations or direct field\n    let productDescription = product.description;\n    if (!productDescription && product.translations && Array.isArray(product.translations)) {\n      const translation = product.translations.find(t => t.description);\n      productDescription = translation?.description;\n    }\n    if (productDescription && typeof productDescription === 'string') {\n      // Strip HTML tags from description\n      const cleanDescription = productDescription.replace(/<[^>]*>/g, ' ').replace(/\\s+/g, ' ').trim();\n      if (cleanDescription.length > 0) {\n        textParts.push(cleanDescription);\n      }\n    }\n    \n    // Add EAN if available\n    if (product.ean && typeof product.ean === 'string') {\n      textParts.push(`EAN: ${product.ean.trim()}`);\n    }\n    \n    // Add manufacturer number if available\n    if (product.manufacturerNumber && typeof product.manufacturerNumber === 'string') {\n      textParts.push(`MFG: ${product.manufacturerNumber.trim()}`);\n    }\n\n    // Combine all text parts\n    const textContent = textParts.filter(part => part.length > 0).join(' | ');\n    \n    // For products with minimal content, create basic description\n    let finalTextContent = textContent;\n    if (finalTextContent.trim().length === 0) {\n      finalTextContent = `Product ID: ${product.id}`;\n      if (product.ean) finalTextContent += ` | EAN: ${product.ean}`;\n      if (product.active) finalTextContent += ' | Active Product';\n    }\n\n    // Safely extract price information\n    let price = 0;\n    let currency = 'EUR';\n    if (Array.isArray(product.price) && product.price.length > 0) {\n      const priceObj = product.price[0];\n      if (priceObj && typeof priceObj.gross === 'number') {\n        price = priceObj.gross;\n      }\n      if (priceObj && priceObj.currencyId) {\n        currency = priceObj.currencyId;\n      }\n    }\n\n    // Prepare metadata with safe defaults\n    const metadata = {\n      id: product.id,\n      name: productName || '',\n      price: price,\n      currency: currency,\n      stock: typeof product.stock === 'number' ? product.stock : 0,\n      active: Boolean(product.active),\n      manufacturerNumber: product.manufacturerNumber || '',\n      ean: product.ean || '',\n      createdAt: product.createdAt || null,\n      updatedAt: product.updatedAt || null\n    };\n\n    transformedProducts.push({\n      pageContent: finalTextContent,\n      metadata: metadata\n    });\n\n  } catch (error) {\n    transformErrors.push(`Product ${product.id || index}: ${error.message}`);\n  }\n});\n\nconsole.log(`‚úÖ Transformed ${transformedProducts.length} products successfully`);\nif (transformErrors.length > 0) {\n  console.warn(`‚ö†Ô∏è ${transformErrors.length} transformation errors:`);\n  transformErrors.slice(0, 5).forEach(error => console.warn(`  - ${error}`));\n}\n\n// Return transformed products with error tracking\nconst result = transformedProducts.map(product => ({ \n  json: {\n    ...product,\n    _metadata: {\n      totalErrors: previousErrors.length + transformErrors.length,\n      transformErrors: transformErrors.length\n    }\n  }\n}));\n\nif (result.length === 0) {\n  throw new Error('No products could be transformed successfully');\n}\n\nreturn result;"},"id":"f6g7h8i9-0j1k-2l3m-4n5o-6p7q8r9s0t1u","name":"Transform Products for Vector Storage","type":"n8n-nodes-base.code","typeVersion":2,"position":[1560,420]},{"parameters":{"jsCode":"// Store products in Qdrant using HTTP API\nconst items = $input.all();\n\nif (!Array.isArray(items) || items.length === 0) {\n  throw new Error('No products to store in Qdrant');\n}\n\nconsole.log(`üîÑ Preparing to store ${items.length} products in Qdrant...`);\n\n// Prepare points for Qdrant\nconst points = [];\nconst errors = [];\n\nitems.forEach((item, index) => {\n  try {\n    const product = item.json;\n    \n    if (!product || !product.pageContent || !product.metadata || !product.metadata.id) {\n      errors.push(`Item ${index}: Missing required fields`);\n      return;\n    }\n\n    // Create a simple vector (placeholder since we don't have embeddings yet)\n    // In a real implementation, you'd generate embeddings from pageContent\n    const vector = new Array(1536).fill(0).map(() => Math.random() * 0.1);\n    \n    const point = {\n      id: product.metadata.id,\n      vector: vector,\n      payload: {\n        content: product.pageContent,\n        name: product.metadata.name,\n        price: product.metadata.price,\n        currency: product.metadata.currency,\n        stock: product.metadata.stock,\n        active: product.metadata.active,\n        ean: product.metadata.ean,\n        manufacturerNumber: product.metadata.manufacturerNumber,\n        createdAt: product.metadata.createdAt,\n        updatedAt: product.metadata.updatedAt\n      }\n    };\n    \n    points.push(point);\n    \n  } catch (error) {\n    errors.push(`Item ${index}: ${error.message}`);\n  }\n});\n\nif (points.length === 0) {\n  throw new Error('No valid points could be prepared for Qdrant storage');\n}\n\nconsole.log(`‚úÖ Prepared ${points.length} points for Qdrant storage`);\nif (errors.length > 0) {\n  console.warn(`‚ö†Ô∏è ${errors.length} preparation errors:`);\n  errors.slice(0, 3).forEach(error => console.warn(`  - ${error}`));\n}\n\n// Return the points data for the HTTP request\nreturn [{\n  json: {\n    points: points,\n    totalPoints: points.length,\n    errors: errors\n  }\n}];"},"id":"g7h8i9j0-1k2l-3m4n-5o6p-7q8r9s0t1u2v","name":"Prepare Qdrant Points","type":"n8n-nodes-base.code","typeVersion":2,"position":[1780,420]},{"parameters":{"method":"PUT","url":"https://8ec957ec-27b4-4041-9714-f8dde751b007.europe-west3-0.gcp.cloud.qdrant.io:6333/collections/shopware_products/points","sendHeaders":true,"headerParameters":{"parameters":[{"name":"api-key","value":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhY2Nlc3MiOiJtIn0.50x-a9c0zTX_dzWnKjq-xM7rJ0ym6_yZ-D_eN_Idft4"},{"name":"Content-Type","value":"application/json"}]},"sendBody":true,"bodyParameters":{"parameters":[{"name":"points","value":"={{ $json.points }}"}]},"options":{"timeout":60000,"retry":{"enabled":true,"maxRetries":2,"retryInterval":3000}}},"id":"h8i9j0k1-2l3m-4n5o-6p7q-8r9s0t1u2v3w","name":"Store in Qdrant Vector DB","type":"n8n-nodes-base.httpRequest","typeVersion":4.1,"position":[2000,420]},{"parameters":{"jsCode":"// Enhanced completion logging with Qdrant storage results\nconst items = $input.all();\nconst qdrantResponse = items[0].json;\n\n// Parse Qdrant response\nlet successfulInserts = 0;\nlet failedInserts = 0;\nlet totalProcessed = 0;\n\nif (qdrantResponse && qdrantResponse.status === 'ok') {\n  successfulInserts = qdrantResponse.result?.operation_id ? 1 : 0;\n  totalProcessed = 1;\n} else {\n  failedInserts = 1;\n  totalProcessed = 1;\n}\n\nconst completionTime = new Date().toISOString();\n\n// Log completion status\nconsole.log('üéâ ===== IMPORT COMPLETED =====');\nconsole.log(`üìä Batch operations processed: ${totalProcessed}`);\nconsole.log(`‚úÖ Successfully stored in Qdrant: ${successfulInserts}`);\nif (failedInserts > 0) {\n  console.log(`‚ùå Failed to store: ${failedInserts}`);\n  console.log(`Response: ${JSON.stringify(qdrantResponse, null, 2)}`);\n}\nconsole.log(`‚è∞ Completion time: ${completionTime}`);\nconsole.log('================================');\n\nreturn [{\n  json: {\n    status: 'completed',\n    totalProcessed: totalProcessed,\n    successfulInserts: successfulInserts,\n    failedInserts: failedInserts,\n    errorRate: totalProcessed > 0 ? (failedInserts / totalProcessed * 100).toFixed(2) + '%' : '0%',\n    message: `Successfully processed batch operation, ${successfulInserts} operations completed`,\n    timestamp: completionTime,\n    qdrantResponse: qdrantResponse\n  }\n}];"},"id":"i9j0k1l2-3m4n-5o6p-7q8r-9s0t1u2v3w4x","name":"Log Completion & Statistics","type":"n8n-nodes-base.code","typeVersion":2,"position":[2220,420]}],"connections":{"Manual Trigger":{"main":[[{"node":"Get OAuth Token","type":"main","index":0}]]},"Get OAuth Token":{"main":[[{"node":"Validate Token & Initialize","type":"main","index":0}]]},"Validate Token & Initialize":{"main":[[{"node":"Fetch Products Page","type":"main","index":0}]]},"Fetch Products Page":{"main":[[{"node":"Process Page & Check Pagination","type":"main","index":0}]]},"Process Page & Check Pagination":{"main":[[{"node":"Has More Pages?","type":"main","index":0}]]},"Has More Pages?":{"main":[[{"node":"Fetch Products Page","type":"main","index":0}],[{"node":"Transform Products for Vector Storage","type":"main","index":0}]]},"Transform Products for Vector Storage":{"main":[[{"node":"Prepare Qdrant Points","type":"main","index":0}]]},"Prepare Qdrant Points":{"main":[[{"node":"Store in Qdrant Vector DB","type":"main","index":0}]]},"Store in Qdrant Vector DB":{"main":[[{"node":"Log Completion & Statistics","type":"main","index":0}]]}},"settings":{"executionOrder":"v1","saveManualExecutions":true,"callerPolicy":"workflowsFromSameOwner"},"staticData":null,"meta":null,"pinData":{},"versionId":"4","triggerCount":1,"tags":[{"createdAt":"2024-01-01T00:00:00.000Z","updatedAt":"2024-01-01T00:00:00.000Z","id":"tag1","name":"shopware"},{"createdAt":"2024-01-01T00:00:00.000Z","updatedAt":"2024-01-01T00:00:00.000Z","id":"tag2","name":"qdrant"},{"createdAt":"2024-01-01T00:00:00.000Z","updatedAt":"2024-01-01T00:00:00.000Z","id":"tag3","name":"vector-database"}]},{"createdAt":"2025-07-26T06:39:11.350Z","updatedAt":"2024-01-01T00:00:00.000Z","id":"RwykvK2aZadqVQK8","name":"Shopware to Qdrant Product Import (Enhanced)","active":false,"isArchived":false,"nodes":[{"parameters":{},"id":"f8b0c5e1-8a2d-4c3e-9f1a-2b3c4d5e6f7g","name":"Manual Trigger","type":"n8n-nodes-base.manualTrigger","typeVersion":1,"position":[240,300]},{"parameters":{"method":"POST","url":"https://shop.held.de/api/oauth/token","sendHeaders":true,"headerParameters":{"parameters":[{"name":"Content-Type","value":"application/json"}]},"sendBody":true,"bodyParameters":{"parameters":[{"name":"grant_type","value":"client_credentials"},{"name":"client_id","value":"SWIANEPSMGTHMLJMT1BHEFAZNW"},{"name":"client_secret","value":"UVJKRGFWZENoVW9OY1ZuUktYNkN6NFRucVNVQU1VR1B0cElhUzE"}]},"options":{"timeout":30000,"retry":{"enabled":true,"maxRetries":3,"retryInterval":1000}}},"id":"a1b2c3d4-5e6f-7g8h-9i0j-1k2l3m4n5o6p","name":"Get OAuth Token","type":"n8n-nodes-base.httpRequest","typeVersion":4.1,"position":[460,300]},{"parameters":{"jsCode":"// Validate OAuth response and initialize pagination\nconst items = $input.all();\nconst response = items[0].json;\n\n// Check if we got a valid access token\nif (!response.access_token) {\n  throw new Error('Failed to obtain access token from Shopware API');\n}\n\nconsole.log('‚úÖ Successfully obtained OAuth token');\nconsole.log(`Token type: ${response.token_type}`);\nconsole.log(`Expires in: ${response.expires_in} seconds`);\n\n// Set initial pagination parameters\nconst paginationData = {\n  page: 1,\n  limit: 50, // Shopware default limit\n  totalPages: null,\n  accessToken: response.access_token,\n  allProducts: [],\n  startTime: new Date().toISOString(),\n  errors: []\n};\n\nreturn [{\n  json: paginationData\n}];"},"id":"b2c3d4e5-6f7g-8h9i-0j1k-2l3m4n5o6p7q","name":"Validate Token & Initialize","type":"n8n-nodes-base.code","typeVersion":2,"position":[680,300]},{"parameters":{"url":"=https://shop.held.de/api/product?page={{ $json.page }}&limit={{ $json.limit }}&associations[translations][]=name&associations[translations][]=description&associations[translations][]=metaDescription&includes[product][]=price&includes[product][]=stock&includes[product][]=active&includes[product][]=manufacturerNumber&includes[product][]=ean&includes[product][]=categories&includes[product][]=properties&includes[product][]=seoUrls&includes[product][]=createdAt&includes[product][]=updatedAt","sendHeaders":true,"headerParameters":{"parameters":[{"name":"Authorization","value":"=Bearer {{ $json.accessToken }}"},{"name":"Content-Type","value":"application/json"},{"name":"Accept","value":"application/json"},{"name":"sw-include-seo-urls","value":"true"}]},"options":{"timeout":60000,"retry":{"enabled":true,"maxRetries":3,"retryInterval":2000}}},"id":"c3d4e5f6-7g8h-9i0j-1k2l-3m4n5o6p7q8r","name":"Fetch Products Page","type":"n8n-nodes-base.httpRequest","typeVersion":4.1,"position":[900,300]},{"parameters":{"jsCode":"// Process the API response with comprehensive error handling\nconst items = $input.all();\nconst response = items[0].json;\n\n// Validate API response structure\nif (!response || typeof response !== 'object') {\n  throw new Error('Invalid API response format');\n}\n\n// Extract products and pagination info with fallbacks\nconst products = response.data || [];\nconst total = response.total || 0;\nconst currentPage = response.page || 1;\nconst limit = response.limit || 50;\nconst totalPages = Math.ceil(total / limit);\n\n// Get existing data from previous iterations\nlet allProducts = $node[\"Validate Token & Initialize\"].json.allProducts || [];\nlet errors = $node[\"Validate Token & Initialize\"].json.errors || [];\n\n// Validate products data\nif (!Array.isArray(products)) {\n  const error = `Page ${currentPage}: Products data is not an array`;\n  errors.push(error);\n  console.warn('‚ö†Ô∏è ' + error);\n} else {\n  // Add current page products to the collection\n  allProducts = allProducts.concat(products);\n  console.log(`üì¶ Fetched page ${currentPage}/${totalPages} - ${products.length} products (Total: ${allProducts.length}/${total})`);\n}\n\n// Determine if we need to fetch more pages\nconst hasMorePages = currentPage < totalPages;\n\nif (hasMorePages) {\n  // Return data for next page\n  return [{\n    json: {\n      page: currentPage + 1,\n      limit: limit,\n      totalPages: totalPages,\n      accessToken: $node[\"Validate Token & Initialize\"].json.accessToken,\n      allProducts: allProducts,\n      hasMorePages: true,\n      currentTotal: allProducts.length,\n      expectedTotal: total,\n      startTime: $node[\"Validate Token & Initialize\"].json.startTime,\n      errors: errors\n    }\n  }];\n} else {\n  // All pages fetched, return final collection\n  const endTime = new Date().toISOString();\n  const duration = new Date(endTime) - new Date($node[\"Validate Token & Initialize\"].json.startTime);\n  \n  console.log(`üéâ Pagination complete! Fetched ${allProducts.length} products in ${Math.round(duration/1000)}s`);\n  \n  if (errors.length > 0) {\n    console.warn(`‚ö†Ô∏è ${errors.length} errors encountered during fetch:`);\n    errors.forEach(error => console.warn(`  - ${error}`));\n  }\n  \n  return [{\n    json: {\n      allProducts: allProducts,\n      hasMorePages: false,\n      totalProducts: allProducts.length,\n      paginationComplete: true,\n      startTime: $node[\"Validate Token & Initialize\"].json.startTime,\n      endTime: endTime,\n      duration: Math.round(duration/1000),\n      errors: errors\n    }\n  }];\n}"},"id":"d4e5f6g7-8h9i-0j1k-2l3m-4n5o6p7q8r9s","name":"Process Page & Check Pagination","type":"n8n-nodes-base.code","typeVersion":2,"position":[1120,300]},{"parameters":{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict"},"conditions":[{"id":"c1a2b3c4-d5e6-f7g8-h9i0-j1k2l3m4n5o6","leftValue":"={{ $json.hasMorePages }}","rightValue":true,"operator":{"type":"boolean","operation":"true"}}],"combinator":"and"},"options":{}},"id":"e5f6g7h8-9i0j-1k2l-3m4n-5o6p7q8r9s0t","name":"Has More Pages?","type":"n8n-nodes-base.if","typeVersion":2,"position":[1340,300]},{"parameters":{"jsCode":"// Transform products for vector storage with enhanced error handling\nconst items = $input.all();\nconst allProducts = items[0].json.allProducts;\nconst previousErrors = items[0].json.errors || [];\n\nif (!Array.isArray(allProducts)) {\n  throw new Error('Products data is not an array');\n}\n\nconsole.log(`üîÑ Starting transformation of ${allProducts.length} products...`);\n\nconst transformedProducts = [];\nconst transformErrors = [];\n\nallProducts.forEach((product, index) => {\n  try {\n    // Validate required fields\n    if (!product || typeof product !== 'object') {\n      transformErrors.push(`Product ${index}: Invalid product object`);\n      return;\n    }\n\n    if (!product.id) {\n      transformErrors.push(`Product ${index}: Missing product ID`);\n      return;\n    }\n\n    // Safely extract and combine text fields\n    const textParts = [];\n    \n    // Add name\n    if (product.name && typeof product.name === 'string') {\n      textParts.push(product.name.trim());\n    }\n    \n    // Add description\n    if (product.description && typeof product.description === 'string') {\n      textParts.push(product.description.trim());\n    }\n    \n    // Add meta description\n    if (product.metaDescription && typeof product.metaDescription === 'string') {\n      textParts.push(product.metaDescription.trim());\n    }\n    \n    // Add properties\n    if (Array.isArray(product.properties)) {\n      const propertyTexts = product.properties\n        .filter(prop => prop && prop.name && prop.value)\n        .map(prop => `${prop.name}: ${prop.value}`);\n      if (propertyTexts.length > 0) {\n        textParts.push(propertyTexts.join(', '));\n      }\n    }\n    \n    // Add categories\n    if (Array.isArray(product.categories)) {\n      const categoryNames = product.categories\n        .filter(cat => cat && cat.name)\n        .map(cat => cat.name);\n      if (categoryNames.length > 0) {\n        textParts.push(categoryNames.join(', '));\n      }\n    }\n    \n    // Add manufacturer number\n    if (product.manufacturerNumber && typeof product.manufacturerNumber === 'string') {\n      textParts.push(product.manufacturerNumber.trim());\n    }\n    \n    // Add EAN\n    if (product.ean && typeof product.ean === 'string') {\n      textParts.push(product.ean.trim());\n    }\n\n    // Combine all text parts\n    const textContent = textParts.filter(part => part.length > 0).join(' | ');\n    \n    // Skip products with no meaningful content\n    if (textContent.trim().length === 0) {\n      transformErrors.push(`Product ${product.id}: No meaningful text content`);\n      return;\n    }\n\n    // Safely extract price information\n    let price = 0;\n    let currency = 'EUR';\n    if (Array.isArray(product.price) && product.price.length > 0) {\n      const priceObj = product.price[0];\n      if (priceObj && typeof priceObj.gross === 'number') {\n        price = priceObj.gross;\n      }\n      if (priceObj && priceObj.currencyId) {\n        currency = priceObj.currencyId;\n      }\n    }\n\n    // Prepare metadata with safe defaults\n    const metadata = {\n      id: product.id,\n      name: product.name || '',\n      price: price,\n      currency: currency,\n      stock: typeof product.stock === 'number' ? product.stock : 0,\n      active: Boolean(product.active),\n      manufacturerNumber: product.manufacturerNumber || '',\n      ean: product.ean || '',\n      categories: Array.isArray(product.categories) \n        ? product.categories.filter(cat => cat && cat.name).map(cat => cat.name)\n        : [],\n      properties: Array.isArray(product.properties) ? product.properties : [],\n      url: (Array.isArray(product.seoUrls) && product.seoUrls.length > 0) \n        ? product.seoUrls[0].seoPathInfo || ''\n        : '',\n      createdAt: product.createdAt || null,\n      updatedAt: product.updatedAt || null\n    };\n\n    transformedProducts.push({\n      pageContent: textContent,\n      metadata: metadata\n    });\n\n  } catch (error) {\n    transformErrors.push(`Product ${product.id || index}: ${error.message}`);\n  }\n});\n\nconsole.log(`‚úÖ Transformed ${transformedProducts.length} products successfully`);\nif (transformErrors.length > 0) {\n  console.warn(`‚ö†Ô∏è ${transformErrors.length} transformation errors:`);\n  transformErrors.slice(0, 10).forEach(error => console.warn(`  - ${error}`));\n  if (transformErrors.length > 10) {\n    console.warn(`  ... and ${transformErrors.length - 10} more errors`);\n  }\n}\n\n// Return transformed products with error tracking\nconst result = transformedProducts.map(product => ({ \n  json: {\n    ...product,\n    _metadata: {\n      totalErrors: previousErrors.length + transformErrors.length,\n      transformErrors: transformErrors.length\n    }\n  }\n}));\n\nif (result.length === 0) {\n  throw new Error('No products could be transformed successfully');\n}\n\nreturn result;"},"id":"f6g7h8i9-0j1k-2l3m-4n5o-6p7q8r9s0t1u","name":"Transform Products for Vector Storage","type":"n8n-nodes-base.code","typeVersion":2,"position":[1560,420]},{"parameters":{"model":"text-embedding-3-small","options":{"batchSize":100,"stripNewLines":true,"maxRetries":3}},"id":"g7h8i9j0-1k2l-3m4n-5o6p-7q8r9s0t1u2v","name":"Generate Embeddings","type":"@n8n/n8n-nodes-langchain.embeddingsOpenAi","typeVersion":1,"position":[1780,420]},{"parameters":{"mode":"insert","qdrantCollection":{"__rl":true,"value":"shopware_products","mode":"name"},"options":{"batchSize":50}},"id":"h8i9j0k1-2l3m-4n5o-6p7q-8r9s0t1u2v3w","name":"Insert into Qdrant","type":"@n8n/n8n-nodes-langchain.vectorStoreQdrant","typeVersion":1,"position":[2000,420]},{"parameters":{"jsCode":"// Comprehensive completion logging with error summary\nconst items = $input.all();\nconst totalProcessed = items.length;\n\n// Extract error information from the first item's metadata\nconst firstItem = items[0];\nconst errorInfo = firstItem?.json?._metadata || {};\n\nconst completionTime = new Date().toISOString();\n\n// Calculate processing statistics\nconst stats = {\n  totalProductsProcessed: totalProcessed,\n  totalErrors: errorInfo.totalErrors || 0,\n  transformErrors: errorInfo.transformErrors || 0,\n  successRate: totalProcessed > 0 ? ((totalProcessed / (totalProcessed + (errorInfo.totalErrors || 0))) * 100).toFixed(2) : 0\n};\n\n// Log comprehensive completion status\nconsole.log('üéâ ===== IMPORT COMPLETED =====');\nconsole.log(`üìä Products successfully processed: ${stats.totalProductsProcessed}`);\nconsole.log(`‚ö†Ô∏è Total errors encountered: ${stats.totalErrors}`);\nconsole.log(`üìà Success rate: ${stats.successRate}%`);\nconsole.log(`‚è∞ Completion time: ${completionTime}`);\nconsole.log('================================');\n\nif (stats.totalErrors > 0) {\n  console.warn('‚ö†Ô∏è Some products could not be processed. Check the logs above for details.');\n}\n\nif (totalProcessed === 0) {\n  throw new Error('No products were successfully processed!');\n}\n\nreturn [{\n  json: {\n    status: 'completed',\n    statistics: stats,\n    message: `Successfully imported ${totalProcessed} products into Qdrant`,\n    timestamp: completionTime,\n    recommendations: stats.totalErrors > 0 \n      ? ['Review error logs', 'Consider re-running for failed products', 'Check data quality in source system']\n      : ['Import completed successfully', 'Ready for chatbot integration', 'Consider setting up monitoring']\n  }\n}];"},"id":"i9j0k1l2-3m4n-5o6p-7q8r-9s0t1u2v3w4x","name":"Log Completion & Statistics","type":"n8n-nodes-base.code","typeVersion":2,"position":[2220,420]},{"parameters":{"jsCode":"// Error handler for OAuth failures\nconst error = $input.first().error;\n\nconsole.error('‚ùå OAuth Authentication Failed!');\nconsole.error(`Error: ${error.message}`);\nconsole.error('Please check:');\nconsole.error('- Shopware API credentials are correct');\nconsole.error('- Integration has proper permissions');\nconsole.error('- Shopware instance is accessible');\n\nreturn [{\n  json: {\n    status: 'failed',\n    stage: 'authentication',\n    error: error.message,\n    timestamp: new Date().toISOString(),\n    troubleshooting: [\n      'Verify client_id and client_secret',\n      'Check Shopware integration permissions',\n      'Ensure API endpoint is accessible',\n      'Review Shopware logs for authentication errors'\n    ]\n  }\n}];"},"id":"j0k1l2m3-4n5o-6p7q-8r9s-0t1u2v3w4x5y","name":"Handle OAuth Error","type":"n8n-nodes-base.code","typeVersion":2,"position":[460,480]},{"parameters":{"jsCode":"// Error handler for API fetch failures\nconst error = $input.first().error;\nconst currentPage = $node[\"Process Page & Check Pagination\"]?.json?.page || 'unknown';\n\nconsole.error(`‚ùå API Fetch Failed on page ${currentPage}!`);\nconsole.error(`Error: ${error.message}`);\nconsole.error('This could be due to:');\nconsole.error('- Network connectivity issues');\nconsole.error('- API rate limiting');\nconsole.error('- Invalid API response format');\nconsole.error('- Server-side errors');\n\nreturn [{\n  json: {\n    status: 'failed',\n    stage: 'data_fetch',\n    page: currentPage,\n    error: error.message,\n    timestamp: new Date().toISOString(),\n    troubleshooting: [\n      'Check network connectivity',\n      'Verify API endpoint availability',\n      'Review rate limiting settings',\n      'Check Shopware server logs',\n      'Try reducing batch size'\n    ]\n  }\n}];"},"id":"k1l2m3n4-5o6p-7q8r-9s0t-1u2v3w4x5y6z","name":"Handle API Error","type":"n8n-nodes-base.code","typeVersion":2,"position":[1120,480]},{"parameters":{"jsCode":"// Error handler for vector storage failures\nconst error = $input.first().error;\n\nconsole.error('‚ùå Vector Storage Failed!');\nconsole.error(`Error: ${error.message}`);\nconsole.error('This could be due to:');\nconsole.error('- Qdrant connection issues');\nconsole.error('- Invalid collection configuration');\nconsole.error('- Embedding generation failures');\nconsole.error('- Insufficient Qdrant storage space');\n\nreturn [{\n  json: {\n    status: 'failed',\n    stage: 'vector_storage',\n    error: error.message,\n    timestamp: new Date().toISOString(),\n    troubleshooting: [\n      'Verify Qdrant connection credentials',\n      'Check collection exists and is accessible',\n      'Ensure OpenAI API key is valid',\n      'Review Qdrant cluster status',\n      'Check available storage space',\n      'Verify embedding dimensions match collection config'\n    ]\n  }\n}];"},"id":"l2m3n4o5-6p7q-8r9s-0t1u-2v3w4x5y6z7a","name":"Handle Vector Storage Error","type":"n8n-nodes-base.code","typeVersion":2,"position":[2000,580]}],"connections":{"Manual Trigger":{"main":[[{"node":"Get OAuth Token","type":"main","index":0}]]},"Get OAuth Token":{"main":[[{"node":"Validate Token & Initialize","type":"main","index":0}]],"error":[[{"node":"Handle OAuth Error","type":"main","index":0}]]},"Validate Token & Initialize":{"main":[[{"node":"Fetch Products Page","type":"main","index":0}]]},"Fetch Products Page":{"main":[[{"node":"Process Page & Check Pagination","type":"main","index":0}]],"error":[[{"node":"Handle API Error","type":"main","index":0}]]},"Process Page & Check Pagination":{"main":[[{"node":"Has More Pages?","type":"main","index":0}]]},"Has More Pages?":{"main":[[{"node":"Fetch Products Page","type":"main","index":0}],[{"node":"Transform Products for Vector Storage","type":"main","index":0}]]},"Transform Products for Vector Storage":{"main":[[{"node":"Generate Embeddings","type":"main","index":0}]]},"Generate Embeddings":{"main":[[{"node":"Insert into Qdrant","type":"main","index":0}]],"error":[[{"node":"Handle Vector Storage Error","type":"main","index":0}]]},"Insert into Qdrant":{"main":[[{"node":"Log Completion & Statistics","type":"main","index":0}]],"error":[[{"node":"Handle Vector Storage Error","type":"main","index":0}]]}},"settings":{"executionOrder":"v1","saveManualExecutions":true,"callerPolicy":"workflowsFromSameOwner","errorWorkflow":{"enabled":false}},"staticData":null,"meta":null,"pinData":{},"versionId":"2","triggerCount":1,"tags":[{"createdAt":"2024-01-01T00:00:00.000Z","updatedAt":"2024-01-01T00:00:00.000Z","id":"tag1","name":"shopware"},{"createdAt":"2024-01-01T00:00:00.000Z","updatedAt":"2024-01-01T00:00:00.000Z","id":"tag2","name":"qdrant"},{"createdAt":"2024-01-01T00:00:00.000Z","updatedAt":"2024-01-01T00:00:00.000Z","id":"tag3","name":"vector-database"},{"createdAt":"2024-01-01T00:00:00.000Z","updatedAt":"2024-01-01T00:00:00.000Z","id":"tag4","name":"enhanced"}]},{"createdAt":"2025-07-26T06:39:14.692Z","updatedAt":"2024-01-01T00:00:00.000Z","id":"zWbjNKpe1o6yWRSj","name":"Shopware to Qdrant Product Import (Fixed)","active":false,"isArchived":false,"nodes":[{"parameters":{},"id":"f8b0c5e1-8a2d-4c3e-9f1a-2b3c4d5e6f7g","name":"Manual Trigger","type":"n8n-nodes-base.manualTrigger","typeVersion":1,"position":[240,300]},{"parameters":{"method":"POST","url":"https://shop.held.de/api/oauth/token","sendHeaders":true,"headerParameters":{"parameters":[{"name":"Content-Type","value":"application/json"}]},"sendBody":true,"bodyParameters":{"parameters":[{"name":"grant_type","value":"client_credentials"},{"name":"client_id","value":"SWIANEPSMGTHMLJMT1BHEFAZNW"},{"name":"client_secret","value":"UVJKRGFWZENoVW9OY1ZuUktYNkN6NFRucVNVQU1VR1B0cElhUzE"}]},"options":{"timeout":30000,"retry":{"enabled":true,"maxRetries":3,"retryInterval":1000}}},"id":"a1b2c3d4-5e6f-7g8h-9i0j-1k2l3m4n5o6p","name":"Get OAuth Token","type":"n8n-nodes-base.httpRequest","typeVersion":4.1,"position":[460,300]},{"parameters":{"jsCode":"// Validate OAuth response and initialize pagination\nconst items = $input.all();\nconst response = items[0].json;\n\n// Check if we got a valid access token\nif (!response.access_token) {\n  throw new Error('Failed to obtain access token from Shopware API');\n}\n\nconsole.log('‚úÖ Successfully obtained OAuth token');\nconsole.log(`Token type: ${response.token_type}`);\nconsole.log(`Expires in: ${response.expires_in} seconds`);\n\n// Set initial pagination parameters\nconst paginationData = {\n  page: 1,\n  limit: 10, // Reduced for testing\n  totalPages: null,\n  accessToken: response.access_token,\n  allProducts: [],\n  startTime: new Date().toISOString(),\n  errors: []\n};\n\nreturn [{\n  json: paginationData\n}];"},"id":"b2c3d4e5-6f7g-8h9i-0j1k-2l3m4n5o6p7q","name":"Validate Token & Initialize","type":"n8n-nodes-base.code","typeVersion":2,"position":[680,300]},{"parameters":{"url":"=https://shop.held.de/api/product?page={{ $json.page }}&limit={{ $json.limit }}","sendHeaders":true,"headerParameters":{"parameters":[{"name":"Authorization","value":"=Bearer {{ $json.accessToken }}"},{"name":"Content-Type","value":"application/json"},{"name":"Accept","value":"application/json"}]},"options":{"timeout":60000,"retry":{"enabled":true,"maxRetries":3,"retryInterval":2000}}},"id":"c3d4e5f6-7g8h-9i0j-1k2l-3m4n5o6p7q8r","name":"Fetch Products Page","type":"n8n-nodes-base.httpRequest","typeVersion":4.1,"position":[900,300]},{"parameters":{"jsCode":"// Process the API response with comprehensive error handling\nconst items = $input.all();\nconst response = items[0].json;\n\n// Validate API response structure\nif (!response || typeof response !== 'object') {\n  throw new Error('Invalid API response format');\n}\n\n// Extract products and pagination info with fallbacks\nconst products = response.data || [];\nconst total = response.total || 0;\nconst currentPage = response.page || 1;\nconst limit = response.limit || 10;\nconst totalPages = Math.ceil(total / limit);\n\n// Get existing data from previous iterations\nlet allProducts = $node[\"Validate Token & Initialize\"].json.allProducts || [];\nlet errors = $node[\"Validate Token & Initialize\"].json.errors || [];\n\n// Validate products data\nif (!Array.isArray(products)) {\n  const error = `Page ${currentPage}: Products data is not an array`;\n  errors.push(error);\n  console.warn('‚ö†Ô∏è ' + error);\n} else {\n  // Add current page products to the collection\n  allProducts = allProducts.concat(products);\n  console.log(`üì¶ Fetched page ${currentPage}/${totalPages} - ${products.length} products (Total: ${allProducts.length}/${total})`);\n}\n\n// Determine if we need to fetch more pages (limit to 2 pages for testing)\nconst hasMorePages = currentPage < Math.min(totalPages, 2);\n\nif (hasMorePages) {\n  // Return data for next page\n  return [{\n    json: {\n      page: currentPage + 1,\n      limit: limit,\n      totalPages: totalPages,\n      accessToken: $node[\"Validate Token & Initialize\"].json.accessToken,\n      allProducts: allProducts,\n      hasMorePages: true,\n      currentTotal: allProducts.length,\n      expectedTotal: total,\n      startTime: $node[\"Validate Token & Initialize\"].json.startTime,\n      errors: errors\n    }\n  }];\n} else {\n  // All pages fetched, return final collection\n  const endTime = new Date().toISOString();\n  const duration = new Date(endTime) - new Date($node[\"Validate Token & Initialize\"].json.startTime);\n  \n  console.log(`üéâ Pagination complete! Fetched ${allProducts.length} products in ${Math.round(duration/1000)}s`);\n  \n  if (errors.length > 0) {\n    console.warn(`‚ö†Ô∏è ${errors.length} errors encountered during fetch:`);\n    errors.forEach(error => console.warn(`  - ${error}`));\n  }\n  \n  return [{\n    json: {\n      allProducts: allProducts,\n      hasMorePages: false,\n      totalProducts: allProducts.length,\n      paginationComplete: true,\n      startTime: $node[\"Validate Token & Initialize\"].json.startTime,\n      endTime: endTime,\n      duration: Math.round(duration/1000),\n      errors: errors\n    }\n  }];\n}"},"id":"d4e5f6g7-8h9i-0j1k-2l3m-4n5o6p7q8r9s","name":"Process Page & Check Pagination","type":"n8n-nodes-base.code","typeVersion":2,"position":[1120,300]},{"parameters":{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict"},"conditions":[{"id":"c1a2b3c4-d5e6-f7g8-h9i0-j1k2l3m4n5o6","leftValue":"={{ $json.hasMorePages }}","rightValue":true,"operator":{"type":"boolean","operation":"equal","rightType":"boolean"}}],"combinator":"and"},"options":{}},"id":"e5f6g7h8-9i0j-1k2l-3m4n-5o6p7q8r9s0t","name":"Has More Pages?","type":"n8n-nodes-base.if","typeVersion":2,"position":[1340,300]},{"parameters":{"jsCode":"// Transform products for vector storage with enhanced error handling\nconst items = $input.all();\nconst allProducts = items[0].json.allProducts;\nconst previousErrors = items[0].json.errors || [];\n\nif (!Array.isArray(allProducts)) {\n  throw new Error('Products data is not an array');\n}\n\nconsole.log(`üîÑ Starting transformation of ${allProducts.length} products...`);\n\nconst transformedProducts = [];\nconst transformErrors = [];\n\nallProducts.forEach((product, index) => {\n  try {\n    // Validate required fields\n    if (!product || typeof product !== 'object') {\n      transformErrors.push(`Product ${index}: Invalid product object`);\n      return;\n    }\n\n    if (!product.id) {\n      transformErrors.push(`Product ${index}: Missing product ID`);\n      return;\n    }\n\n    // Safely extract and combine text fields\n    const textParts = [];\n    \n    // Extract name from translations or direct field\n    let productName = product.name;\n    if (!productName && product.translations && Array.isArray(product.translations)) {\n      const translation = product.translations.find(t => t.name);\n      productName = translation?.name;\n    }\n    if (productName && typeof productName === 'string') {\n      textParts.push(productName.trim());\n    }\n    \n    // Extract description from translations or direct field\n    let productDescription = product.description;\n    if (!productDescription && product.translations && Array.isArray(product.translations)) {\n      const translation = product.translations.find(t => t.description);\n      productDescription = translation?.description;\n    }\n    if (productDescription && typeof productDescription === 'string') {\n      // Strip HTML tags from description\n      const cleanDescription = productDescription.replace(/<[^>]*>/g, ' ').replace(/\\s+/g, ' ').trim();\n      if (cleanDescription.length > 0) {\n        textParts.push(cleanDescription);\n      }\n    }\n    \n    // Add EAN if available\n    if (product.ean && typeof product.ean === 'string') {\n      textParts.push(`EAN: ${product.ean.trim()}`);\n    }\n    \n    // Add manufacturer number if available\n    if (product.manufacturerNumber && typeof product.manufacturerNumber === 'string') {\n      textParts.push(`MFG: ${product.manufacturerNumber.trim()}`);\n    }\n\n    // Combine all text parts\n    const textContent = textParts.filter(part => part.length > 0).join(' | ');\n    \n    // For products with minimal content, create basic description\n    let finalTextContent = textContent;\n    if (finalTextContent.trim().length === 0) {\n      finalTextContent = `Product ID: ${product.id}`;\n      if (product.ean) finalTextContent += ` | EAN: ${product.ean}`;\n      if (product.active) finalTextContent += ' | Active Product';\n    }\n\n    // Safely extract price information\n    let price = 0;\n    let currency = 'EUR';\n    if (Array.isArray(product.price) && product.price.length > 0) {\n      const priceObj = product.price[0];\n      if (priceObj && typeof priceObj.gross === 'number') {\n        price = priceObj.gross;\n      }\n      if (priceObj && priceObj.currencyId) {\n        currency = priceObj.currencyId;\n      }\n    }\n\n    // Prepare metadata with safe defaults\n    const metadata = {\n      id: product.id,\n      name: productName || '',\n      price: price,\n      currency: currency,\n      stock: typeof product.stock === 'number' ? product.stock : 0,\n      active: Boolean(product.active),\n      manufacturerNumber: product.manufacturerNumber || '',\n      ean: product.ean || '',\n      createdAt: product.createdAt || null,\n      updatedAt: product.updatedAt || null\n    };\n\n    transformedProducts.push({\n      pageContent: finalTextContent,\n      metadata: metadata\n    });\n\n  } catch (error) {\n    transformErrors.push(`Product ${product.id || index}: ${error.message}`);\n  }\n});\n\nconsole.log(`‚úÖ Transformed ${transformedProducts.length} products successfully`);\nif (transformErrors.length > 0) {\n  console.warn(`‚ö†Ô∏è ${transformErrors.length} transformation errors:`);\n  transformErrors.slice(0, 5).forEach(error => console.warn(`  - ${error}`));\n}\n\n// Return transformed products with error tracking\nconst result = transformedProducts.map(product => ({ \n  json: {\n    ...product,\n    _metadata: {\n      totalErrors: previousErrors.length + transformErrors.length,\n      transformErrors: transformErrors.length\n    }\n  }\n}));\n\nif (result.length === 0) {\n  throw new Error('No products could be transformed successfully');\n}\n\nreturn result;"},"id":"f6g7h8i9-0j1k-2l3m-4n5o-6p7q8r9s0t1u","name":"Transform Products for Vector Storage","type":"n8n-nodes-base.code","typeVersion":2,"position":[1560,420]},{"parameters":{"operation":"insert","collection":"shopware_products","options":{"batchSize":100}},"id":"g7h8i9j0-1k2l-3m4n-5o6p-7q8r9s0t1u2v","name":"Store in Qdrant Vector DB","type":"n8n-nodes-base.qdrant","typeVersion":1,"position":[1780,420],"credentials":{"qdrantApi":{"id":"qdrant-shopware-creds","name":"Qdrant Shopware Integration"}}},{"parameters":{"jsCode":"// Enhanced completion logging with Qdrant storage results\nconst items = $input.all();\nconst totalProcessed = items.length;\nconst successfulInserts = items.filter(item => item.json && item.json.status === 'ok').length;\nconst failedInserts = totalProcessed - successfulInserts;\n\nconst completionTime = new Date().toISOString();\n\n// Log completion status\nconsole.log('üéâ ===== IMPORT COMPLETED =====');\nconsole.log(`üìä Products processed: ${totalProcessed}`);\nconsole.log(`‚úÖ Successfully stored in Qdrant: ${successfulInserts}`);\nif (failedInserts > 0) {\n  console.log(`‚ùå Failed to store: ${failedInserts}`);\n}\nconsole.log(`‚è∞ Completion time: ${completionTime}`);\nconsole.log('================================');\n\n// Check for any errors in the Qdrant responses\nconst errors = [];\nitems.forEach((item, index) => {\n  if (item.json && item.json.status !== 'ok') {\n    errors.push(`Item ${index}: ${item.json.message || 'Unknown error'}`);\n  }\n});\n\nif (errors.length > 0) {\n  console.warn('‚ö†Ô∏è Qdrant storage errors:');\n  errors.slice(0, 5).forEach(error => console.warn(`  - ${error}`));\n}\n\nreturn [{\n  json: {\n    status: 'completed',\n    totalProcessed: totalProcessed,\n    successfulInserts: successfulInserts,\n    failedInserts: failedInserts,\n    errorRate: totalProcessed > 0 ? (failedInserts / totalProcessed * 100).toFixed(2) + '%' : '0%',\n    message: `Successfully processed ${totalProcessed} products, ${successfulInserts} stored in Qdrant`,\n    timestamp: completionTime,\n    errors: errors.slice(0, 10) // Keep first 10 errors for debugging\n  }\n}];"},"id":"i9j0k1l2-3m4n-5o6p-7q8r-9s0t1u2v3w4x","name":"Log Completion & Statistics","type":"n8n-nodes-base.code","typeVersion":2,"position":[2000,420]}],"connections":{"Manual Trigger":{"main":[[{"node":"Get OAuth Token","type":"main","index":0}]]},"Get OAuth Token":{"main":[[{"node":"Validate Token & Initialize","type":"main","index":0}]]},"Validate Token & Initialize":{"main":[[{"node":"Fetch Products Page","type":"main","index":0}]]},"Fetch Products Page":{"main":[[{"node":"Process Page & Check Pagination","type":"main","index":0}]]},"Process Page & Check Pagination":{"main":[[{"node":"Has More Pages?","type":"main","index":0}]]},"Has More Pages?":{"main":[[{"node":"Fetch Products Page","type":"main","index":0}],[{"node":"Transform Products for Vector Storage","type":"main","index":0}]]},"Transform Products for Vector Storage":{"main":[[{"node":"Store in Qdrant Vector DB","type":"main","index":0}]]},"Store in Qdrant Vector DB":{"main":[[{"node":"Log Completion & Statistics","type":"main","index":0}]]}},"settings":{"executionOrder":"v1","saveManualExecutions":true,"callerPolicy":"workflowsFromSameOwner"},"staticData":null,"meta":null,"pinData":{},"versionId":"3","triggerCount":1,"tags":[{"createdAt":"2024-01-01T00:00:00.000Z","updatedAt":"2024-01-01T00:00:00.000Z","id":"tag1","name":"shopware"},{"createdAt":"2024-01-01T00:00:00.000Z","updatedAt":"2024-01-01T00:00:00.000Z","id":"tag2","name":"qdrant"},{"createdAt":"2024-01-01T00:00:00.000Z","updatedAt":"2024-01-01T00:00:00.000Z","id":"tag3","name":"vector-database"}]}]