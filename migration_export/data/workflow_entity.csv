id,name,active,nodes,connections,settings,staticData,pinData,versionId,triggerCount,meta,parentFolderId,createdAt,updatedAt,isArchived
WfrjB80qiV7HKM8s,Shopware to Qdrant Product Import (Complete),0,"[{""parameters"":{},""id"":""f8b0c5e1-8a2d-4c3e-9f1a-2b3c4d5e6f7g"",""name"":""Manual Trigger"",""type"":""n8n-nodes-base.manualTrigger"",""typeVersion"":1,""position"":[240,300]},{""parameters"":{""method"":""POST"",""url"":""https://shop.held.de/api/oauth/token"",""sendHeaders"":true,""headerParameters"":{""parameters"":[{""name"":""Content-Type"",""value"":""application/json""}]},""sendBody"":true,""bodyParameters"":{""parameters"":[{""name"":""grant_type"",""value"":""client_credentials""},{""name"":""client_id"",""value"":""SWIANEPSMGTHMLJMT1BHEFAZNW""},{""name"":""client_secret"",""value"":""UVJKRGFWZENoVW9OY1ZuUktYNkN6NFRucVNVQU1VR1B0cElhUzE""}]},""options"":{""timeout"":30000,""retry"":{""enabled"":true,""maxRetries"":3,""retryInterval"":1000}}},""id"":""a1b2c3d4-5e6f-7g8h-9i0j-1k2l3m4n5o6p"",""name"":""Get OAuth Token"",""type"":""n8n-nodes-base.httpRequest"",""typeVersion"":4.1,""position"":[460,300]},{""parameters"":{""jsCode"":""// Validate OAuth response and initialize pagination\nconst items = $input.all();\nconst response = items[0].json;\n\n// Check if we got a valid access token\nif (!response.access_token) {\n  throw new Error('Failed to obtain access token from Shopware API');\n}\n\nconsole.log('‚úÖ Successfully obtained OAuth token');\nconsole.log(`Token type: ${response.token_type}`);\nconsole.log(`Expires in: ${response.expires_in} seconds`);\n\n// Set initial pagination parameters\nconst paginationData = {\n  page: 1,\n  limit: 10, // Reduced for testing\n  totalPages: null,\n  accessToken: response.access_token,\n  allProducts: [],\n  startTime: new Date().toISOString(),\n  errors: []\n};\n\nreturn [{\n  json: paginationData\n}];""},""id"":""b2c3d4e5-6f7g-8h9i-0j1k-2l3m4n5o6p7q"",""name"":""Validate Token & Initialize"",""type"":""n8n-nodes-base.code"",""typeVersion"":2,""position"":[680,300]},{""parameters"":{""url"":""=https://shop.held.de/api/product?page={{ $json.page }}&limit={{ $json.limit }}"",""sendHeaders"":true,""headerParameters"":{""parameters"":[{""name"":""Authorization"",""value"":""=Bearer {{ $json.accessToken }}""},{""name"":""Content-Type"",""value"":""application/json""},{""name"":""Accept"",""value"":""application/json""}]},""options"":{""timeout"":60000,""retry"":{""enabled"":true,""maxRetries"":3,""retryInterval"":2000}}},""id"":""c3d4e5f6-7g8h-9i0j-1k2l-3m4n5o6p7q8r"",""name"":""Fetch Products Page"",""type"":""n8n-nodes-base.httpRequest"",""typeVersion"":4.1,""position"":[900,300]},{""parameters"":{""jsCode"":""// Process the API response with comprehensive error handling\nconst items = $input.all();\nconst response = items[0].json;\n\n// Validate API response structure\nif (!response || typeof response !== 'object') {\n  throw new Error('Invalid API response format');\n}\n\n// Extract products and pagination info with fallbacks\nconst products = response.data || [];\nconst total = response.total || 0;\nconst currentPage = response.page || 1;\nconst limit = response.limit || 10;\nconst totalPages = Math.ceil(total / limit);\n\n// Get existing data from previous iterations\nlet allProducts = $node[\""Validate Token & Initialize\""].json.allProducts || [];\nlet errors = $node[\""Validate Token & Initialize\""].json.errors || [];\n\n// Validate products data\nif (!Array.isArray(products)) {\n  const error = `Page ${currentPage}: Products data is not an array`;\n  errors.push(error);\n  console.warn('‚ö†Ô∏è ' + error);\n} else {\n  // Add current page products to the collection\n  allProducts = allProducts.concat(products);\n  console.log(`üì¶ Fetched page ${currentPage}/${totalPages} - ${products.length} products (Total: ${allProducts.length}/${total})`);\n}\n\n// Determine if we need to fetch more pages (limit to 2 pages for testing)\nconst hasMorePages = currentPage < Math.min(totalPages, 2);\n\nif (hasMorePages) {\n  // Return data for next page\n  return [{\n    json: {\n      page: currentPage + 1,\n      limit: limit,\n      totalPages: totalPages,\n      accessToken: $node[\""Validate Token & Initialize\""].json.accessToken,\n      allProducts: allProducts,\n      hasMorePages: true,\n      currentTotal: allProducts.length,\n      expectedTotal: total,\n      startTime: $node[\""Validate Token & Initialize\""].json.startTime,\n      errors: errors\n    }\n  }];\n} else {\n  // All pages fetched, return final collection\n  const endTime = new Date().toISOString();\n  const duration = new Date(endTime) - new Date($node[\""Validate Token & Initialize\""].json.startTime);\n  \n  console.log(`üéâ Pagination complete! Fetched ${allProducts.length} products in ${Math.round(duration/1000)}s`);\n  \n  if (errors.length > 0) {\n    console.warn(`‚ö†Ô∏è ${errors.length} errors encountered during fetch:`);\n    errors.forEach(error => console.warn(`  - ${error}`));\n  }\n  \n  return [{\n    json: {\n      allProducts: allProducts,\n      hasMorePages: false,\n      totalProducts: allProducts.length,\n      paginationComplete: true,\n      startTime: $node[\""Validate Token & Initialize\""].json.startTime,\n      endTime: endTime,\n      duration: Math.round(duration/1000),\n      errors: errors\n    }\n  }];\n}""},""id"":""d4e5f6g7-8h9i-0j1k-2l3m-4n5o6p7q8r9s"",""name"":""Process Page & Check Pagination"",""type"":""n8n-nodes-base.code"",""typeVersion"":2,""position"":[1120,300]},{""parameters"":{""conditions"":{""options"":{""caseSensitive"":true,""leftValue"":"""",""typeValidation"":""strict""},""conditions"":[{""id"":""c1a2b3c4-d5e6-f7g8-h9i0-j1k2l3m4n5o6"",""leftValue"":""={{ $json.hasMorePages }}"",""rightValue"":true,""operator"":{""type"":""boolean"",""operation"":""equal"",""rightType"":""boolean""}}],""combinator"":""and""},""options"":{}},""id"":""e5f6g7h8-9i0j-1k2l-3m4n-5o6p7q8r9s0t"",""name"":""Has More Pages?"",""type"":""n8n-nodes-base.if"",""typeVersion"":2,""position"":[1340,300]},{""parameters"":{""jsCode"":""// Transform products for vector storage with enhanced error handling\nconst items = $input.all();\nconst allProducts = items[0].json.allProducts;\nconst previousErrors = items[0].json.errors || [];\n\nif (!Array.isArray(allProducts)) {\n  throw new Error('Products data is not an array');\n}\n\nconsole.log(`üîÑ Starting transformation of ${allProducts.length} products...`);\n\nconst transformedProducts = [];\nconst transformErrors = [];\n\nallProducts.forEach((product, index) => {\n  try {\n    // Validate required fields\n    if (!product || typeof product !== 'object') {\n      transformErrors.push(`Product ${index}: Invalid product object`);\n      return;\n    }\n\n    if (!product.id) {\n      transformErrors.push(`Product ${index}: Missing product ID`);\n      return;\n    }\n\n    // Safely extract and combine text fields\n    const textParts = [];\n    \n    // Extract name from translations or direct field\n    let productName = product.name;\n    if (!productName && product.translations && Array.isArray(product.translations)) {\n      const translation = product.translations.find(t => t.name);\n      productName = translation?.name;\n    }\n    if (productName && typeof productName === 'string') {\n      textParts.push(productName.trim());\n    }\n    \n    // Extract description from translations or direct field\n    let productDescription = product.description;\n    if (!productDescription && product.translations && Array.isArray(product.translations)) {\n      const translation = product.translations.find(t => t.description);\n      productDescription = translation?.description;\n    }\n    if (productDescription && typeof productDescription === 'string') {\n      // Strip HTML tags from description\n      const cleanDescription = productDescription.replace(/<[^>]*>/g, ' ').replace(/\\s+/g, ' ').trim();\n      if (cleanDescription.length > 0) {\n        textParts.push(cleanDescription);\n      }\n    }\n    \n    // Add EAN if available\n    if (product.ean && typeof product.ean === 'string') {\n      textParts.push(`EAN: ${product.ean.trim()}`);\n    }\n    \n    // Add manufacturer number if available\n    if (product.manufacturerNumber && typeof product.manufacturerNumber === 'string') {\n      textParts.push(`MFG: ${product.manufacturerNumber.trim()}`);\n    }\n\n    // Combine all text parts\n    const textContent = textParts.filter(part => part.length > 0).join(' | ');\n    \n    // For products with minimal content, create basic description\n    let finalTextContent = textContent;\n    if (finalTextContent.trim().length === 0) {\n      finalTextContent = `Product ID: ${product.id}`;\n      if (product.ean) finalTextContent += ` | EAN: ${product.ean}`;\n      if (product.active) finalTextContent += ' | Active Product';\n    }\n\n    // Safely extract price information\n    let price = 0;\n    let currency = 'EUR';\n    if (Array.isArray(product.price) && product.price.length > 0) {\n      const priceObj = product.price[0];\n      if (priceObj && typeof priceObj.gross === 'number') {\n        price = priceObj.gross;\n      }\n      if (priceObj && priceObj.currencyId) {\n        currency = priceObj.currencyId;\n      }\n    }\n\n    // Prepare metadata with safe defaults\n    const metadata = {\n      id: product.id,\n      name: productName || '',\n      price: price,\n      currency: currency,\n      stock: typeof product.stock === 'number' ? product.stock : 0,\n      active: Boolean(product.active),\n      manufacturerNumber: product.manufacturerNumber || '',\n      ean: product.ean || '',\n      createdAt: product.createdAt || null,\n      updatedAt: product.updatedAt || null\n    };\n\n    transformedProducts.push({\n      pageContent: finalTextContent,\n      metadata: metadata\n    });\n\n  } catch (error) {\n    transformErrors.push(`Product ${product.id || index}: ${error.message}`);\n  }\n});\n\nconsole.log(`‚úÖ Transformed ${transformedProducts.length} products successfully`);\nif (transformErrors.length > 0) {\n  console.warn(`‚ö†Ô∏è ${transformErrors.length} transformation errors:`);\n  transformErrors.slice(0, 5).forEach(error => console.warn(`  - ${error}`));\n}\n\n// Return transformed products with error tracking\nconst result = transformedProducts.map(product => ({ \n  json: {\n    ...product,\n    _metadata: {\n      totalErrors: previousErrors.length + transformErrors.length,\n      transformErrors: transformErrors.length\n    }\n  }\n}));\n\nif (result.length === 0) {\n  throw new Error('No products could be transformed successfully');\n}\n\nreturn result;""},""id"":""f6g7h8i9-0j1k-2l3m-4n5o-6p7q8r9s0t1u"",""name"":""Transform Products for Vector Storage"",""type"":""n8n-nodes-base.code"",""typeVersion"":2,""position"":[1560,420]},{""parameters"":{""jsCode"":""// Store products in Qdrant using HTTP API\nconst items = $input.all();\n\nif (!Array.isArray(items) || items.length === 0) {\n  throw new Error('No products to store in Qdrant');\n}\n\nconsole.log(`üîÑ Preparing to store ${items.length} products in Qdrant...`);\n\n// Prepare points for Qdrant\nconst points = [];\nconst errors = [];\n\nitems.forEach((item, index) => {\n  try {\n    const product = item.json;\n    \n    if (!product || !product.pageContent || !product.metadata || !product.metadata.id) {\n      errors.push(`Item ${index}: Missing required fields`);\n      return;\n    }\n\n    // Create a simple vector (placeholder since we don't have embeddings yet)\n    // In a real implementation, you'd generate embeddings from pageContent\n    const vector = new Array(1536).fill(0).map(() => Math.random() * 0.1);\n    \n    const point = {\n      id: product.metadata.id,\n      vector: vector,\n      payload: {\n        content: product.pageContent,\n        name: product.metadata.name,\n        price: product.metadata.price,\n        currency: product.metadata.currency,\n        stock: product.metadata.stock,\n        active: product.metadata.active,\n        ean: product.metadata.ean,\n        manufacturerNumber: product.metadata.manufacturerNumber,\n        createdAt: product.metadata.createdAt,\n        updatedAt: product.metadata.updatedAt\n      }\n    };\n    \n    points.push(point);\n    \n  } catch (error) {\n    errors.push(`Item ${index}: ${error.message}`);\n  }\n});\n\nif (points.length === 0) {\n  throw new Error('No valid points could be prepared for Qdrant storage');\n}\n\nconsole.log(`‚úÖ Prepared ${points.length} points for Qdrant storage`);\nif (errors.length > 0) {\n  console.warn(`‚ö†Ô∏è ${errors.length} preparation errors:`);\n  errors.slice(0, 3).forEach(error => console.warn(`  - ${error}`));\n}\n\n// Return the points data for the HTTP request\nreturn [{\n  json: {\n    points: points,\n    totalPoints: points.length,\n    errors: errors\n  }\n}];""},""id"":""g7h8i9j0-1k2l-3m4n-5o6p-7q8r9s0t1u2v"",""name"":""Prepare Qdrant Points"",""type"":""n8n-nodes-base.code"",""typeVersion"":2,""position"":[1780,420]},{""parameters"":{""method"":""PUT"",""url"":""https://8ec957ec-27b4-4041-9714-f8dde751b007.europe-west3-0.gcp.cloud.qdrant.io:6333/collections/shopware_products/points"",""sendHeaders"":true,""headerParameters"":{""parameters"":[{""name"":""api-key"",""value"":""eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhY2Nlc3MiOiJtIn0.50x-a9c0zTX_dzWnKjq-xM7rJ0ym6_yZ-D_eN_Idft4""},{""name"":""Content-Type"",""value"":""application/json""}]},""sendBody"":true,""bodyParameters"":{""parameters"":[{""name"":""points"",""value"":""={{ $json.points }}""}]},""options"":{""timeout"":60000,""retry"":{""enabled"":true,""maxRetries"":2,""retryInterval"":3000}}},""id"":""h8i9j0k1-2l3m-4n5o-6p7q-8r9s0t1u2v3w"",""name"":""Store in Qdrant Vector DB"",""type"":""n8n-nodes-base.httpRequest"",""typeVersion"":4.1,""position"":[2000,420]},{""parameters"":{""jsCode"":""// Enhanced completion logging with Qdrant storage results\nconst items = $input.all();\nconst qdrantResponse = items[0].json;\n\n// Parse Qdrant response\nlet successfulInserts = 0;\nlet failedInserts = 0;\nlet totalProcessed = 0;\n\nif (qdrantResponse && qdrantResponse.status === 'ok') {\n  successfulInserts = qdrantResponse.result?.operation_id ? 1 : 0;\n  totalProcessed = 1;\n} else {\n  failedInserts = 1;\n  totalProcessed = 1;\n}\n\nconst completionTime = new Date().toISOString();\n\n// Log completion status\nconsole.log('üéâ ===== IMPORT COMPLETED =====');\nconsole.log(`üìä Batch operations processed: ${totalProcessed}`);\nconsole.log(`‚úÖ Successfully stored in Qdrant: ${successfulInserts}`);\nif (failedInserts > 0) {\n  console.log(`‚ùå Failed to store: ${failedInserts}`);\n  console.log(`Response: ${JSON.stringify(qdrantResponse, null, 2)}`);\n}\nconsole.log(`‚è∞ Completion time: ${completionTime}`);\nconsole.log('================================');\n\nreturn [{\n  json: {\n    status: 'completed',\n    totalProcessed: totalProcessed,\n    successfulInserts: successfulInserts,\n    failedInserts: failedInserts,\n    errorRate: totalProcessed > 0 ? (failedInserts / totalProcessed * 100).toFixed(2) + '%' : '0%',\n    message: `Successfully processed batch operation, ${successfulInserts} operations completed`,\n    timestamp: completionTime,\n    qdrantResponse: qdrantResponse\n  }\n}];""},""id"":""i9j0k1l2-3m4n-5o6p-7q8r-9s0t1u2v3w4x"",""name"":""Log Completion & Statistics"",""type"":""n8n-nodes-base.code"",""typeVersion"":2,""position"":[2220,420]}]","{""Manual Trigger"":{""main"":[[{""node"":""Get OAuth Token"",""type"":""main"",""index"":0}]]},""Get OAuth Token"":{""main"":[[{""node"":""Validate Token & Initialize"",""type"":""main"",""index"":0}]]},""Validate Token & Initialize"":{""main"":[[{""node"":""Fetch Products Page"",""type"":""main"",""index"":0}]]},""Fetch Products Page"":{""main"":[[{""node"":""Process Page & Check Pagination"",""type"":""main"",""index"":0}]]},""Process Page & Check Pagination"":{""main"":[[{""node"":""Has More Pages?"",""type"":""main"",""index"":0}]]},""Has More Pages?"":{""main"":[[{""node"":""Fetch Products Page"",""type"":""main"",""index"":0}],[{""node"":""Transform Products for Vector Storage"",""type"":""main"",""index"":0}]]},""Transform Products for Vector Storage"":{""main"":[[{""node"":""Prepare Qdrant Points"",""type"":""main"",""index"":0}]]},""Prepare Qdrant Points"":{""main"":[[{""node"":""Store in Qdrant Vector DB"",""type"":""main"",""index"":0}]]},""Store in Qdrant Vector DB"":{""main"":[[{""node"":""Log Completion & Statistics"",""type"":""main"",""index"":0}]]}}","{""executionOrder"":""v1"",""saveManualExecutions"":true,""callerPolicy"":""workflowsFromSameOwner""}",,{},777db697-d311-4d5e-bce2-886291a25efa,1,,,2025-07-26 06:38:39.409,2025-07-26 11:02:42,1
sU8WiDF4UnAQq9PC,Shopware Optimized Vectorization Workflow,0,"[{""parameters"":{},""id"":""a1b2c3d4-5e6f-7g8h-9i0j-1k2l3m4n5o6p"",""name"":""Manual Trigger"",""type"":""n8n-nodes-base.manualTrigger"",""typeVersion"":1,""position"":[240,300]},{""parameters"":{""jsCode"":""// Load and enhance dataset with Shopware-specific metadata\nconst fs = require('fs');\nconst path = require('path');\n\ntry {\n  // Load the optimized dataset\n  const datasetPath = path.join(process.cwd(), 'optimized_dataset_format.json');\n  const datasetContent = fs.readFileSync(datasetPath, 'utf8');\n  const dataset = JSON.parse(datasetContent);\n  \n  console.log('üìÅ Loading HELD Inuit Heizhandschuh optimized dataset...');\n  console.log(`Product: ${dataset.dataset_metadata.product_name}`);\n  console.log(`Article Number: ${dataset.dataset_metadata.product_id}`);\n  console.log(`Version: ${dataset.dataset_metadata.version}`);\n  console.log(`Total chunks: ${dataset.dataset_metadata.total_chunks}`);\n  \n  const chunks = dataset.optimized_chunks || [];\n  const articleNumber = dataset.dataset_metadata.product_id;\n  \n  if (chunks.length === 0) {\n    throw new Error('No chunks found in dataset');\n  }\n  \n  // Return each chunk as a separate item with enhanced Shopware metadata\n  return chunks.map((chunk, index) => ({\n    json: {\n      chunk_id: chunk.chunk_id,\n      content: chunk.content,\n      metadata: {\n        ...chunk.metadata,\n        // Shopware Integration Fields\n        article_number: articleNumber,\n        shopware_product_id: `sw_${articleNumber}`,\n        shopware_variant_id: `sw_var_${articleNumber}_${index.toString().padStart(3, '0')}`,\n        last_updated: new Date().toISOString(),\n        content_version: '2.0',\n        chunk_index: index,\n        \n        // Product Hierarchy\n        brand: 'HELD',\n        category_path: 'Handschuhe > Touring-Handschuhe > mit Membrane',\n        product_line: 'Inuit',\n        \n        // Update Tracking\n        source_system: 'shopware',\n        sync_status: 'active',\n        price_currency: 'EUR',\n        stock_status: 'available',\n        \n        // Processing metadata\n        processed_at: new Date().toISOString(),\n        content_length: chunk.content.length,\n        embedding_model: 'text-embedding-3-large',\n        workflow_version: '2.0_shopware_optimized'\n      },\n      article_number: articleNumber,\n      chunk_index: index,\n      dataset_info: {\n        product_id: dataset.dataset_metadata.product_id,\n        product_name: dataset.dataset_metadata.product_name,\n        language: dataset.dataset_metadata.language,\n        embedding_model: dataset.dataset_metadata.embedding_model\n      }\n    }\n  }));\n  \n} catch (error) {\n  console.error('‚ùå Failed to load dataset:', error.message);\n  throw new Error(`Dataset loading failed: ${error.message}`);\n}""},""id"":""b2c3d4e5-6f7g-8h9i-0j1k-2l3m4n5o6p7q"",""name"":""Load & Enhance Dataset"",""type"":""n8n-nodes-base.code"",""typeVersion"":2,""position"":[460,300]},{""parameters"":{""method"":""DELETE"",""url"":""http://localhost:6333/collections/held_products_optimized"",""options"":{""timeout"":30000,""retry"":{""enabled"":true,""maxRetries"":2,""retryInterval"":2000}}},""id"":""c3d4e5f6-7g8h-9i0j-1k2l-3m4n5o6p7q8r"",""name"":""Delete Existing Collection"",""type"":""n8n-nodes-base.httpRequest"",""typeVersion"":4.1,""position"":[680,300],""continueOnFail"":true},{""parameters"":{""method"":""PUT"",""url"":""http://localhost:6333/collections/held_products_optimized"",""sendHeaders"":true,""headerParameters"":{""parameters"":[{""name"":""Content-Type"",""value"":""application/json""}]},""sendBody"":true,""bodyParameters"":{""parameters"":[{""name"":""vectors"",""value"":""={\""size\"": 3072, \""distance\"": \""Cosine\""}""}]},""options"":{""timeout"":30000,""retry"":{""enabled"":true,""maxRetries"":3,""retryInterval"":2000}}},""id"":""d4e5f6g7-8h9i-0j1k-2l3m-4n5o6p7q8r9s"",""name"":""Create Optimized Collection"",""type"":""n8n-nodes-base.httpRequest"",""typeVersion"":4.1,""position"":[900,300]},{""parameters"":{""jsCode"":""// Create payload indexes for efficient Shopware queries\nconst indexesToCreate = [\n  'metadata.article_number',\n  'metadata.shopware_product_id',\n  'metadata.brand',\n  'metadata.category_path',\n  'metadata.last_updated',\n  'metadata.chunk_type',\n  'metadata.source_system',\n  'metadata.sync_status'\n];\n\nconsole.log('üîß Creating payload indexes for Shopware optimization...');\n\nreturn indexesToCreate.map(fieldName => ({\n  json: {\n    field_name: fieldName,\n    field_schema: 'keyword'\n  }\n}));""},""id"":""e5f6g7h8-9i0j-1k2l-3m4n-5o6p7q8r9s0t"",""name"":""Prepare Index Fields"",""type"":""n8n-nodes-base.code"",""typeVersion"":2,""position"":[1120,300]},{""parameters"":{""method"":""PUT"",""url"":""=http://localhost:6333/collections/held_products_optimized/index/{{ $json.field_name }}"",""sendHeaders"":true,""headerParameters"":{""parameters"":[{""name"":""Content-Type"",""value"":""application/json""}]},""sendBody"":true,""bodyParameters"":{""parameters"":[{""name"":""field_name"",""value"":""={{ $json.field_name }}""},{""name"":""field_schema"",""value"":""={{ $json.field_schema }}""}]},""options"":{""timeout"":15000}},""id"":""f6g7h8i9-0j1k-2l3m-4n5o-6p7q8r9s0t1u"",""name"":""Create Payload Indexes"",""type"":""n8n-nodes-base.httpRequest"",""typeVersion"":4.1,""position"":[1340,300],""continueOnFail"":true},{""parameters"":{""jsCode"":""// Generate deterministic mock embeddings for testing\nconst item = $input.item(0).json;\n\nif (!item.content) {\n  throw new Error('No content to generate embeddings for');\n}\n\nconsole.log(`üîÑ Generating mock embedding for chunk: ${item.chunk_id}`);\n\n// Generate deterministic mock embedding based on content\nfunction generateMockEmbedding(text, dimensions = 3072) {\n  const crypto = require('crypto');\n  const hash = crypto.createHash('md5').update(text).digest('hex');\n  \n  const embedding = [];\n  for (let i = 0; i < dimensions; i++) {\n    const hexPart = hash[(i * 2) % hash.length] + hash[((i * 2) + 1) % hash.length];\n    const value = (parseInt(hexPart, 16) / 255.0) * 2 - 1;\n    embedding.push(value);\n  }\n  \n  return embedding;\n}\n\nconst mockEmbedding = generateMockEmbedding(item.content);\n\nconsole.log(`‚úÖ Generated mock embedding: ${mockEmbedding.length} dimensions`);\nconsole.log(`   Range: ${Math.min(...mockEmbedding).toFixed(3)} to ${Math.max(...mockEmbedding).toFixed(3)}`);\n\nreturn {\n  json: {\n    ...item,\n    embedding: mockEmbedding,\n    embedding_info: {\n      model: 'mock-deterministic',\n      dimensions: mockEmbedding.length,\n      generated_at: new Date().toISOString(),\n      fallback_used: true\n    }\n  }\n};""},""id"":""g7h8i9j0-1k2l-3m4n-5o6p-7q8r9s0t1u2v"",""name"":""Generate Mock Embeddings"",""type"":""n8n-nodes-base.code"",""typeVersion"":2,""position"":[1560,300]},{""parameters"":{""jsCode"":""// Prepare optimized Qdrant points with deterministic IDs for upsert\nconst item = $input.item(0).json;\n\nif (!item.embedding || !Array.isArray(item.embedding)) {\n  throw new Error('No valid embedding found');\n}\n\nif (!item.chunk_id || !item.content) {\n  throw new Error('Missing required chunk data');\n}\n\n// Generate deterministic Point ID based on article number and chunk index\nfunction generateDeterministicPointId(articleNumber, chunkIndex) {\n  const idString = `${articleNumber}_${chunkIndex.toString().padStart(3, '0')}`;\n  const crypto = require('crypto');\n  const hash = crypto.createHash('md5').update(idString).digest('hex');\n  // Convert to positive integer within safe range\n  return parseInt(hash.substring(0, 15), 16);\n}\n\nconst pointId = generateDeterministicPointId(item.article_number, item.chunk_index);\n\n// Prepare comprehensive payload for Shopware integration\nconst payload = {\n  chunk_id: item.chunk_id,\n  content: item.content,\n  metadata: item.metadata\n};\n\n// Create Qdrant point\nconst qdrantPoint = {\n  id: pointId,\n  vector: item.embedding,\n  payload: payload\n};\n\nconsole.log(`üîÑ Preparing Qdrant point: ${pointId}`);\nconsole.log(`   Article: ${item.article_number}`);\nconsole.log(`   Chunk: ${item.chunk_id}`);\nconsole.log(`   Vector dimensions: ${item.embedding.length}`);\n\nreturn {\n  json: {\n    point: qdrantPoint,\n    article_number: item.article_number,\n    chunk_index: item.chunk_index,\n    summary: {\n      point_id: pointId,\n      chunk_type: item.metadata.chunk_type,\n      content_category: item.metadata.content_category,\n      article_number: item.article_number,\n      shopware_product_id: item.metadata.shopware_product_id\n    }\n  }\n};""},""id"":""h8i9j0k1-2l3m-4n5o-6p7q-8r9s0t1u2v3w"",""name"":""Prepare Optimized Qdrant Points"",""type"":""n8n-nodes-base.code"",""typeVersion"":2,""position"":[1780,300]},{""parameters"":{""jsCode"":""// Delete existing product data before upsert\nconst items = $input.all();\n\nif (!items || items.length === 0) {\n  throw new Error('No points to process');\n}\n\n// Get article number from first item\nconst articleNumber = items[0].json.article_number;\n\nconsole.log(`üóëÔ∏è Deleting existing data for article: ${articleNumber}`);\n\n// Prepare delete filter\nconst deleteFilter = {\n  must: [\n    {\n      key: 'metadata.article_number',\n      match: {\n        value: articleNumber\n      }\n    }\n  ]\n};\n\nreturn [{\n  json: {\n    filter: deleteFilter,\n    article_number: articleNumber,\n    points_to_upsert: items.map(item => item.json.point)\n  }\n}];""},""id"":""i9j0k1l2-3m4n-5o6p-7q8r-9s0t1u2v3w4x"",""name"":""Prepare Delete Filter"",""type"":""n8n-nodes-base.code"",""typeVersion"":2,""position"":[2000,300]},{""parameters"":{""method"":""POST"",""url"":""http://localhost:6333/collections/held_products_optimized/points/delete"",""sendHeaders"":true,""headerParameters"":{""parameters"":[{""name"":""Content-Type"",""value"":""application/json""}]},""sendBody"":true,""bodyParameters"":{""parameters"":[{""name"":""filter"",""value"":""={{ $json.filter }}""}]},""options"":{""timeout"":30000,""retry"":{""enabled"":true,""maxRetries"":2,""retryInterval"":2000}}},""id"":""j0k1l2m3-4n5o-6p7q-8r9s-0t1u2v3w4x5y"",""name"":""Delete Existing Product Data"",""type"":""n8n-nodes-base.httpRequest"",""typeVersion"":4.1,""position"":[2220,300]},{""parameters"":{""method"":""PUT"",""url"":""http://localhost:6333/collections/held_products_optimized/points"",""sendHeaders"":true,""headerParameters"":{""parameters"":[{""name"":""Content-Type"",""value"":""application/json""}]},""sendBody"":true,""bodyParameters"":{""parameters"":[{""name"":""points"",""value"":""={{ $node['Prepare Delete Filter'].json.points_to_upsert }}""}]},""options"":{""timeout"":60000,""retry"":{""enabled"":true,""maxRetries"":3,""retryInterval"":5000}}},""id"":""k1l2m3n4-5o6p-7q8r-9s0t-1u2v3w4x5y6z"",""name"":""Upsert Product Data"",""type"":""n8n-nodes-base.httpRequest"",""typeVersion"":4.1,""position"":[2440,300]},{""parameters"":{""jsCode"":""// Test upsert functionality by performing a search\nconst upsertResult = $input.item(0).json;\nconst articleNumber = $node['Prepare Delete Filter'].json.article_number;\n\nconsole.log('üß™ Testing upsert functionality...');\nconsole.log(`Article Number: ${articleNumber}`);\nconsole.log(`Upsert Status: ${upsertResult.status}`);\n\n// Prepare test search queries\nconst testQueries = [\n  'Wie lange h√§lt der Akku?',\n  'Welche Gr√∂√üen gibt es?',\n  'Ist der Handschuh wasserdicht?',\n  'Preis des Handschuhs'\n];\n\nreturn testQueries.map(query => ({\n  json: {\n    query: query,\n    article_number: articleNumber,\n    upsert_status: upsertResult.status\n  }\n}));""},""id"":""l2m3n4o5-6p7q-8r9s-0t1u-2v3w4x5y6z7a"",""name"":""Prepare Test Queries"",""type"":""n8n-nodes-base.code"",""typeVersion"":2,""position"":[2660,300]},{""parameters"":{""jsCode"":""// Generate mock query embedding for search test\nconst item = $input.item(0).json;\n\nfunction generateMockEmbedding(text, dimensions = 3072) {\n  const crypto = require('crypto');\n  const hash = crypto.createHash('md5').update(text).digest('hex');\n  \n  const embedding = [];\n  for (let i = 0; i < dimensions; i++) {\n    const hexPart = hash[(i * 2) % hash.length] + hash[((i * 2) + 1) % hash.length];\n    const value = (parseInt(hexPart, 16) / 255.0) * 2 - 1;\n    embedding.push(value);\n  }\n  \n  return embedding;\n}\n\nconst queryEmbedding = generateMockEmbedding(item.query);\n\nreturn {\n  json: {\n    ...item,\n    query_vector: queryEmbedding\n  }\n};""},""id"":""m3n4o5p6-7q8r-9s0t-1u2v-3w4x5y6z7a8b"",""name"":""Generate Query Embedding"",""type"":""n8n-nodes-base.code"",""typeVersion"":2,""position"":[2880,300]},{""parameters"":{""method"":""POST"",""url"":""http://localhost:6333/collections/held_products_optimized/points/search"",""sendHeaders"":true,""headerParameters"":{""parameters"":[{""name"":""Content-Type"",""value"":""application/json""}]},""sendBody"":true,""bodyParameters"":{""parameters"":[{""name"":""vector"",""value"":""={{ $json.query_vector }}""},{""name"":""filter"",""value"":""={\""must\"": [{\""key\"": \""metadata.article_number\"", \""match\"": {\""value\"": \""{{ $json.article_number }}\""}}]}""},{""name"":""limit"",""value"":2},{""name"":""with_payload"",""value"":true}]},""options"":{""timeout"":30000}},""id"":""n4o5p6q7-8r9s-0t1u-2v3w-4x5y6z7a8b9c"",""name"":""Test Search Functionality"",""type"":""n8n-nodes-base.httpRequest"",""typeVersion"":4.1,""position"":[3100,300]},{""parameters"":{""jsCode"":""// Generate final completion report\nconst searchResults = $input.all();\nconst articleNumber = searchResults[0]?.json?.article_number || 'unknown';\n\nconst completionTime = new Date().toISOString();\n\n// Analyze search results\nlet totalSearches = searchResults.length;\nlet successfulSearches = 0;\nlet searchSummary = [];\n\nsearchResults.forEach((result, index) => {\n  const searchData = result.json;\n  const query = $node['Prepare Test Queries'].json[index]?.query || 'unknown';\n  \n  if (searchData.result && Array.isArray(searchData.result)) {\n    successfulSearches++;\n    searchSummary.push({\n      query: query,\n      results_found: searchData.result.length,\n      top_score: searchData.result[0]?.score || 0\n    });\n  }\n});\n\n// Generate final report\nconst finalReport = {\n  workflow_status: 'completed',\n  completion_time: completionTime,\n  \n  workflow_summary: {\n    article_number: articleNumber,\n    collection_name: 'held_products_optimized',\n    workflow_version: '2.0_shopware_optimized'\n  },\n  \n  upsert_summary: {\n    upsert_completed: true,\n    article_processed: articleNumber,\n    collection_recreated: true\n  },\n  \n  search_testing: {\n    total_queries: totalSearches,\n    successful_searches: successfulSearches,\n    success_rate: totalSearches > 0 ? `${Math.round((successfulSearches / totalSearches) * 100)}%` : '0%',\n    search_results: searchSummary\n  },\n  \n  optimization_features: [\n    'Shopware-specific metadata enhancement',\n    'Deterministic point ID generation',\n    'Article number-based upsert functionality',\n    'Payload indexing for efficient queries',\n    'Mock embedding generation for testing',\n    'Search functionality verification'\n  ],\n  \n  next_steps: [\n    'Integrate with real OpenAI embeddings API',\n    'Connect to live Shopware product data',\n    'Implement automated sync scheduling',\n    'Add monitoring and alerting',\n    'Scale for production workloads'\n  ]\n};\n\nconsole.log('üéâ ===== SHOPWARE VECTORIZATION COMPLETED =====');\nconsole.log(`üìä Article processed: ${finalReport.workflow_summary.article_number}`);\nconsole.log(`‚úÖ Upsert completed: ${finalReport.upsert_summary.upsert_completed}`);\nconsole.log(`üîç Search success rate: ${finalReport.search_testing.success_rate}`);\nconsole.log(`‚è∞ Completed at: ${completionTime}`);\nconsole.log('================================================');\n\nreturn [{ json: finalReport }];""},""id"":""o5p6q7r8-9s0t-1u2v-3w4x-5y6z7a8b9c0d"",""name"":""Generate Completion Report"",""type"":""n8n-nodes-base.code"",""typeVersion"":2,""position"":[3320,300]}]","{""Manual Trigger"":{""main"":[[{""node"":""Load & Enhance Dataset"",""type"":""main"",""index"":0}]]},""Load & Enhance Dataset"":{""main"":[[{""node"":""Delete Existing Collection"",""type"":""main"",""index"":0}]]},""Delete Existing Collection"":{""main"":[[{""node"":""Create Optimized Collection"",""type"":""main"",""index"":0}]]},""Create Optimized Collection"":{""main"":[[{""node"":""Prepare Index Fields"",""type"":""main"",""index"":0}]]},""Prepare Index Fields"":{""main"":[[{""node"":""Create Payload Indexes"",""type"":""main"",""index"":0}]]},""Create Payload Indexes"":{""main"":[[{""node"":""Generate Mock Embeddings"",""type"":""main"",""index"":0}]]},""Generate Mock Embeddings"":{""main"":[[{""node"":""Prepare Optimized Qdrant Points"",""type"":""main"",""index"":0}]]},""Prepare Optimized Qdrant Points"":{""main"":[[{""node"":""Prepare Delete Filter"",""type"":""main"",""index"":0}]]},""Prepare Delete Filter"":{""main"":[[{""node"":""Delete Existing Product Data"",""type"":""main"",""index"":0}]]},""Delete Existing Product Data"":{""main"":[[{""node"":""Upsert Product Data"",""type"":""main"",""index"":0}]]},""Upsert Product Data"":{""main"":[[{""node"":""Prepare Test Queries"",""type"":""main"",""index"":0}]]},""Prepare Test Queries"":{""main"":[[{""node"":""Generate Query Embedding"",""type"":""main"",""index"":0}]]},""Generate Query Embedding"":{""main"":[[{""node"":""Test Search Functionality"",""type"":""main"",""index"":0}]]},""Test Search Functionality"":{""main"":[[{""node"":""Generate Completion Report"",""type"":""main"",""index"":0}]]}}","{""executionOrder"":""v1"",""saveManualExecutions"":true,""callerPolicy"":""workflowsFromSameOwner""}",,{},b6423fd3-56df-43e1-9d5e-e9280fd3c86d,1,,,2025-07-26 10:14:38.782,2025-07-26 11:02:40,1
JWL1s21OQx2lOpBL,Shopware Optimized Vectorization Workflow (Fixed),1,"[{""parameters"":{},""id"":""a1b2c3d4-5e6f-7g8h-9i0j-1k2l3m4n5o6p"",""name"":""Manual Trigger"",""type"":""n8n-nodes-base.manualTrigger"",""typeVersion"":1,""position"":[240,300]},{""parameters"":{""jsCode"":""// Load and enhance dataset with embedded data (since fs module is not available)\nconst dataset = {\n  \""dataset_metadata\"": {\n    \""version\"": \""1.0\"",\n    \""created\"": \""2025-01-26\"",\n    \""product_id\"": \""022572-00\"",\n    \""product_name\"": \""Inuit Heizhandschuh\"",\n    \""language\"": \""de\"",\n    \""total_chunks\"": 3,\n    \""embedding_model\"": \""text-embedding-3-large\"",\n    \""chunk_strategy\"": \""semantic_overlap\""\n  },\n  \""optimized_chunks\"": [\n    {\n      \""chunk_id\"": \""inuit_001_overview\"",\n      \""content\"": \""HELD Inuit Heizhandschuh (Art. 022572-00) - Premium beheizter Motorradhandschuh f√ºr extreme Winterbedingungen. Preis: 249,95 ‚Ç¨. Aktuell nicht verf√ºgbar. Kategorie: Touring-Handschuhe mit Membrane. Verf√ºgbare Gr√∂√üen: 7, 8, 9, 10, 11, 12 (Standardgr√∂√üen). Farbe: schwarz. Hochwertige Verarbeitung mit 7,4V 3000 mAh Batteriesystem f√ºr zuverl√§ssige W√§rmeleistung.\"",\n      \""metadata\"": {\n        \""chunk_type\"": \""product_overview\"",\n        \""content_category\"": \""basic_info\"",\n        \""keywords\"": [\""Preis\"", \""Verf√ºgbarkeit\"", \""Gr√∂√üen\"", \""Farbe\"", \""Heizhandschuh\""],\n        \""customer_intents\"": [\""product_inquiry\"", \""price_check\"", \""availability\"", \""sizing\""],\n        \""confidence_score\"": 0.95,\n        \""seasonal_relevance\"": \""winter\"",\n        \""technical_level\"": \""basic\""\n      }\n    },\n    {\n      \""chunk_id\"": \""inuit_002_heating_system\"",\n      \""content\"": \""Heizsystem: 7,4V 3000 mAh Lithium-Akku mit drei Heizstufen. TURBO (-70¬∞C): Finger 2,5h, Handschuh 4,5h, Kombination 1,5h. HIGH (-50¬∞C): Finger 4,0h, Handschuh 7,5h, Kombination 2,5h. LOW (-30¬∞C): Finger 7,5h, Handschuh 11,0h, Kombination 4,0h. Separate Heizzonen f√ºr Finger und Handschuh steuerbar. Ladeger√§t inklusive.\"",\n      \""metadata\"": {\n        \""chunk_type\"": \""technical_specifications\"",\n        \""content_category\"": \""heating_performance\"",\n        \""keywords\"": [\""Akku\"", \""Heizstufen\"", \""Laufzeit\"", \""Temperatur\"", \""Heizzonen\""],\n        \""customer_intents\"": [\""battery_life\"", \""heating_performance\"", \""temperature_range\""],\n        \""confidence_score\"": 0.98,\n        \""technical_level\"": \""detailed\""\n      }\n    },\n    {\n      \""chunk_id\"": \""inuit_003_materials\"",\n      \""content\"": \""Materialien: Oberhand aus hochwertigem Stretchgewebe f√ºr Flexibilit√§t. Handfl√§che aus robustem Ziegenleder (farbecht und schwei√übest√§ndig). Futter: Oberhand mit Thermoplush Fleece und PRIMALOFT¬Æ Isolierung, Handfl√§che mit 3M‚Ñ¢-Thinsulate‚Ñ¢ W√§rmefutter. Leder/Textil-Mix f√ºr optimale Balance zwischen Schutz und Komfort.\"",\n      \""metadata\"": {\n        \""chunk_type\"": \""technical_specifications\"",\n        \""content_category\"": \""materials\"",\n        \""keywords\"": [\""Stretchgewebe\"", \""Ziegenleder\"", \""PRIMALOFT\"", \""Thinsulate\"", \""Materialien\""],\n        \""customer_intents\"": [\""material_questions\"", \""quality_inquiry\"", \""durability\""],\n        \""confidence_score\"": 0.96,\n        \""technical_level\"": \""detailed\""\n      }\n    }\n  ]\n};\n\nconsole.log('üìÅ Loading HELD Inuit Heizhandschuh optimized dataset...');\nconsole.log(`Product: ${dataset.dataset_metadata.product_name}`);\nconsole.log(`Article Number: ${dataset.dataset_metadata.product_id}`);\nconsole.log(`Version: ${dataset.dataset_metadata.version}`);\nconsole.log(`Total chunks: ${dataset.dataset_metadata.total_chunks}`);\n\nconst chunks = dataset.optimized_chunks || [];\nconst articleNumber = dataset.dataset_metadata.product_id;\n\nif (chunks.length === 0) {\n  throw new Error('No chunks found in dataset');\n}\n\n// Return each chunk as a separate item with enhanced Shopware metadata\nreturn chunks.map((chunk, index) => ({\n  json: {\n    chunk_id: chunk.chunk_id,\n    content: chunk.content,\n    metadata: {\n      ...chunk.metadata,\n      // Shopware Integration Fields\n      article_number: articleNumber,\n      shopware_product_id: `sw_${articleNumber}`,\n      shopware_variant_id: `sw_var_${articleNumber}_${index.toString().padStart(3, '0')}`,\n      last_updated: new Date().toISOString(),\n      content_version: '2.0',\n      chunk_index: index,\n      \n      // Product Hierarchy\n      brand: 'HELD',\n      category_path: 'Handschuhe > Touring-Handschuhe > mit Membrane',\n      product_line: 'Inuit',\n      \n      // Update Tracking\n      source_system: 'shopware',\n      sync_status: 'active',\n      price_currency: 'EUR',\n      stock_status: 'available',\n      \n      // Processing metadata\n      processed_at: new Date().toISOString(),\n      content_length: chunk.content.length,\n      embedding_model: 'text-embedding-3-large',\n      workflow_version: '2.0_shopware_optimized'\n    },\n    article_number: articleNumber,\n    chunk_index: index,\n    dataset_info: {\n      product_id: dataset.dataset_metadata.product_id,\n      product_name: dataset.dataset_metadata.product_name,\n      language: dataset.dataset_metadata.language,\n      embedding_model: dataset.dataset_metadata.embedding_model\n    }\n  }\n}));""},""id"":""b2c3d4e5-6f7g-8h9i-0j1k-2l3m4n5o6p7q"",""name"":""Load & Enhance Dataset (Fixed)"",""type"":""n8n-nodes-base.code"",""typeVersion"":2,""position"":[460,300]},{""parameters"":{""method"":""DELETE"",""url"":""http://localhost:6333/collections/held_products_optimized"",""options"":{""timeout"":30000,""retry"":{""enabled"":true,""maxRetries"":2,""retryInterval"":2000}}},""id"":""c3d4e5f6-7g8h-9i0j-1k2l-3m4n5o6p7q8r"",""name"":""Delete Existing Collection"",""type"":""n8n-nodes-base.httpRequest"",""typeVersion"":4.1,""position"":[680,300],""continueOnFail"":true},{""parameters"":{""method"":""PUT"",""url"":""http://localhost:6333/collections/held_products_optimized"",""sendHeaders"":true,""headerParameters"":{""parameters"":[{""name"":""Content-Type"",""value"":""application/json""}]},""sendBody"":true,""bodyParameters"":{""parameters"":[{""name"":""vectors"",""value"":""={\""size\"": 3072, \""distance\"": \""Cosine\""}""}]},""options"":{""timeout"":30000,""retry"":{""enabled"":true,""maxRetries"":3,""retryInterval"":2000}}},""id"":""d4e5f6g7-8h9i-0j1k-2l3m-4n5o6p7q8r9s"",""name"":""Create Optimized Collection"",""type"":""n8n-nodes-base.httpRequest"",""typeVersion"":4.1,""position"":[900,300]},{""parameters"":{""jsCode"":""// Generate deterministic mock embeddings for testing\nconst item = $input.item(0).json;\n\nif (!item.content) {\n  throw new Error('No content to generate embeddings for');\n}\n\nconsole.log(`üîÑ Generating mock embedding for chunk: ${item.chunk_id}`);\n\n// Generate deterministic mock embedding based on content\nfunction generateMockEmbedding(text, dimensions = 3072) {\n  // Simple hash-based deterministic embedding generation\n  let hash = 0;\n  for (let i = 0; i < text.length; i++) {\n    const char = text.charCodeAt(i);\n    hash = ((hash << 5) - hash) + char;\n    hash = hash & hash; // Convert to 32bit integer\n  }\n  \n  const embedding = [];\n  for (let i = 0; i < dimensions; i++) {\n    // Use hash and index to generate deterministic values\n    const seed = hash + i;\n    const value = (Math.sin(seed) * 10000) % 2 - 1; // Range -1 to 1\n    embedding.push(value);\n  }\n  \n  return embedding;\n}\n\nconst mockEmbedding = generateMockEmbedding(item.content);\n\nconsole.log(`‚úÖ Generated mock embedding: ${mockEmbedding.length} dimensions`);\nconsole.log(`   Range: ${Math.min(...mockEmbedding).toFixed(3)} to ${Math.max(...mockEmbedding).toFixed(3)}`);\n\nreturn {\n  json: {\n    ...item,\n    embedding: mockEmbedding,\n    embedding_info: {\n      model: 'mock-deterministic',\n      dimensions: mockEmbedding.length,\n      generated_at: new Date().toISOString(),\n      fallback_used: true\n    }\n  }\n};""},""id"":""e5f6g7h8-9i0j-1k2l-3m4n-5o6p7q8r9s0t"",""name"":""Generate Mock Embeddings"",""type"":""n8n-nodes-base.code"",""typeVersion"":2,""position"":[1120,300]},{""parameters"":{""jsCode"":""// Prepare optimized Qdrant points with deterministic IDs for upsert\nconst item = $input.item(0).json;\n\nif (!item.embedding || !Array.isArray(item.embedding)) {\n  throw new Error('No valid embedding found');\n}\n\nif (!item.chunk_id || !item.content) {\n  throw new Error('Missing required chunk data');\n}\n\n// Generate deterministic Point ID based on article number and chunk index\nfunction generateDeterministicPointId(articleNumber, chunkIndex) {\n  const idString = `${articleNumber}_${chunkIndex.toString().padStart(3, '0')}`;\n  let hash = 0;\n  for (let i = 0; i < idString.length; i++) {\n    const char = idString.charCodeAt(i);\n    hash = ((hash << 5) - hash) + char;\n    hash = hash & hash;\n  }\n  // Ensure positive integer\n  return Math.abs(hash);\n}\n\nconst pointId = generateDeterministicPointId(item.article_number, item.chunk_index);\n\n// Prepare comprehensive payload for Shopware integration\nconst payload = {\n  chunk_id: item.chunk_id,\n  content: item.content,\n  metadata: item.metadata\n};\n\n// Create Qdrant point\nconst qdrantPoint = {\n  id: pointId,\n  vector: item.embedding,\n  payload: payload\n};\n\nconsole.log(`üîÑ Preparing Qdrant point: ${pointId}`);\nconsole.log(`   Article: ${item.article_number}`);\nconsole.log(`   Chunk: ${item.chunk_id}`);\nconsole.log(`   Vector dimensions: ${item.embedding.length}`);\n\nreturn {\n  json: {\n    point: qdrantPoint,\n    article_number: item.article_number,\n    chunk_index: item.chunk_index,\n    summary: {\n      point_id: pointId,\n      chunk_type: item.metadata.chunk_type,\n      content_category: item.metadata.content_category,\n      article_number: item.article_number,\n      shopware_product_id: item.metadata.shopware_product_id\n    }\n  }\n};""},""id"":""f6g7h8i9-0j1k-2l3m-4n5o-6p7q8r9s0t1u"",""name"":""Prepare Optimized Qdrant Points"",""type"":""n8n-nodes-base.code"",""typeVersion"":2,""position"":[1340,300]},{""parameters"":{""jsCode"":""// Collect all points for batch upload to Qdrant\nconst items = $input.all();\n\nif (!items || items.length === 0) {\n  throw new Error('No points to upload to Qdrant');\n}\n\nconst points = [];\nconst summaries = [];\nconst errors = [];\nlet articleNumber = null;\n\nitems.forEach((item, index) => {\n  try {\n    if (!item.json || !item.json.point) {\n      errors.push(`Item ${index}: Missing point data`);\n      return;\n    }\n    \n    const point = item.json.point;\n    const summary = item.json.summary;\n    \n    // Validate point structure\n    if (!point.id || !point.vector || !point.payload) {\n      errors.push(`Item ${index}: Invalid point structure`);\n      return;\n    }\n    \n    points.push(point);\n    summaries.push(summary);\n    \n    // Get article number from first valid item\n    if (!articleNumber && item.json.article_number) {\n      articleNumber = item.json.article_number;\n    }\n    \n  } catch (error) {\n    errors.push(`Item ${index}: ${error.message}`);\n  }\n});\n\nif (points.length === 0) {\n  throw new Error('No valid points could be prepared for upload');\n}\n\nconsole.log('üì¶ Collecting points for batch upload...');\nconsole.log(`‚úÖ Prepared ${points.length} points for Qdrant`);\nconsole.log(`‚ö†Ô∏è ${errors.length} errors encountered`);\nconsole.log(`üìã Article Number: ${articleNumber}`);\n\nreturn {\n  json: {\n    points: points,\n    article_number: articleNumber,\n    batch_info: {\n      total_points: points.length,\n      total_errors: errors.length,\n      prepared_at: new Date().toISOString()\n    },\n    errors: errors\n  }\n};""},""id"":""g7h8i9j0-1k2l-3m4n-5o6p-7q8r9s0t1u2v"",""name"":""Collect Points for Batch Upload"",""type"":""n8n-nodes-base.code"",""typeVersion"":2,""position"":[1560,300]},{""parameters"":{""method"":""PUT"",""url"":""http://localhost:6333/collections/held_products_optimized/points"",""sendHeaders"":true,""headerParameters"":{""parameters"":[{""name"":""Content-Type"",""value"":""application/json""}]},""sendBody"":true,""bodyParameters"":{""parameters"":[{""name"":""points"",""value"":""={{ $json.points }}""}]},""options"":{""timeout"":60000,""retry"":{""enabled"":true,""maxRetries"":3,""retryInterval"":5000}}},""id"":""h8i9j0k1-2l3m-4n5o-6p7q-8r9s0t1u2v3w"",""name"":""Upsert Product Data"",""type"":""n8n-nodes-base.httpRequest"",""typeVersion"":4.1,""position"":[1780,300]},{""parameters"":{""jsCode"":""// Generate final completion report\nconst upsertResult = $input.item(0).json;\nconst batchInfo = $node['Collect Points for Batch Upload'].json.batch_info;\nconst articleNumber = $node['Collect Points for Batch Upload'].json.article_number;\n\n// Check if upload was successful\nlet uploadSuccess = false;\nif (upsertResult && upsertResult.status === 'ok') {\n  uploadSuccess = true;\n}\n\nconst completionTime = new Date().toISOString();\n\n// Generate final report\nconst finalReport = {\n  workflow_status: 'completed',\n  completion_time: completionTime,\n  \n  workflow_summary: {\n    article_number: articleNumber,\n    collection_name: 'held_products_optimized',\n    workflow_version: '2.0_shopware_optimized_fixed'\n  },\n  \n  upload_summary: {\n    points_uploaded: batchInfo.total_points,\n    upload_errors: batchInfo.total_errors,\n    upload_success: uploadSuccess,\n    qdrant_response: upsertResult\n  },\n  \n  optimization_features: [\n    'Shopware-specific metadata enhancement',\n    'Deterministic point ID generation',\n    'Article number-based upsert functionality',\n    'Mock embedding generation for testing',\n    'Embedded dataset (no file system dependency)',\n    'Error handling and validation'\n  ],\n  \n  next_steps: [\n    'Integrate with real OpenAI embeddings API',\n    'Connect to live Shopware product data',\n    'Implement automated sync scheduling',\n    'Add monitoring and alerting',\n    'Scale for production workloads'\n  ]\n};\n\nconsole.log('üéâ ===== SHOPWARE VECTORIZATION COMPLETED =====');\nconsole.log(`üìä Article processed: ${finalReport.workflow_summary.article_number}`);\nconsole.log(`‚úÖ Upload success: ${finalReport.upload_summary.upload_success}`);\nconsole.log(`üì¶ Points uploaded: ${finalReport.upload_summary.points_uploaded}`);\nconsole.log(`‚è∞ Completed at: ${completionTime}`);\nconsole.log('================================================');\n\nreturn [{ json: finalReport }];""},""id"":""i9j0k1l2-3m4n-5o6p-7q8r-9s0t1u2v3w4x"",""name"":""Generate Completion Report"",""type"":""n8n-nodes-base.code"",""typeVersion"":2,""position"":[2000,300]}]","{""Manual Trigger"":{""main"":[[{""node"":""Load & Enhance Dataset (Fixed)"",""type"":""main"",""index"":0}]]},""Load & Enhance Dataset (Fixed)"":{""main"":[[{""node"":""Delete Existing Collection"",""type"":""main"",""index"":0}]]},""Delete Existing Collection"":{""main"":[[{""node"":""Create Optimized Collection"",""type"":""main"",""index"":0}]]},""Create Optimized Collection"":{""main"":[[{""node"":""Generate Mock Embeddings"",""type"":""main"",""index"":0}]]},""Generate Mock Embeddings"":{""main"":[[{""node"":""Prepare Optimized Qdrant Points"",""type"":""main"",""index"":0}]]},""Prepare Optimized Qdrant Points"":{""main"":[[{""node"":""Collect Points for Batch Upload"",""type"":""main"",""index"":0}]]},""Collect Points for Batch Upload"":{""main"":[[{""node"":""Upsert Product Data"",""type"":""main"",""index"":0}]]},""Upsert Product Data"":{""main"":[[{""node"":""Generate Completion Report"",""type"":""main"",""index"":0}]]}}","{""executionOrder"":""v1"",""saveManualExecutions"":true,""callerPolicy"":""workflowsFromSameOwner""}",,{},f80e5ee3-2300-46f1-bda3-b3100561f857,1,,,2025-07-26 10:18:06.864,2025-07-26 11:02:37,1
yNElfI1SZOWdSh1G,Shopware Optimized Vectorization Workflow (Fixed),0,"[{""parameters"":{},""id"":""a1b2c3d4-5e6f-7g8h-9i0j-1k2l3m4n5o6p"",""name"":""Manual Trigger"",""type"":""n8n-nodes-base.manualTrigger"",""typeVersion"":1,""position"":[240,300]},{""parameters"":{""jsCode"":""// Load and enhance dataset with embedded data (since fs module is not available)\nconst dataset = {\n  \""dataset_metadata\"": {\n    \""version\"": \""1.0\"",\n    \""created\"": \""2025-01-26\"",\n    \""product_id\"": \""022572-00\"",\n    \""product_name\"": \""Inuit Heizhandschuh\"",\n    \""language\"": \""de\"",\n    \""total_chunks\"": 3,\n    \""embedding_model\"": \""text-embedding-3-large\"",\n    \""chunk_strategy\"": \""semantic_overlap\""\n  },\n  \""optimized_chunks\"": [\n    {\n      \""chunk_id\"": \""inuit_001_overview\"",\n      \""content\"": \""HELD Inuit Heizhandschuh (Art. 022572-00) - Premium beheizter Motorradhandschuh f√ºr extreme Winterbedingungen. Preis: 249,95 ‚Ç¨. Aktuell nicht verf√ºgbar. Kategorie: Touring-Handschuhe mit Membrane. Verf√ºgbare Gr√∂√üen: 7, 8, 9, 10, 11, 12 (Standardgr√∂√üen). Farbe: schwarz. Hochwertige Verarbeitung mit 7,4V 3000 mAh Batteriesystem f√ºr zuverl√§ssige W√§rmeleistung.\"",\n      \""metadata\"": {\n        \""chunk_type\"": \""product_overview\"",\n        \""content_category\"": \""basic_info\"",\n        \""keywords\"": [\""Preis\"", \""Verf√ºgbarkeit\"", \""Gr√∂√üen\"", \""Farbe\"", \""Heizhandschuh\""],\n        \""customer_intents\"": [\""product_inquiry\"", \""price_check\"", \""availability\"", \""sizing\""],\n        \""confidence_score\"": 0.95,\n        \""seasonal_relevance\"": \""winter\"",\n        \""technical_level\"": \""basic\""\n      }\n    },\n    {\n      \""chunk_id\"": \""inuit_002_heating_system\"",\n      \""content\"": \""Heizsystem: 7,4V 3000 mAh Lithium-Akku mit drei Heizstufen. TURBO (-70¬∞C): Finger 2,5h, Handschuh 4,5h, Kombination 1,5h. HIGH (-50¬∞C): Finger 4,0h, Handschuh 7,5h, Kombination 2,5h. LOW (-30¬∞C): Finger 7,5h, Handschuh 11,0h, Kombination 4,0h. Separate Heizzonen f√ºr Finger und Handschuh steuerbar. Ladeger√§t inklusive.\"",\n      \""metadata\"": {\n        \""chunk_type\"": \""technical_specifications\"",\n        \""content_category\"": \""heating_performance\"",\n        \""keywords\"": [\""Akku\"", \""Heizstufen\"", \""Laufzeit\"", \""Temperatur\"", \""Heizzonen\""],\n        \""customer_intents\"": [\""battery_life\"", \""heating_performance\"", \""temperature_range\""],\n        \""confidence_score\"": 0.98,\n        \""technical_level\"": \""detailed\""\n      }\n    },\n    {\n      \""chunk_id\"": \""inuit_003_materials\"",\n      \""content\"": \""Materialien: Oberhand aus hochwertigem Stretchgewebe f√ºr Flexibilit√§t. Handfl√§che aus robustem Ziegenleder (farbecht und schwei√übest√§ndig). Futter: Oberhand mit Thermoplush Fleece und PRIMALOFT¬Æ Isolierung, Handfl√§che mit 3M‚Ñ¢-Thinsulate‚Ñ¢ W√§rmefutter. Leder/Textil-Mix f√ºr optimale Balance zwischen Schutz und Komfort.\"",\n      \""metadata\"": {\n        \""chunk_type\"": \""technical_specifications\"",\n        \""content_category\"": \""materials\"",\n        \""keywords\"": [\""Stretchgewebe\"", \""Ziegenleder\"", \""PRIMALOFT\"", \""Thinsulate\"", \""Materialien\""],\n        \""customer_intents\"": [\""material_questions\"", \""quality_inquiry\"", \""durability\""],\n        \""confidence_score\"": 0.96,\n        \""technical_level\"": \""detailed\""\n      }\n    }\n  ]\n};\n\nconsole.log('üìÅ Loading HELD Inuit Heizhandschuh optimized dataset...');\nconsole.log(`Product: ${dataset.dataset_metadata.product_name}`);\nconsole.log(`Article Number: ${dataset.dataset_metadata.product_id}`);\nconsole.log(`Version: ${dataset.dataset_metadata.version}`);\nconsole.log(`Total chunks: ${dataset.dataset_metadata.total_chunks}`);\n\nconst chunks = dataset.optimized_chunks || [];\nconst articleNumber = dataset.dataset_metadata.product_id;\n\nif (chunks.length === 0) {\n  throw new Error('No chunks found in dataset');\n}\n\n// Return each chunk as a separate item with enhanced Shopware metadata\nreturn chunks.map((chunk, index) => ({\n  json: {\n    chunk_id: chunk.chunk_id,\n    content: chunk.content,\n    metadata: {\n      ...chunk.metadata,\n      // Shopware Integration Fields\n      article_number: articleNumber,\n      shopware_product_id: `sw_${articleNumber}`,\n      shopware_variant_id: `sw_var_${articleNumber}_${index.toString().padStart(3, '0')}`,\n      last_updated: new Date().toISOString(),\n      content_version: '2.0',\n      chunk_index: index,\n      \n      // Product Hierarchy\n      brand: 'HELD',\n      category_path: 'Handschuhe > Touring-Handschuhe > mit Membrane',\n      product_line: 'Inuit',\n      \n      // Update Tracking\n      source_system: 'shopware',\n      sync_status: 'active',\n      price_currency: 'EUR',\n      stock_status: 'available',\n      \n      // Processing metadata\n      processed_at: new Date().toISOString(),\n      content_length: chunk.content.length,\n      embedding_model: 'text-embedding-3-large',\n      workflow_version: '2.0_shopware_optimized'\n    },\n    article_number: articleNumber,\n    chunk_index: index,\n    dataset_info: {\n      product_id: dataset.dataset_metadata.product_id,\n      product_name: dataset.dataset_metadata.product_name,\n      language: dataset.dataset_metadata.language,\n      embedding_model: dataset.dataset_metadata.embedding_model\n    }\n  }\n}));""},""id"":""b2c3d4e5-6f7g-8h9i-0j1k-2l3m4n5o6p7q"",""name"":""Load & Enhance Dataset (Fixed)"",""type"":""n8n-nodes-base.code"",""typeVersion"":2,""position"":[460,300]},{""parameters"":{""method"":""DELETE"",""url"":""http://localhost:6333/collections/held_products_optimized"",""options"":{""timeout"":30000,""retry"":{""enabled"":true,""maxRetries"":2,""retryInterval"":2000}}},""id"":""c3d4e5f6-7g8h-9i0j-1k2l-3m4n5o6p7q8r"",""name"":""Delete Existing Collection"",""type"":""n8n-nodes-base.httpRequest"",""typeVersion"":4.1,""position"":[680,300],""continueOnFail"":true},{""parameters"":{""method"":""PUT"",""url"":""http://localhost:6333/collections/held_products_optimized"",""sendHeaders"":true,""headerParameters"":{""parameters"":[{""name"":""Content-Type"",""value"":""application/json""}]},""sendBody"":true,""bodyParameters"":{""parameters"":[{""name"":""vectors"",""value"":""={\""size\"": 3072, \""distance\"": \""Cosine\""}""}]},""options"":{""timeout"":30000,""retry"":{""enabled"":true,""maxRetries"":3,""retryInterval"":2000}}},""id"":""d4e5f6g7-8h9i-0j1k-2l3m-4n5o6p7q8r9s"",""name"":""Create Optimized Collection"",""type"":""n8n-nodes-base.httpRequest"",""typeVersion"":4.1,""position"":[900,300]},{""parameters"":{""jsCode"":""// Generate deterministic mock embeddings for testing\nconst item = $input.item(0).json;\n\nif (!item.content) {\n  throw new Error('No content to generate embeddings for');\n}\n\nconsole.log(`üîÑ Generating mock embedding for chunk: ${item.chunk_id}`);\n\n// Generate deterministic mock embedding based on content\nfunction generateMockEmbedding(text, dimensions = 3072) {\n  // Simple hash-based deterministic embedding generation\n  let hash = 0;\n  for (let i = 0; i < text.length; i++) {\n    const char = text.charCodeAt(i);\n    hash = ((hash << 5) - hash) + char;\n    hash = hash & hash; // Convert to 32bit integer\n  }\n  \n  const embedding = [];\n  for (let i = 0; i < dimensions; i++) {\n    // Use hash and index to generate deterministic values\n    const seed = hash + i;\n    const value = (Math.sin(seed) * 10000) % 2 - 1; // Range -1 to 1\n    embedding.push(value);\n  }\n  \n  return embedding;\n}\n\nconst mockEmbedding = generateMockEmbedding(item.content);\n\nconsole.log(`‚úÖ Generated mock embedding: ${mockEmbedding.length} dimensions`);\nconsole.log(`   Range: ${Math.min(...mockEmbedding).toFixed(3)} to ${Math.max(...mockEmbedding).toFixed(3)}`);\n\nreturn {\n  json: {\n    ...item,\n    embedding: mockEmbedding,\n    embedding_info: {\n      model: 'mock-deterministic',\n      dimensions: mockEmbedding.length,\n      generated_at: new Date().toISOString(),\n      fallback_used: true\n    }\n  }\n};""},""id"":""e5f6g7h8-9i0j-1k2l-3m4n-5o6p7q8r9s0t"",""name"":""Generate Mock Embeddings"",""type"":""n8n-nodes-base.code"",""typeVersion"":2,""position"":[1120,300]},{""parameters"":{""jsCode"":""// Prepare optimized Qdrant points with deterministic IDs for upsert\nconst item = $input.item(0).json;\n\nif (!item.embedding || !Array.isArray(item.embedding)) {\n  throw new Error('No valid embedding found');\n}\n\nif (!item.chunk_id || !item.content) {\n  throw new Error('Missing required chunk data');\n}\n\n// Generate deterministic Point ID based on article number and chunk index\nfunction generateDeterministicPointId(articleNumber, chunkIndex) {\n  const idString = `${articleNumber}_${chunkIndex.toString().padStart(3, '0')}`;\n  let hash = 0;\n  for (let i = 0; i < idString.length; i++) {\n    const char = idString.charCodeAt(i);\n    hash = ((hash << 5) - hash) + char;\n    hash = hash & hash;\n  }\n  // Ensure positive integer\n  return Math.abs(hash);\n}\n\nconst pointId = generateDeterministicPointId(item.article_number, item.chunk_index);\n\n// Prepare comprehensive payload for Shopware integration\nconst payload = {\n  chunk_id: item.chunk_id,\n  content: item.content,\n  metadata: item.metadata\n};\n\n// Create Qdrant point\nconst qdrantPoint = {\n  id: pointId,\n  vector: item.embedding,\n  payload: payload\n};\n\nconsole.log(`üîÑ Preparing Qdrant point: ${pointId}`);\nconsole.log(`   Article: ${item.article_number}`);\nconsole.log(`   Chunk: ${item.chunk_id}`);\nconsole.log(`   Vector dimensions: ${item.embedding.length}`);\n\nreturn {\n  json: {\n    point: qdrantPoint,\n    article_number: item.article_number,\n    chunk_index: item.chunk_index,\n    summary: {\n      point_id: pointId,\n      chunk_type: item.metadata.chunk_type,\n      content_category: item.metadata.content_category,\n      article_number: item.article_number,\n      shopware_product_id: item.metadata.shopware_product_id\n    }\n  }\n};""},""id"":""f6g7h8i9-0j1k-2l3m-4n5o-6p7q8r9s0t1u"",""name"":""Prepare Optimized Qdrant Points"",""type"":""n8n-nodes-base.code"",""typeVersion"":2,""position"":[1340,300]},{""parameters"":{""jsCode"":""// Collect all points for batch upload to Qdrant\nconst items = $input.all();\n\nif (!items || items.length === 0) {\n  throw new Error('No points to upload to Qdrant');\n}\n\nconst points = [];\nconst summaries = [];\nconst errors = [];\nlet articleNumber = null;\n\nitems.forEach((item, index) => {\n  try {\n    if (!item.json || !item.json.point) {\n      errors.push(`Item ${index}: Missing point data`);\n      return;\n    }\n    \n    const point = item.json.point;\n    const summary = item.json.summary;\n    \n    // Validate point structure\n    if (!point.id || !point.vector || !point.payload) {\n      errors.push(`Item ${index}: Invalid point structure`);\n      return;\n    }\n    \n    points.push(point);\n    summaries.push(summary);\n    \n    // Get article number from first valid item\n    if (!articleNumber && item.json.article_number) {\n      articleNumber = item.json.article_number;\n    }\n    \n  } catch (error) {\n    errors.push(`Item ${index}: ${error.message}`);\n  }\n});\n\nif (points.length === 0) {\n  throw new Error('No valid points could be prepared for upload');\n}\n\nconsole.log('üì¶ Collecting points for batch upload...');\nconsole.log(`‚úÖ Prepared ${points.length} points for Qdrant`);\nconsole.log(`‚ö†Ô∏è ${errors.length} errors encountered`);\nconsole.log(`üìã Article Number: ${articleNumber}`);\n\nreturn {\n  json: {\n    points: points,\n    article_number: articleNumber,\n    batch_info: {\n      total_points: points.length,\n      total_errors: errors.length,\n      prepared_at: new Date().toISOString()\n    },\n    errors: errors\n  }\n};""},""id"":""g7h8i9j0-1k2l-3m4n-5o6p-7q8r9s0t1u2v"",""name"":""Collect Points for Batch Upload"",""type"":""n8n-nodes-base.code"",""typeVersion"":2,""position"":[1560,300]},{""parameters"":{""method"":""PUT"",""url"":""http://localhost:6333/collections/held_products_optimized/points"",""sendHeaders"":true,""headerParameters"":{""parameters"":[{""name"":""Content-Type"",""value"":""application/json""}]},""sendBody"":true,""bodyParameters"":{""parameters"":[{""name"":""points"",""value"":""={{ $json.points }}""}]},""options"":{""timeout"":60000,""retry"":{""enabled"":true,""maxRetries"":3,""retryInterval"":5000}}},""id"":""h8i9j0k1-2l3m-4n5o-6p7q-8r9s0t1u2v3w"",""name"":""Upsert Product Data"",""type"":""n8n-nodes-base.httpRequest"",""typeVersion"":4.1,""position"":[1780,300]},{""parameters"":{""jsCode"":""// Generate final completion report\nconst upsertResult = $input.item(0).json;\nconst batchInfo = $node['Collect Points for Batch Upload'].json.batch_info;\nconst articleNumber = $node['Collect Points for Batch Upload'].json.article_number;\n\n// Check if upload was successful\nlet uploadSuccess = false;\nif (upsertResult && upsertResult.status === 'ok') {\n  uploadSuccess = true;\n}\n\nconst completionTime = new Date().toISOString();\n\n// Generate final report\nconst finalReport = {\n  workflow_status: 'completed',\n  completion_time: completionTime,\n  \n  workflow_summary: {\n    article_number: articleNumber,\n    collection_name: 'held_products_optimized',\n    workflow_version: '2.0_shopware_optimized_fixed'\n  },\n  \n  upload_summary: {\n    points_uploaded: batchInfo.total_points,\n    upload_errors: batchInfo.total_errors,\n    upload_success: uploadSuccess,\n    qdrant_response: upsertResult\n  },\n  \n  optimization_features: [\n    'Shopware-specific metadata enhancement',\n    'Deterministic point ID generation',\n    'Article number-based upsert functionality',\n    'Mock embedding generation for testing',\n    'Embedded dataset (no file system dependency)',\n    'Error handling and validation'\n  ],\n  \n  next_steps: [\n    'Integrate with real OpenAI embeddings API',\n    'Connect to live Shopware product data',\n    'Implement automated sync scheduling',\n    'Add monitoring and alerting',\n    'Scale for production workloads'\n  ]\n};\n\nconsole.log('üéâ ===== SHOPWARE VECTORIZATION COMPLETED =====');\nconsole.log(`üìä Article processed: ${finalReport.workflow_summary.article_number}`);\nconsole.log(`‚úÖ Upload success: ${finalReport.upload_summary.upload_success}`);\nconsole.log(`üì¶ Points uploaded: ${finalReport.upload_summary.points_uploaded}`);\nconsole.log(`‚è∞ Completed at: ${completionTime}`);\nconsole.log('================================================');\n\nreturn [{ json: finalReport }];""},""id"":""i9j0k1l2-3m4n-5o6p-7q8r-9s0t1u2v3w4x"",""name"":""Generate Completion Report"",""type"":""n8n-nodes-base.code"",""typeVersion"":2,""position"":[2000,300]}]","{""Manual Trigger"":{""main"":[[{""node"":""Load & Enhance Dataset (Fixed)"",""type"":""main"",""index"":0}]]},""Load & Enhance Dataset (Fixed)"":{""main"":[[{""node"":""Delete Existing Collection"",""type"":""main"",""index"":0}]]},""Delete Existing Collection"":{""main"":[[{""node"":""Create Optimized Collection"",""type"":""main"",""index"":0}]]},""Create Optimized Collection"":{""main"":[[{""node"":""Generate Mock Embeddings"",""type"":""main"",""index"":0}]]},""Generate Mock Embeddings"":{""main"":[[{""node"":""Prepare Optimized Qdrant Points"",""type"":""main"",""index"":0}]]},""Prepare Optimized Qdrant Points"":{""main"":[[{""node"":""Collect Points for Batch Upload"",""type"":""main"",""index"":0}]]},""Collect Points for Batch Upload"":{""main"":[[{""node"":""Upsert Product Data"",""type"":""main"",""index"":0}]]},""Upsert Product Data"":{""main"":[[{""node"":""Generate Completion Report"",""type"":""main"",""index"":0}]]}}","{""executionOrder"":""v1"",""saveManualExecutions"":true,""callerPolicy"":""workflowsFromSameOwner""}",,{},3868d9b0-4eda-4691-af87-39829e532ed9,1,,,2025-07-26 10:21:51.795,2025-07-26 11:02:34,1
d74bb1275e9a48ac,Shopware to Qdrant Product Import (Best Version),1,"[{""parameters"": {}, ""id"": ""f8b0c5e1-8a2d-4c3e-9f1a-2b3c4d5e6f7g"", ""name"": ""Manual Trigger"", ""type"": ""n8n-nodes-base.manualTrigger"", ""typeVersion"": 1, ""position"": [240, 300]}, {""parameters"": {""method"": ""POST"", ""url"": ""https://shop.held.de/api/oauth/token"", ""sendHeaders"": true, ""headerParameters"": {""parameters"": [{""name"": ""Content-Type"", ""value"": ""application/json""}]}, ""sendBody"": true, ""bodyParameters"": {""parameters"": [{""name"": ""grant_type"", ""value"": ""client_credentials""}, {""name"": ""client_id"", ""value"": ""SWIANEPSMGTHMLJMT1BHEFAZNW""}, {""name"": ""client_secret"", ""value"": ""UVJKRGFWZENoVW9OY1ZuUktYNkN6NFRucVNVQU1VR1B0cElhUzE""}]}, ""options"": {""timeout"": 30000, ""retry"": {""enabled"": true, ""maxRetries"": 3, ""retryInterval"": 1000}}}, ""id"": ""a1b2c3d4-5e6f-7g8h-9i0j-1k2l3m4n5o6p"", ""name"": ""Get OAuth Token"", ""type"": ""n8n-nodes-base.httpRequest"", ""typeVersion"": 4.1, ""position"": [460, 300]}, {""parameters"": {""jsCode"": ""// Validate OAuth response and initialize pagination\nconst items = $input.all();\nconst response = items[0].json;\n\n// Check if we got a valid access token\nif (!response.access_token) {\n  throw new Error('Failed to obtain access token from Shopware API');\n}\n\nconsole.log('\u2705 Successfully obtained OAuth token');\nconsole.log(`Token type: ${response.token_type}`);\nconsole.log(`Expires in: ${response.expires_in} seconds`);\n\n// Set initial pagination parameters\nconst paginationData = {\n  page: 1,\n  limit: 10, // Reduced for testing\n  totalPages: null,\n  accessToken: response.access_token,\n  allProducts: [],\n  startTime: new Date().toISOString(),\n  errors: []\n};\n\nreturn [{\n  json: paginationData\n}];""}, ""id"": ""b2c3d4e5-6f7g-8h9i-0j1k-2l3m4n5o6p7q"", ""name"": ""Validate Token & Initialize"", ""type"": ""n8n-nodes-base.code"", ""typeVersion"": 2, ""position"": [680, 300]}, {""parameters"": {""url"": ""=https://shop.held.de/api/product?page={{ $json.page }}&limit={{ $json.limit }}"", ""sendHeaders"": true, ""headerParameters"": {""parameters"": [{""name"": ""Authorization"", ""value"": ""=Bearer {{ $json.accessToken }}""}, {""name"": ""Content-Type"", ""value"": ""application/json""}, {""name"": ""Accept"", ""value"": ""application/json""}]}, ""options"": {""timeout"": 60000, ""retry"": {""enabled"": true, ""maxRetries"": 3, ""retryInterval"": 2000}}}, ""id"": ""c3d4e5f6-7g8h-9i0j-1k2l-3m4n5o6p7q8r"", ""name"": ""Fetch Products Page"", ""type"": ""n8n-nodes-base.httpRequest"", ""typeVersion"": 4.1, ""position"": [900, 300]}, {""parameters"": {""jsCode"": ""// Process the API response with comprehensive error handling\nconst items = $input.all();\nconst response = items[0].json;\n\n// Validate API response structure\nif (!response || typeof response !== 'object') {\n  throw new Error('Invalid API response format');\n}\n\n// Extract products and pagination info with fallbacks\nconst products = response.data || [];\nconst total = response.total || 0;\nconst currentPage = response.page || 1;\nconst limit = response.limit || 10;\nconst totalPages = Math.ceil(total / limit);\n\n// Get existing data from previous iterations\nlet allProducts = $node[\""Validate Token & Initialize\""].json.allProducts || [];\nlet errors = $node[\""Validate Token & Initialize\""].json.errors || [];\n\n// Validate products data\nif (!Array.isArray(products)) {\n  const error = `Page ${currentPage}: Products data is not an array`;\n  errors.push(error);\n  console.warn('\u26a0\ufe0f ' + error);\n} else {\n  // Add current page products to the collection\n  allProducts = allProducts.concat(products);\n  console.log(`\ud83d\udce6 Fetched page ${currentPage}/${totalPages} - ${products.length} products (Total: ${allProducts.length}/${total})`);\n}\n\n// Determine if we need to fetch more pages (limit to 2 pages for testing)\nconst hasMorePages = currentPage < Math.min(totalPages, 2);\n\nif (hasMorePages) {\n  // Return data for next page\n  return [{\n    json: {\n      page: currentPage + 1,\n      limit: limit,\n      totalPages: totalPages,\n      accessToken: $node[\""Validate Token & Initialize\""].json.accessToken,\n      allProducts: allProducts,\n      hasMorePages: true,\n      currentTotal: allProducts.length,\n      expectedTotal: total,\n      startTime: $node[\""Validate Token & Initialize\""].json.startTime,\n      errors: errors\n    }\n  }];\n} else {\n  // All pages fetched, return final collection\n  const endTime = new Date().toISOString();\n  const duration = new Date(endTime) - new Date($node[\""Validate Token & Initialize\""].json.startTime);\n  \n  console.log(`\ud83c\udf89 Pagination complete! Fetched ${allProducts.length} products in ${Math.round(duration/1000)}s`);\n  \n  if (errors.length > 0) {\n    console.warn(`\u26a0\ufe0f ${errors.length} errors encountered during fetch:`);\n    errors.forEach(error => console.warn(`  - ${error}`));\n  }\n  \n  return [{\n    json: {\n      allProducts: allProducts,\n      hasMorePages: false,\n      totalProducts: allProducts.length,\n      paginationComplete: true,\n      startTime: $node[\""Validate Token & Initialize\""].json.startTime,\n      endTime: endTime,\n      duration: Math.round(duration/1000),\n      errors: errors\n    }\n  }];\n}""}, ""id"": ""d4e5f6g7-8h9i-0j1k-2l3m-4n5o6p7q8r9s"", ""name"": ""Process Page & Check Pagination"", ""type"": ""n8n-nodes-base.code"", ""typeVersion"": 2, ""position"": [1120, 300]}, {""parameters"": {""conditions"": {""options"": {""caseSensitive"": true, ""leftValue"": """", ""typeValidation"": ""strict""}, ""conditions"": [{""id"": ""c1a2b3c4-d5e6-f7g8-h9i0-j1k2l3m4n5o6"", ""leftValue"": ""={{ $json.hasMorePages }}"", ""rightValue"": true, ""operator"": {""type"": ""boolean"", ""operation"": ""equal"", ""rightType"": ""boolean""}}], ""combinator"": ""and""}, ""options"": {}}, ""id"": ""e5f6g7h8-9i0j-1k2l-3m4n-5o6p7q8r9s0t"", ""name"": ""Has More Pages?"", ""type"": ""n8n-nodes-base.if"", ""typeVersion"": 2, ""position"": [1340, 300]}, {""parameters"": {""jsCode"": ""// Transform products for vector storage with enhanced error handling\nconst items = $input.all();\nconst allProducts = items[0].json.allProducts;\nconst previousErrors = items[0].json.errors || [];\n\nif (!Array.isArray(allProducts)) {\n  throw new Error('Products data is not an array');\n}\n\nconsole.log(`\ud83d\udd04 Starting transformation of ${allProducts.length} products...`);\n\nconst transformedProducts = [];\nconst transformErrors = [];\n\nallProducts.forEach((product, index) => {\n  try {\n    // Validate required fields\n    if (!product || typeof product !== 'object') {\n      transformErrors.push(`Product ${index}: Invalid product object`);\n      return;\n    }\n\n    if (!product.id) {\n      transformErrors.push(`Product ${index}: Missing product ID`);\n      return;\n    }\n\n    // Safely extract and combine text fields\n    const textParts = [];\n    \n    // Extract name from translations or direct field\n    let productName = product.name;\n    if (!productName && product.translations && Array.isArray(product.translations)) {\n      const translation = product.translations.find(t => t.name);\n      productName = translation?.name;\n    }\n    if (productName && typeof productName === 'string') {\n      textParts.push(productName.trim());\n    }\n    \n    // Extract description from translations or direct field\n    let productDescription = product.description;\n    if (!productDescription && product.translations && Array.isArray(product.translations)) {\n      const translation = product.translations.find(t => t.description);\n      productDescription = translation?.description;\n    }\n    if (productDescription && typeof productDescription === 'string') {\n      // Strip HTML tags from description\n      const cleanDescription = productDescription.replace(/<[^>]*>/g, ' ').replace(/\\s+/g, ' ').trim();\n      if (cleanDescription.length > 0) {\n        textParts.push(cleanDescription);\n      }\n    }\n    \n    // Add EAN if available\n    if (product.ean && typeof product.ean === 'string') {\n      textParts.push(`EAN: ${product.ean.trim()}`);\n    }\n    \n    // Add manufacturer number if available\n    if (product.manufacturerNumber && typeof product.manufacturerNumber === 'string') {\n      textParts.push(`MFG: ${product.manufacturerNumber.trim()}`);\n    }\n\n    // Combine all text parts\n    const textContent = textParts.filter(part => part.length > 0).join(' | ');\n    \n    // For products with minimal content, create basic description\n    let finalTextContent = textContent;\n    if (finalTextContent.trim().length === 0) {\n      finalTextContent = `Product ID: ${product.id}`;\n      if (product.ean) finalTextContent += ` | EAN: ${product.ean}`;\n      if (product.active) finalTextContent += ' | Active Product';\n    }\n\n    // Safely extract price information\n    let price = 0;\n    let currency = 'EUR';\n    if (Array.isArray(product.price) && product.price.length > 0) {\n      const priceObj = product.price[0];\n      if (priceObj && typeof priceObj.gross === 'number') {\n        price = priceObj.gross;\n      }\n      if (priceObj && priceObj.currencyId) {\n        currency = priceObj.currencyId;\n      }\n    }\n\n    // Prepare metadata with safe defaults\n    const metadata = {\n      id: product.id,\n      name: productName || '',\n      price: price,\n      currency: currency,\n      stock: typeof product.stock === 'number' ? product.stock : 0,\n      active: Boolean(product.active),\n      manufacturerNumber: product.manufacturerNumber || '',\n      ean: product.ean || '',\n      createdAt: product.createdAt || null,\n      updatedAt: product.updatedAt || null\n    };\n\n    transformedProducts.push({\n      pageContent: finalTextContent,\n      metadata: metadata\n    });\n\n  } catch (error) {\n    transformErrors.push(`Product ${product.id || index}: ${error.message}`);\n  }\n});\n\nconsole.log(`\u2705 Transformed ${transformedProducts.length} products successfully`);\nif (transformErrors.length > 0) {\n  console.warn(`\u26a0\ufe0f ${transformErrors.length} transformation errors:`);\n  transformErrors.slice(0, 5).forEach(error => console.warn(`  - ${error}`));\n}\n\n// Return transformed products with error tracking\nconst result = transformedProducts.map(product => ({ \n  json: {\n    ...product,\n    _metadata: {\n      totalErrors: previousErrors.length + transformErrors.length,\n      transformErrors: transformErrors.length\n    }\n  }\n}));\n\nif (result.length === 0) {\n  throw new Error('No products could be transformed successfully');\n}\n\nreturn result;""}, ""id"": ""f6g7h8i9-0j1k-2l3m-4n5o-6p7q8r9s0t1u"", ""name"": ""Transform Products for Vector Storage"", ""type"": ""n8n-nodes-base.code"", ""typeVersion"": 2, ""position"": [1560, 420]}, {""parameters"": {""jsCode"": ""// Store products in Qdrant using HTTP API\nconst items = $input.all();\n\nif (!Array.isArray(items) || items.length === 0) {\n  throw new Error('No products to store in Qdrant');\n}\n\nconsole.log(`\ud83d\udd04 Preparing to store ${items.length} products in Qdrant...`);\n\n// Prepare points for Qdrant\nconst points = [];\nconst errors = [];\n\nitems.forEach((item, index) => {\n  try {\n    const product = item.json;\n    \n    if (!product || !product.pageContent || !product.metadata || !product.metadata.id) {\n      errors.push(`Item ${index}: Missing required fields`);\n      return;\n    }\n\n    // Create a simple vector (placeholder since we don't have embeddings yet)\n    // In a real implementation, you'd generate embeddings from pageContent\n    const vector = new Array(1536).fill(0).map(() => Math.random() * 0.1);\n    \n    const point = {\n      id: product.metadata.id,\n      vector: vector,\n      payload: {\n        content: product.pageContent,\n        name: product.metadata.name,\n        price: product.metadata.price,\n        currency: product.metadata.currency,\n        stock: product.metadata.stock,\n        active: product.metadata.active,\n        ean: product.metadata.ean,\n        manufacturerNumber: product.metadata.manufacturerNumber,\n        createdAt: product.metadata.createdAt,\n        updatedAt: product.metadata.updatedAt\n      }\n    };\n    \n    points.push(point);\n    \n  } catch (error) {\n    errors.push(`Item ${index}: ${error.message}`);\n  }\n});\n\nif (points.length === 0) {\n  throw new Error('No valid points could be prepared for Qdrant storage');\n}\n\nconsole.log(`\u2705 Prepared ${points.length} points for Qdrant storage`);\nif (errors.length > 0) {\n  console.warn(`\u26a0\ufe0f ${errors.length} preparation errors:`);\n  errors.slice(0, 3).forEach(error => console.warn(`  - ${error}`));\n}\n\n// Return the points data for the HTTP request\nreturn [{\n  json: {\n    points: points,\n    totalPoints: points.length,\n    errors: errors\n  }\n}];""}, ""id"": ""h7i8j9k0-1l2m-3n4o-5p6q-7r8s9t0u1v2w"", ""name"": ""Prepare Qdrant Points"", ""type"": ""n8n-nodes-base.code"", ""typeVersion"": 2, ""position"": [1670, 420]}, {""parameters"": {""method"": ""PUT"", ""url"": ""https://8ec957ec-27b4-4041-9714-f8dde751b007.europe-west3-0.gcp.cloud.qdrant.io:6333/collections/shopware_products/points"", ""sendHeaders"": true, ""headerParameters"": {""parameters"": [{""name"": ""api-key"", ""value"": ""eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhY2Nlc3MiOiJtIn0.0J2RW3imIbLAdONM5mlaC_fVai3TcUjLO6qy_639Quw""}, {""name"": ""Content-Type"", ""value"": ""application/json""}]}, ""sendBody"": true, ""bodyParameters"": {""parameters"": [{""name"": ""points"", ""value"": ""={{ $json.points }}""}]}, ""options"": {""timeout"": 60000, ""retry"": {""enabled"": true, ""maxRetries"": 2, ""retryInterval"": 3000}}}, ""id"": ""g7h8i9j0-1k2l-3m4n-5o6p-7q8r9s0t1u2v"", ""name"": ""Store in Qdrant Vector DB"", ""type"": ""n8n-nodes-base.httpRequest"", ""typeVersion"": 4.1, ""position"": [1890, 420]}, {""parameters"": {""jsCode"": ""// Enhanced completion logging with Qdrant storage results\nconst items = $input.all();\nconst qdrantResponse = items[0].json;\n\n// Parse Qdrant response\nlet successfulInserts = 0;\nlet failedInserts = 0;\nlet totalProcessed = 0;\n\nif (qdrantResponse && qdrantResponse.status === 'ok') {\n  successfulInserts = qdrantResponse.result?.operation_id ? 1 : 0;\n  totalProcessed = 1;\n} else {\n  failedInserts = 1;\n  totalProcessed = 1;\n}\n\nconst completionTime = new Date().toISOString();\n\n// Log completion status\nconsole.log('\ud83c\udf89 ===== IMPORT COMPLETED =====');\nconsole.log(`\ud83d\udcca Batch operations processed: ${totalProcessed}`);\nconsole.log(`\u2705 Successfully stored in Qdrant: ${successfulInserts}`);\nif (failedInserts > 0) {\n  console.log(`\u274c Failed to store: ${failedInserts}`);\n  console.log(`Response: ${JSON.stringify(qdrantResponse, null, 2)}`);\n}\nconsole.log(`\u23f0 Completion time: ${completionTime}`);\nconsole.log('================================');\n\nreturn [{\n  json: {\n    status: 'completed',\n    totalProcessed: totalProcessed,\n    successfulInserts: successfulInserts,\n    failedInserts: failedInserts,\n    errorRate: totalProcessed > 0 ? (failedInserts / totalProcessed * 100).toFixed(2) + '%' : '0%',\n    message: `Successfully processed batch operation, ${successfulInserts} operations completed`,\n    timestamp: completionTime,\n    qdrantResponse: qdrantResponse\n  }\n}];""}, ""id"": ""i9j0k1l2-3m4n-5o6p-7q8r-9s0t1u2v3w4x"", ""name"": ""Log Completion & Statistics"", ""type"": ""n8n-nodes-base.code"", ""typeVersion"": 2, ""position"": [2110, 420]}]","{""Manual Trigger"": {""main"": [[{""node"": ""Get OAuth Token"", ""type"": ""main"", ""index"": 0}]]}, ""Get OAuth Token"": {""main"": [[{""node"": ""Validate Token & Initialize"", ""type"": ""main"", ""index"": 0}]]}, ""Validate Token & Initialize"": {""main"": [[{""node"": ""Fetch Products Page"", ""type"": ""main"", ""index"": 0}]]}, ""Fetch Products Page"": {""main"": [[{""node"": ""Process Page & Check Pagination"", ""type"": ""main"", ""index"": 0}]]}, ""Process Page & Check Pagination"": {""main"": [[{""node"": ""Has More Pages?"", ""type"": ""main"", ""index"": 0}]]}, ""Has More Pages?"": {""main"": [[{""node"": ""Fetch Products Page"", ""type"": ""main"", ""index"": 0}], [{""node"": ""Transform Products for Vector Storage"", ""type"": ""main"", ""index"": 0}]]}, ""Transform Products for Vector Storage"": {""main"": [[{""node"": ""Prepare Qdrant Points"", ""type"": ""main"", ""index"": 0}]]}, ""Prepare Qdrant Points"": {""main"": [[{""node"": ""Store in Qdrant Vector DB"", ""type"": ""main"", ""index"": 0}]]}, ""Store in Qdrant Vector DB"": {""main"": [[{""node"": ""Log Completion & Statistics"", ""type"": ""main"", ""index"": 0}]]}}","{""executionOrder"": ""v1"", ""saveManualExecutions"": true, ""callerPolicy"": ""workflowsFromSameOwner""}",null,,1,1,,,2025-07-26T12:07:36.019166Z,2025-07-26T12:07:36.019166Z,0
